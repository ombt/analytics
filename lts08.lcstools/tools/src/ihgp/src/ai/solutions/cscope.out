cscope 11 $HOME/src/ai/solutions -c 0000315762
	@include/aigraph.h

25 #ifndef 
_AIGRAPH_H_


26 #define 
	#_AIGRAPH_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"aisearch.h
"

30 #include 
	~"bisearch.h
"

31 #include 
	~"ainodes.h
"

39 
class
 
	cBreadthGraph
 : 
public
 
Search


41 
public
:

42 
BreadthGraph
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

43 int 
add
(
Node
 *);

52 
class
 
	cDepthGraph
 : 
public
 
Search


54 
public
:

55 
DepthGraph
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

56 int 
add
(
Node
 *);

57 void 
setdepth
(unsigned);

58 unsigned 
	$getdepth
() const;

59 
private
:

60 unsigned 
maxdepth
;

69 
class
 
	cBiBreadthGraph
 : 
public
 
BiSearch


71 
public
:

72 
	`BiBreadthGraph
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

73 int 
	`add
(
IntrList
<
Node
> *, IntrList<Node> *, Node *);

82 
class
 
	cBiDepthGraph
 : 
public
 
BiSearch


84 
public
:

85 
	`BiDepthGraph
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

86 int 
	`add
(
IntrList
<
Node
> *, IntrList<Node> *, Node *);

102 
class
 
	cAStar
 : 
public
 
Search


104 
public
:

105 
	`AStar
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

106 int 
	`add
(
Node
 *);

107 
virtual
 int 
	`compute_g
(const 
Node
 *) = 0;

108 
virtual
 int 
	`compute_h
(const 
Node
 *) = 0;

123 
class
 
	cUnicostGraph
 : 
public
 
Search


125 
public
:

126 
	`UnicostGraph
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

127 int 
	`add
(
Node
 *);

128 
virtual
 int 
	`compute_g
(const 
Node
 *) = 0;

	@include/ainodes.h

25 #ifndef 
_AINODES_H_


26 #define 
	#_AINODES_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~"xarray.h
"

31 #include 
	~"xlist.h
"

51 
class
 
	cNode
 : 
public
 
ListNode


53 
public
:

54 
Node
();

55 
Node
 *
	$clone
() const;

56 void 
	`setparent
(
Node
 *);

57 
Node
 *
	$getparent
() const;

59 
virtual
 int 
operator
==(const 
Node
 &) const = 0;

60 
virtual
 int 
operator
<(const 
Node
 &) const;

61 
virtual
 void 
	$display
() const = 0;

62 
virtual
 
Node
 *
	`do_operator
(int);

63 
virtual
 
IntrList
<
Node
> *
	`expand
(int);

64 
private
:

65 
Node
 *
parent
;

74 
class
 
	cDepthNode
 : 
public
 
Node


76 
public
:

77 
	`DepthNode
();

78 unsigned 
	$getdepth
() const;

79 void 
	`setdepth
(unsigned);

80 
private
:

81 unsigned 
depth
;

93 
class
 
	cUniNode
 : 
public
 
Node


95 
public
:

96 
	`UniNode
();

97 int 
operator
<(const 
Node
 &) const;

98 int 
	$get_g
() const;

99 void 
	`set_g
(int);

100 
private
:

101 int 
g
;

114 
class
 
	cBestNode
 : 
public
 
UniNode


116 
public
:

117 
	`BestNode
();

118 int 
operator
<(const 
Node
 &) const;

119 int 
	$get_f
() const;

120 void 
	`set_f
(int);

121 
private
:

123 
f
;

138 enum 
	eTypeOfNode
 { 
OR
, 
AND
 };

139 enum 
	eNodeStat
 { 
Unsolvable
, 
Solved
, 
Undef
 };

141 
class
 
	cAONode
 : 
public
 
Node


143 
public
:

144 
	`AONode
();

145 
	`AONode
(int);

146 
AONode
 *
	$clone
() const;

147 void 
	`incn_left
();

149 
virtual
 
TypeOfNode
 
	$gettype
() const = 0;

150 
virtual
 int 
	$get_nsucc
() const = 0;

151 
virtual
 
AONode
 *
	$getsucc
(int = 0) const = 0;

152 
virtual
 void 
	`setstatus
(
NodeStat
) = 0;

153 
virtual
 
NodeStat
 
	$getstatus
() const = 0;

154 
virtual
 int 
	`setsolved
(
AONode
 *) = 0;

155 
virtual
 int 
	`setunsolvable
() = 0;

156 
protected
:

157 
NodeStat
 
status
;

158 int 
n_left
;

178 
class
 
	cAndNode
 : 
public
 
AONode


180 
public
:

181 
	`AndNode
();

182 
	`AndNode
(int 
n_nodes
);

184 
TypeOfNode
 
	$gettype
() const;

185 void 
	`setstatus
(
NodeStat
);

186 
NodeStat
 
	$getstatus
() const;

187 int 
	`setsolved
(
AONode
 *);

188 int 
	`setunsolvable
();

189 
AONode
 *
	$getsucc
(int) const;

190 int 
	$get_nsucc
() const;

191 void 
	`setsucc
(int, 
AONode
 *);

192 void 
	`addsucc
(
AONode
 *);

193 void 
	$display
() const;

194 int 
operator
==(const 
Node
 &) const;

195 
private
:

196 static 
TypeOfNode
 
type
;

198 
PtrArray
<
AONode
> 
succlist
;

207 
class
 
	cOrNode
 : 
public
 
AONode


209 
public
:

210 
	`OrNode
();

212 
TypeOfNode
 
	$gettype
() const;

213 int 
	$get_nsucc
() const;

214 
AONode
 *
	$getsucc
(int 
n
) const;

215 void 
	`setstatus
(
NodeStat
);

216 
NodeStat
 
	$getstatus
() const;

217 int 
	`setsolved
(
AONode
 *);

218 int 
	`setunsolvable
();

219 
private
:

220 static 
TypeOfNode
 
type
;

222 
AONode
 *
succ
;

243 
class
 
	cBackNode
 : 
public
 
ListNode


245 
public
:

246 
	`BackNode
();

247 
virtual
 int 
operator
==(const 
BackNode
 &) const = 0;

248 
virtual
 
BackNode
 *
	`do_operator
(int);

249 
virtual
 
BackNode
 *
	`expand_one
(int);

250 
virtual
 void 
	$display
() const = 0;

251 
BackNode
 *
	$clone
() const;

252 
private
:

253 int 
last_op
;

	@include/aisearch.h

25 #ifndef 
_AISEARCH_H_


26 #define 
	#_AISEARCH_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"ainodes.h
"

46 
class
 
	cSearch


48 
	mpublic
:

49 
Search
(int 
numop
, 
Node
 *
start
, Node *
goal
);

50 
	mvirtual
 ~
Search
();

51 
virtual
 int 
is_goal
(const 
Node
 *);

53 int 
generate
();

54 void 
	$display
() const;

55 
IntrList
<
Node
> *
	`get_sol
();

56 
Node
 *
	$get_goal
() const;

57 void 
	`set_startnode
(
Node
 *);

58 void 
	`set_goalnode
(
Node
 *);

59 void 
	`clear
();

60 
private
:

61 
Node
 *
	`solve
();

62 
virtual
 int 
	`add
(
Node
 *) = 0;

63 void 
	$print_sol
(
Node
 *) const;

65 int 
num_op
;

66 
Node
 *
goalnode
,

67 *
solgoal
;

68 
protected
:

69 
SortedIntrList
<
Node
> 
open
,

70 
closed
;

	@include/aitree.h

25 #ifndef 
_AITREE_H_


26 #define 
	#_AITREE_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"ainodes.h
"

30 #include 
	~"aisearch.h
"

31 #include 
	~"bisearch.h
"

32 #include 
	~"aosearch.h
"

40 
class
 
	cBreadthTree
 : 
public
 
Search


42 
public
:

43 
BreadthTree
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

44 int 
add
(
Node
 *);

53 
class
 
	cDepthTree
 : 
public
 
Search


55 
public
:

56 
DepthTree
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

57 int 
add
(
Node
 *);

58 void 
setdepth
(unsigned);

59 unsigned 
	$getdepth
() const;

60 
private
:

61 unsigned 
maxdepth
;

76 
class
 
	cUnicostTree
 : 
public
 
Search


78 
public
:

79 
	`UnicostTree
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

80 int 
	`add
(
Node
 *);

81 
virtual
 int 
	`compute_g
(const 
Node
 *) = 0;

90 
class
 
	cBiDepthTree
 : 
public
 
BiSearch


92 
public
:

93 
	`BiDepthTree
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

94 int 
	`add
(
IntrList
<
Node
> *, IntrList<Node> *, Node *);

103 
class
 
	cBiBreadthTree
 : 
public
 
BiSearch


105 
public
:

106 
	`BiBreadthTree
(int 
op
, 
Node
 *
start
 = 0, Node *
goal
 = 0);

107 int 
	`add
(
IntrList
<
Node
> *, IntrList<Node> *, Node *);

117 
class
 
	cAODepthTree
 : 
public
 
AOSearch


119 
public
:

120 
	`AODepthTree
(int 
op
, 
AONode
 *
start
 = 0);

121 int 
	`add
(
AONode
 *);

130 
class
 
	cAOBreadthTree
 : 
public
 
AOSearch


132 
public
:

133 
	`AOBreadthTree
(int 
op
, 
AONode
 *
start
 = 0);

134 int 
	`add
(
AONode
 *);

	@include/aosearch.h

25 #ifndef 
_AOSEARCH_H_


26 #define 
	#_AOSEARCH_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"ainodes.h
"

46 
class
 
	cAOSearch


48 
	mpublic
:

49 
AOSearch
(int 
numop
, 
AONode
 *
start
);

50 
	mvirtual
 ~
AOSearch
();

51 
virtual
 int 
is_terminal
(const 
AONode
 *) = 0;

53 int 
generate
();

54 void 
display
();

55 
	mIntrList
<
	mNode
> *
get_sol
();

56 void 
set_startnode
(
AONode
 *);

57 void 
clear
();

58 
	mprivate
:

59 int 
solve
();

60 
virtual
 int 
add
(
AONode
 *) = 0;

61 int 
solvable
(
AONode
 *);

62 int 
unsolvable
(
AONode
 *);

63 void 
prune
(
NodeStat
);

64 void 
print_sol
(
AONode
 *);

65 void 
addnodetosol
(
IntrList
<
Node
> *, 
AONode
 *);

66 int 
deletable
(
AONode
 *, 
NodeStat
);

69 
	mnum_op
;

70 
AONode


71 *
	mstartnode
;

72 
	mprotected
:

73 
IntrList
<
AONode
> 
open
,

74 
	mclosed
;

	@include/bisearch.h

25 #ifndef 
_BISEARCH_H_


26 #define 
	#_BISEARCH_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"ainodes.h
"

42 
class
 
	cBiSearch


44 
	mpublic
:

45 
BiSearch
(int 
op
, 
Node
 *
start
, Node *
goal
);

46 
	mvirtual
 ~
BiSearch
();

48 int 
generate
();

49 void 
	$display
() const;

50 
IntrList
<
Node
> *
	`get_sol
();

51 void 
	`set_startnode
(
Node
 *);

52 void 
	`set_goalnode
(
Node
 *);

53 void 
	`clear
();

54 
private
:

56 
Node
 *
	`bisolve
();

58 
Node
 *
	`solve
(
IntrList
<Node> *, IntrList<Node> *, IntrList<Node> *);

60 
virtual
 int 
	`add
(
IntrList
<
Node
> *, IntrList<Node> *, Node *) = 0;

61 void 
	$print_sol
(
Node
 *) const;

62 void 
	$print_sol_2
(
Node
 *) const;

64 int 
num_op
,

65 
foundsol
;

66 
protected
:

67 
IntrList
<
Node
> 
s_open
,

68 
s_closed
,

69 
t_open
,

70 
t_closed
;

	@include/blist.h

25 #ifndef 
_BLIST_H_


26 #define 
	#_BLIST_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<iostream.h
>

32 #define 
	#NoDel
 0

	)
33 #define 
	#DoDel
 1

	)
34 #define 
	#DontManage
 0

	)
35 #define 
	#DoManage
 1

	)
37 
class
 
	cListNode


39 
friend
 
class
 
	mBasList
;

40 
friend
 
class
 
	mSortedBasList
;

41 
friend
 
class
 
	mBasListIterator
;

42 
friend
 
class
 
	mROBasListIterator
;

43 
	mpublic
:

44 
virtual
 ~
	$ListNode
() { }

45 
private
:

46 
ListNode
 *
next
,

47 *
prev
;

48 
	}
};

51 
class
 
	cBasList


53 
friend
 
class
 
	mBasListIterator
;

54 
friend
 
class
 
	mROBasListIterator
;

55 
	mpublic
:

56 
	$BasList
() { 
head
 = 
tail
 = 
found
 = 0; 
nodecount
 = 0; }

57 
virtual
 ~
	$BasList
() { 
	`clear
(); 
	}
}

58 
BasList
(const BasList &
other
);

59 
	gBasList
 &
	goperator
=(const 
BasList
 &);

60 int 
	goperator
==(const 
BasList
 &) const;

62 
virtual
 int 
	$compareeq
(
ListNode
 *, ListNode *) const = 0;

63 
virtual
 int 
	$comparelt
(
ListNode
 *, ListNode *) const { return(0); 
	}
}

64 
virtual
 void 
	$clearnode
(
ListNode
 *) { 
	}
}

65 
virtual
 
ListNode
 *
	$copynode
(ListNode *) const = 0;

67 
ListNode
 *
operator
[](int) const;

69 void 
	`addtohead
(
ListNode
 *);

70 void 
	`addtotail
(
ListNode
 *);

71 void 
	`insert
(
ListNode
 *);

73 
ListNode
 *
	$gethead
() const { return(
head
); 
	}
}

74 
ListNode
 *
	$gettail
() const { return(
tail
); 
	}
}

75 
ListNode
 *
	$getfound
() const { return(
found
); 
	}
}

77 int 
	$getcount
() const { return(
nodecount
); 
	}
}

78 int 
	$is_empty
() const { return(
head
 == 0); 
	}
}

80 int 
find
(
ListNode
 *);

81 
ListNode
 *
lookup
(ListNode *);

83 void 
	$remove_head
(int 
clr
 = 0, int 
del
 = 1)

84 { 
	`remove_node
(
head
, 
del
, 
clr
); 
	}
}

85 void 
	$remove_tail
(int 
clr
 = 0, int 
del
 = 1)

86 { 
	`remove_node
(
tail
, 
del
, 
clr
); 
	}
}

87 void 
	$remove_found
(int 
clr
 = 0, int 
del
 = 1)

88 { 
	`remove_node
(
found
, 
del
, 
clr
); 
	}
}

90 void 
clear
(int 
clr
 = 0, int 
del
 = 1);

92 
	gprotected
:

93 void 
remove_node
(
ListNode
 *, int, int);

94 void 
copylist
(const 
BasList
 &);

95 
ListNode
 *
	ghead
,

96 *
	gtail
,

97 *
	gfound
;

98 int 
	gnodecount
;

102 
class
 
	cSortedBasList
 : 
public
 
BasList


104 
public
:

105 
SortedBasList
 &
operator
=(const SortedBasList &);

108 
inline


109 
	gSortedBasList
 &SortedBasList::
operator
=(const 
SortedBasList
 &
other
)

111 
BasList
::
operator
=(
other
);

112 return(*
	gthis
);

116 
class
 
	cBasListIterator


118 
	mpublic
:

119 
	$BasListIterator
(
BasList
 &
li
) { 
mine
 = &li; 
current
 = li.
head
; }

120 
	$BasListIterator
() { 
mine
 = 0; 
current
 = 0; 
	}
}

121 void 
	$setlist
(
BasList
 &
li
) { 
mine
 = &li; 
current
 = li.
head
; 
	}
}

123 
ListNode
 *
	$getfirst
() { 
current
 = 
mine
->
head
; return(current); 
	}
}

124 
ListNode
 *
	$getlast
() { 
current
 = 
mine
->
tail
; return(current); 
	}
}

125 
ListNode
 *
	$getnext
() { return(
current
 ? current = current->
next
 : 0); 
	}
}

126 
ListNode
 *
	$getprev
() { return(
current
 ? current = current->
prev
 : 0); 
	}
}

127 
ListNode
 *
	$getcurrent
() { return(
current
); 
	}
}

129 int 
	$notempty
() const { return(
current
 != 0); 
	}
}

131 void 
remove_current
(int 
clr
 = 0, int 
del
 = 1);

132 
	gprivate
:

133 
BasList
 *
mine
;

134 
ListNode
 *
	gcurrent
;

137 
class
 
	cROBasListIterator


139 
	mpublic
:

140 
	$ROBasListIterator
(const 
BasList
 &
li
) { 
mine
 = &li; 
current
 = li.
head
; }

141 
	$ROBasListIterator
() { 
mine
 = 0; 
current
 = 0; 
	}
}

142 void 
	$setlist
(const 
BasList
 &
li
) { 
mine
 = &li; 
current
 = li.
head
; 
	}
}

144 const 
ListNode
 *
	$getfirst
() { 
current
 = 
mine
->
head
; return(current); 
	}
}

145 const 
ListNode
 *
	$getlast
() { 
current
 = 
mine
->
tail
; return(current); 
	}
}

146 const 
ListNode
 *
	$getnext
() { return(
current
 ? current = current->
next
 : 0); 
	}
}

147 const 
ListNode
 *
	$getprev
() { return(
current
 ? current = current->
prev
 : 0); 
	}
}

148 const 
ListNode
 *
	$getcurrent
() { return(
current
); 
	}
}

150 int 
	$notempty
() const { return(
current
 != 0); 
	}
}

152 
	gprivate
:

153 const 
BasList
 *
mine
;

154 const 
ListNode
 *
	gcurrent
;

	@include/btrack.h

25 #ifndef 
_BTRACK_H_


26 #define 
	#_BTRACK_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"ainodes.h
"

43 
class
 
	cBackTrack


45 
	mpublic
:

46 
BackTrack
(int 
n
, 
BackNode
 *
start
 = 0, BackNode *
goal
 = 0);

47 
	mvirtual
 ~
BackTrack
();

48 
virtual
 int 
is_goal
(const 
BackNode
 *);

50 int 
generate
();

51 int 
generate_next
();

52 void 
	$display
() const;

53 const 
IntrList
<
BackNode
> *
	`get_sol
();

54 const 
BackNode
 *
	$get_goal
() const;

55 void 
	`setdepth
(int);

56 void 
	`setcheck
(int);

57 void 
	`set_startnode
(
BackNode
 *);

58 void 
	`set_goalnode
(
BackNode
 *);

59 void 
	`clear
();

60 
private
:

61 int 
	`solve
();

63 
IntrList
<
BackNode
> 
stack
;

64 
BackNode
 *
goalnode
;

65 int 
num_op
,

66 
do_lookup
,

67 
depth
;

	@include/logic.h

25 #ifndef 
_LOGIC_H_


26 #define 
	#_LOGIC_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

31 #include 
	~<ctype.h
>

32 #include 
	~<iostream.h
>

33 #include 
	~"xstring.h
"

34 #include 
	~"xarray.h
"

41 enum 
	eTermType
 {
	mVar_T
, 
	mConstant_T
, 
	mComplex_T
};

44 
class
 
	gSubstitution
;

45 
class
 
	gVar
;

56 
class
 
	cTerm


58 
	mpublic
:

59 
virtual
 ~
Term
();

60 
virtual
 
TermType
 
	$gettype
() const = 0;

61 
virtual
 int 
	$unify_me
(const 
Term
 &, 
Substitution
 &) const = 0;

62 
virtual
 int 
	$match
(const 
Term
 &) const = 0;

63 
virtual
 
Term
 *
	$dup
() const = 0;

64 
virtual
 void 
	$display
(
ostream
 &) const = 0;

65 
virtual
 const 
Term
 *
	$get_realvalue
(const 
Substitution
 &) const = 0;

66 
virtual
 int 
	$occurs_in
(const 
Var
 *) const;

67 
Term
 *
	$clone
() const;

68 int 
operator
==(const 
Term
 &
other
);

87 
class
 
	cVar
 : 
public
 
Term


89 
public
:

90 
	`Var
(const char *);

91 
TermType
 
	$gettype
() const;

92 int 
	$unify_me
(const 
Term
 &, 
Substitution
 &) const;

93 int 
	$match
(const 
Term
 &) const;

94 
Term
 *
	$dup
() const;

95 void 
	$display
(
ostream
 &) const;

96 void 
	`update
();

97 const 
Term
 *
	$get_realvalue
(const 
Substitution
 &) const;

98 
private
:

99 int 
val
;

100 char 
name
;

101 static 
TermType
 
type
;

102 static unsigned int 
vartable
[26];

109 
class
 
	cConstant
 : 
public
 
Term


111 
public
:

112 
	`Constant
(const char *);

113 
TermType
 
	$gettype
() const;

114 int 
	$unify_me
(const 
Term
 &, 
Substitution
 &) const;

115 int 
	$match
(const 
Term
 &) const;

116 
Term
 *
	$dup
() const;

117 void 
	$display
(
ostream
 &) const;

118 const 
Term
 *
	$get_realvalue
(const 
Substitution
 &) const;

119 
private
:

120 
String
 
val
;

122 static 
TermType
 
type
;

133 
class
 
	cComplex
 : 
public
 
Term


135 
friend
 
ostream
 &
operator
<<(ostream &, const 
Complex
 &);

136 
public
:

137 
	`Complex
();

138 
	`Complex
(const char *);

139 
Complex
 &
operator
=(const Complex &);

140 
Complex
 &
operator
=(const char *);

141 int 
operator
==(const 
Complex
 &) const;

142 int 
operator
!=(const 
Complex
 &) const;

143 
Complex
 *
	$clone
() const;

144 int 
	$unify
(const 
Complex
 &, 
Substitution
 &) const;

145 void 
	`apply_subst
(
Substitution
 &);

146 void 
	`update_vars
();

147 void 
	`update_vars
(
Substitution
 &);

148 void 
	$display
() const;

149 int 
	$notempty
() const;

150 
private
:

151 
TermType
 
	$gettype
() const;

152 int 
	$match
(const 
Term
 &) const;

153 int 
	$unify_me
(const 
Term
 &, 
Substitution
 &) const;

154 
Term
 *
	$dup
() const;

155 const 
Term
 *
	$get_realvalue
(const 
Substitution
 &) const;

156 int 
	$occurs_in
(const 
Var
 *) const;

157 void 
	$display
(
ostream
 &) const;

158 void 
	`parse_string
(const char *);

159 char *
	`read_body
(char *, char *);

160 void 
	`parse_error
(char *, char *, char *);

162 
String
 
functor
;

163 
PtrArray
<
Term
> 
arguments
;

164 static 
TermType
 
type
;

172 
class
 
	cBinding


174 
friend
 
ostream
 &
operator
<<(ostream &, const 
Binding
 &);

175 
friend
 
Substitution
;

176 
public
:

177 
	`Binding
(const 
Binding
 &);

178 
	`Binding
(const 
Var
 &, const 
Term
 &);

179 ~
	`Binding
();

180 
Binding
 &
operator
=(const Binding &);

181 int 
operator
==(const 
Binding
 &) const;

182 
Binding
 *
	$clone
() const;

183 void 
	`replace_binding
(
Binding
 *);

184 
private
:

185 
Var
 *
first
;

186 
Term
 *
second
;

195 
class
 
	cSubstitution


197 
friend
 
ostream
 &
operator
<<(ostream &, const 
Substitution
 &);

198 
public
:

199 int 
operator
==(const 
Substitution
 &) const;

200 int 
operator
!=(const 
Substitution
 &) const;

201 
Substitution
 *
	$clone
() const;

202 int 
	$is_empty
() const;

203 int 
	`compose
(const 
Substitution
 &);

204 void 
	`update
(const 
Substitution
 &);

205 void 
	`clear
();

207 void 
	`add_binding
(const 
Var
 &, const 
Term
 &);

208 const 
Term
 *
	$get_bound
(const 
Var
 &) const;

209 
private
:

210 int 
	$occurs_in
(const 
Var
 *) const;

212 
PtrArray
<
Binding
> 
bindings
;

	@include/minimax.h

25 #ifndef 
_MINIMAX_H_


26 #define 
	#_MINIMAX_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"xlist.h
"

31 #define 
	#Infinity
 10000

	)
33 enum 
	ePlayer
 { 
	mPlayerOne
, 
	mPlayerTwo
 };

61 
	gtemplate
 <
class
 
	gT
>

62 
class
 
	cMinimax


64 
	mpublic
:

65 
Minimax
();

66 
	mvirtual
 ~
Minimax
();

67 
virtual
 int 
	$game_ends
() const = 0;

68 
virtual
 int 
	$evaluate_board
(
Player
) const = 0;

69 
virtual
 
List
<
T
> *
	`generate_moves
(
Player
) = 0;

70 
virtual
 void 
	`do_move
(const 
T
 &, 
Player
) = 0;

71 
virtual
 void 
	`undo_move
(const 
T
 &, 
Player
) = 0;

73 void 
	`do_cutoff
(int);

74 
Player
 
	`other
(Player);

76 int 
	`do_minimax
(
Player
, int 
maxdepth
, 
T
 *
answer
,

77 int 
alpha
 = -
Infinity
, int 
beta
 = Infinity);

78 
private
:

79 int 
do_alphabeta
;

82 
template
 <
class
 
T
>

83 
inline
 
Minimax
<
T
>::
	$Minimax
()

85 
do_alphabeta
 = 1;

86 
	}
}

88 
	gtemplate
 <
class
 
	gT
>

89 
inline
 
	gMinimax
<
	gT
>::~
	$Minimax
()

91 
	}
}

93 
template
 <
class
 
T
>

94 
inline
 void 
Minimax
<
T
>::
	$do_cutoff
(int 
c
)

96 
do_alphabeta
 = 
c
;

97 
	}
}

99 
	gtemplate
 <
class
 
	gT
>

100 
inline
 
Player
 
	gMinimax
<
	gT
>::
	$other
(Player 
pl
)

102 return(
pl
 == 
PlayerOne
 ? 
PlayerTwo
: PlayerOne);

103 
	}
}

105 
	gtemplate
 <
class
 
	gT
>

106 int 
	gMinimax
<
	gT
>::
	$do_minimax
(
Player
 
pl
, int 
depth
, 
T
 *
answer
, int 
alpha
, int 
beta
)

108 
List
<
T
> *
succs
;

109 
T
 
bestmove
, 
child
;

115 if (!
depth
 || 
	`game_ends
())

116 return(
	`evaluate_board
(
pl
));

119 
succs
 = 
	`generate_moves
(
pl
);

122 if (!
succs
 || succs->
	`is_empty
())

123 return(
	`evaluate_board
(
pl
));

130 if (!
do_alphabeta
)

131 
alpha
 = -
Infinity
;

137 for (int 
i
 = 
succs
->
	`getcount
(); i; i--)

139 int 
newval
;

141 
child
 = 
succs
->
	`gethead
();

142 
succs
->
	`remove_head
();

149 
	`do_move
(
child
, 
pl
);

150 
newval
 = -
	`do_minimax
(
	`other
(
pl
), 
depth
 - 1, 
answer
, -
beta
, -
alpha
);

151 
	`undo_move
(
child
, 
pl
);

154 if (
newval
 > 
alpha
)

156 
alpha
 = 
newval
;

157 
bestmove
 = 
child
;

161 if (
do_alphabeta
)

162 if (
alpha
 >= 
beta
)

164 
bestmove
 = 
child
;

169 
delete
 
succs
;

170 *
answer
 = 
bestmove
;

171 return(
alpha
);

172 
	}
}

	@include/xarray.h

25 #ifndef 
_ARRAY_H_


26 #define 
	#_ARRAY_H_


	)
28 #include 
	~<stdio.h
>

30 #define 
	#NoDel
 0

	)
31 #define 
	#DoDel
 1

	)
32 #define 
	#DontManage
 0

	)
33 #define 
	#DoManage
 1

	)
35 
	gtemplate
 <
class
 
	gT
>

36 
class
 
	cArray


38 
	mpublic
:

39 
Array
();

40 
Array
(int);

41 ~
Array
();

42 
Array
(const Array<
T
> &);

43 
	mArray
<
	mT
> &
	moperator
=(const 
Array
<
T
> &);

44 int 
	moperator
==(const 
Array
<
T
> &) const;

45 int 
	moperator
!=(const 
Array
<
T
> &) const;

46 
	mT
 &
	moperator
[](int);

47 const 
	mT
 &
	moperator
[](int) const;

48 void 
	moperator
+=(const 
T
 &);

49 int 
	$getsize
() const;

50 void 
	`grow
(int);

51 int 
	$find
(const 
T
 &) const;

52 void 
	`clear
();

53 
private
:

54 void 
	`copy_arr
(const 
Array
<
T
> &);

55 int 
size
;

56 
T
 *
array
;

59 
template
 <
class
 
T
>

60 
class
 
	cPtrArray


62 
public
:

63 
	`PtrArray
(int 
sz
 = 0, int 
do_manage
 = 1);

64 ~
	`PtrArray
();

65 
	`PtrArray
(const 
PtrArray
<
T
> &);

66 
PtrArray
<
T
> &
operator
=(const PtrArray<T> &);

67 int 
operator
==(const 
PtrArray
<
T
> &) const;

68 int 
operator
!=(const 
PtrArray
<
T
> &) const;

69 
T
 *&
operator
[](int);

70 const 
T
 *
operator
[](int) const;

71 void 
operator
+=(
T
 *);

72 int 
	$getsize
() const;

73 void 
	`grow
(int);

74 int 
	$find
(const 
T
 *) const;

75 void 
	`clear
(int);

76 
private
:

77 void 
	`copy_arr
(const 
PtrArray
<
T
> &);

78 int 
manage
;

79 int 
size
;

80 
T
 **
array
;

84 
template
 <
class
 
T
>

85 
inline
 
Array
<
T
>::
	$Array
()

87 
array
 = 0;

88 
size
 = 0;

89 
	}
}

91 
	gtemplate
 <
class
 
	gT
>

92 
inline
 
	gArray
<
	gT
>::
	$Array
(int 
sz
)

94 
size
 = 
sz
;

95 if (
size
)

96 
array
 = 
new
 
T
[
size
];

98 
array
= 0;

99 
	}
}

101 
	gtemplate
 <
class
 
	gT
>

102 
inline
 
	gArray
<
	gT
>::~
	$Array
()

104 
delete
 [] 
array
;

105 
	}
}

107 
	gtemplate
 <
class
 
	gT
>

108 
	gArray
<
	gT
>::
Array
(const Array<
T
> &
other
)

110 
copy_arr
(
other
);

113 
	gtemplate
 <
class
 
	gT
>

114 
	gArray
<
	gT
> &Array<T>::
operator
=(const 
Array
<
T
> &
other
)

116 if (
this
 != &
other
)

118 
delete
 [] 
array
;

119 
copy_arr
(
other
);

121 return(*
	gthis
);

124 
	gtemplate
 <
class
 
	gT
>

125 void 
	gArray
<
	gT
>::
copy_arr
(const 
Array
<
T
> &
other
)

127 
size
 = 
other
.size;

128 if (
	gsize
)

130 
	garray
 = 
new
 
T
[
size
];

131 for (int 
	gi
= 0; i < 
	gsize
; i++)

132 
	garray
[
i
] = 
other
.
array
[i];

135 
	garray
 = 0;

138 
	gtemplate
 <
class
 
	gT
>

139 int 
	gArray
<
	gT
>::
operator
==(const 
Array
<
T
> &
other
) const

141 if (
this
 == &
other
)

143 if (
	gsize
 != 
other
.
size
)

145 for (int 
	gi
 = 0; i < 
	gsize
; i++)

146 if (!(
	garray
[
i
] == 
other
.
array
[i]))

151 
	gtemplate
 <
class
 
	gT
>

152 
inline
 int 
	gArray
<
	gT
>::
operator
!=(const 
Array
<
T
> &
other
) const

154 return(!(*
this
 == 
other
));

157 
	gtemplate
 <
class
 
	gT
>

158 
inline
 
	gT
 &
	gArray
<T>::
operator
[](int 
i
)

160 return(
array
[
i
]);

163 
	gtemplate
 <
class
 
	gT
>

164 
inline
 const 
	gT
 &
	gArray
<T>::
operator
[](int 
i
) const

166 return(
array
[
i
]);

169 
	gtemplate
 <
class
 
	gT
>

170 
inline
 void 
	gArray
<
	gT
>::
operator
+=(const 
T
 &
addme
)

172 
grow
(1);

173 
	garray
[
size
 - 1] = 
addme
;

176 
	gtemplate
 <
class
 
	gT
>

177 
inline
 int 
	gArray
<
	gT
>::
	$getsize
() const

179 return(
size
);

180 
	}
}

182 
	gtemplate
 <
class
 
	gT
>

183 void 
	gArray
<
	gT
>::
	$grow
(int 
gz
)

185 
T
 *
oldarray
 = 
array
;

186 int 
newsize
 = 
size
 + 
gz
;

188 
array
 = 
new
 
T
[
newsize
];

189 for (int 
i
 = 0; i < 
size
; i++)

190 
array
[
i
] = 
oldarray
[i];

191 
size
 = 
newsize
;

192 
delete
 [] 
oldarray
;

193 
	}
}

195 
	gtemplate
 <
class
 
	gT
>

196 int 
	gArray
<
	gT
>::
	$find
(const 
T
 &
findme
) const

198 for (int 
i
 = 0; i < 
size
; i++)

199 if (
array
[
i
] == 
findme
)

200 return(
i
);

202 
	}
}

204 
	gtemplate
 <
class
 
	gT
>

205 void 
	gArray
<
	gT
>::
	$clear
()

207 
delete
 [] 
array
;

208 
size
 = 0;

209 
	}
}

211 
	gtemplate
 <
class
 
	gT
>

212 
	gPtrArray
<
	gT
>::
	$PtrArray
(int 
sz
, int 
do_manage
)

214 
size
 = 
sz
;

215 
manage
 = 
do_manage
;

216 if (
size
)

218 
array
 = 
new
 
T
*[
size
];

219 for (int 
i
 = 0; i < 
size
; i++)

220 
array
[
i
] = 0;

223 
array
 = 0;

224 
	}
}

226 
	gtemplate
 <
class
 
	gT
>

227 
	gPtrArray
<
	gT
>::~
	$PtrArray
()

229 
	`clear
(
manage
);

230 
	}
}

232 
	gtemplate
 <
class
 
	gT
>

233 
	gPtrArray
<
	gT
>::
PtrArray
(const PtrArray<
T
> &
other
)

235 
copy_arr
(
other
);

238 
	gtemplate
 <
class
 
	gT
>

239 
	gPtrArray
<
	gT
> &PtrArray<T>::
operator
=(const 
PtrArray
<
T
> &
other
)

241 if (
this
 != &
other
)

243 
clear
(
manage
);

244 
copy_arr
(
other
);

246 return(*
	gthis
);

249 
	gtemplate
 <
class
 
	gT
>

250 void 
	gPtrArray
<
	gT
>::
copy_arr
(const 
PtrArray
<
T
> &
other
)

252 
size
 = 
other
.size;

253 
	gmanage
 = 
other
.
manage
;

255 if (
	gsize
)

257 int 
	gi
;

259 
	garray
 = 
new
 
T
*[
size
];

260 if (
	gmanage
)

261 for (
	gi
 = 0; i < 
	gsize
; i++)

262 
	garray
[
i
] = 
other
.
array
[i] ? other.array[i]->
clone
() : 0;

264 for (
	gi
 = 0; i < 
	gsize
; i++)

265 
	garray
[
i
] = 
other
.
array
[i];

268 
	garray
 = 0;

275 
	gtemplate
 <
class
 
	gT
>

276 int 
	gPtrArray
<
	gT
>::
operator
==(const 
PtrArray
<
T
> &
other
) const

278 if (
this
 == &
other
)

280 if (
	gsize
 != 
other
.
size
)

282 for (int 
	gi
 = 0; i < 
	gsize
; i++)

283 if (!(*
	garray
[
i
] == *
other
.
array
[i]))

288 
	gtemplate
 <
class
 
	gT
>

289 
inline
 int 
	gPtrArray
<
	gT
>::
operator
!=(const 
PtrArray
<
T
> &
other
) const

291 return(!(*
this
 == 
other
));

294 
	gtemplate
 <
class
 
	gT
>

295 
inline
 
	gT
 *&
	gPtrArray
<T>::
operator
[](int 
i
)

297 return(
array
[
i
]);

300 
	gtemplate
 <
class
 
	gT
>

301 
inline
 const 
T
 *
	gPtrArray
<
	gT
>::
operator
[](int 
i
) const

303 return(
array
[
i
]);

306 
	gtemplate
 <
class
 
	gT
>

307 
inline
 void 
	gPtrArray
<
	gT
>::
operator
+=(
T
 *
addme
)

309 
grow
(1);

310 
	garray
[
size
 - 1] = 
addme
;

313 
	gtemplate
 <
class
 
	gT
>

314 
inline
 int 
	gPtrArray
<
	gT
>::
	$getsize
() const

316 return(
size
);

317 
	}
}

319 
	gtemplate
 <
class
 
	gT
>

320 void 
	gPtrArray
<
	gT
>::
	$grow
(int 
gz
)

322 
T
 **
oldarray
 = 
array
;

323 int 
i
, 
newsize
 = 
size
 + 
gz
;

325 
array
 = 
new
 
T
*[
newsize
];

326 for (
i
 = 0; i < 
size
; i++)

327 
array
[
i
] = 
oldarray
[i];

328 for (; 
i
 < 
newsize
; i++)

329 
array
[
i
] = 0;

330 
size
 = 
newsize
;

331 
delete
 [] 
oldarray
;

332 
	}
}

334 
	gtemplate
 <
class
 
	gT
>

335 int 
	gPtrArray
<
	gT
>::
	$find
(const 
T
 *
find_me
) const

337 for (int 
i
 = 0; i < 
size
; i++)

338 if (
array
[
i
])

339 if (*
array
[
i
] == *
find_me
)

340 return(
i
);

342 
	}
}

344 
	gtemplate
 <
class
 
	gT
>

345 void 
	gPtrArray
<
	gT
>::
	$clear
(int 
clr
)

347 if (
clr
)

348 for (int 
i
 = 0; i < 
size
; i++)

349 
delete
 
array
[
i
];

350 
delete
 [] 
array
;

351 
array
 = 0;

352 
size
 = 0;

353 
	}
}

	@include/xlist.h

25 #ifndef 
_LIST_H_


26 #define 
	#_LIST_H_


	)
28 #include 
	~<string.h
>

29 #include 
	~"blist.h
"

36 
	gtemplate
 <
class
 
	gT
>

37 
class
 
	cTListNode
 : 
public
 
ListNode


39 
public
:

40 
	$TListNode
(const 
T
 &
obj
) : 
	$data
(obj) { }

41 
T
 
data
;

42 
	}
};

50 
	gtemplate
 <
class
 
	gT
>

51 
class
 
	cList
 : 
private
 
BasList


53 
public
:

54 
	$List
() : 
	$BasList
() { }

55 #ifdef 
NEED_CAST


56 
	`List
(const 
List
<
T
> &
other
) { 
BasList
::
	`copylist
((BasList &)other); 
	}
}

57 int 
	goperator
==(const 
List
<
T
> &
other
) const { return(
BasList
::
operator
==((BasList &)other)); }

59 
List
(const List<
T
> &
other
) { 
	gBasList
::
copylist
(other); }

61 
	gList
<
	gT
> &
	goperator
=(const 
List
<
T
> &
other
);

63 int 
	$compareeq
(
ListNode
 *
n1
, ListNode *
n2
) const;

64 
ListNode
 *
	$copynode
(ListNode *) const;

66 void 
	$addtohead
(const 
T
 &
a
) { 
BasList
::
	`addtohead
(
new
 
TListNode
<T>(a)); 
	}
}

67 void 
	$addtotail
(const 
T
 &
a
) { 
BasList
::
	`addtotail
(
new
 
TListNode
<T>(a)); 
	}
}

69 
	gT
 &
	goperator
[](int);

70 const 
	gT
 &
	goperator
[](int) const;

71 
	gT
 &
	$gethead
() const;

72 
T
 &
	$gettail
() const;

73 
T
 &
	$getfound
() const;

74 int 
	$getcount
() const { return(
BasList
::
	`getcount
()); 
	}
}

75 int 
	$is_empty
() const { return(
BasList
::
	`is_empty
()); 
	}
}

77 int 
	$find
(const 
T
 &
n
) { 
TListNode
<T> 
	`tmp
(n); return(
BasList
::
	`find
(&
tmp
)); 
	}
}

78 
T
 *
lookup
(const T &
n
);

80 void 
	$remove_head
() { 
BasList
::
	`remove_head
(); 
	}
}

81 void 
	$remove_tail
() { 
BasList
::
	`remove_tail
(); 
	}
}

82 void 
	$remove_found
() { 
BasList
::
	`remove_found
(); 
	}
}

83 void 
	$clear
() { 
BasList
::
	`clear
(); 
	}
}

84 
	gprivate
:

85 void 
	$error
(const char *
str
) const;

86 
protected
:

87 void 
	$insert
(const 
T
 &
a
) { 
BasList
::
	`insert
(
new
 
TListNode
<T>(a)); 
	}
}

90 
	gtemplate
 <
class
 
	gT
>

91 
inline
 
	gList
<
	gT
> &List<T>::
operator
=(const 
List
<
T
> &
other
)

93 
BasList
::
operator
=(
other
);

94 return(*
	gthis
);

97 
	gtemplate
 <
class
 
	gT
>

98 
inline
 
ListNode
 *
	gList
<
	gT
>::
	$copynode
(ListNode *
node
) const

100 return(
new
 
TListNode
<
T
>(((TListNode<T> *)
node
)->
data
));

101 
	}
}

103 
	gtemplate
 <
class
 
	gT
>

104 
inline
 int 
	gList
<
	gT
>::
	$compareeq
(
ListNode
 *
n1
, ListNode *
n2
) const

106 return(((
TListNode
<
T
> *)
n1
)->
data
 == ((TListNode<T> *)
n2
)->data);

107 
	}
}

110 
	gtemplate
 <
class
 
	gT
>

111 void 
	gList
<
	gT
>::
	$error
(const char *
str
) const

113 
	`puts
(
str
);

114 
	`exit
(0);

115 
	}
}

117 
	gtemplate
 <
class
 
	gT
>

118 
inline
 
	gT
 &
	gList
<T>::
operator
[](int 
index
)

120 
TListNode
<
T
> *
node
 = (TListNode<T> *)
BasList
::
operator
[](
index
);

122 if (!
	gnode
)

123 
error
("subscript [] out of range");

124 return(
	gnode
->
	gdata
);

127 
	gtemplate
 <
class
 
	gT
>

128 
inline
 const 
	gT
 &
	gList
<T>::
operator
[](int 
index
) const

130 
TListNode
<
T
> *
node
 = (TListNode<T> *)
BasList
::
operator
[](
index
);

132 if (!
	gnode
)

133 
error
("subscript [] out of range");

134 return(
	gnode
->
	gdata
);

137 
	gtemplate
 <
class
 
	gT
>

138 
inline
 
	gT
 &
	gList
<T>::
	$gethead
() const

140 if (!
head
)

141 
	`error
("gethead() from empty list");

142 return(((
TListNode
<
T
> *)
head
)->
data
);

143 
	}
}

145 
	gtemplate
 <
class
 
	gT
>

146 
inline
 
	gT
 &
	gList
<T>::
	$gettail
() const

148 if (!
tail
)

149 
	`error
("gettail() from empty list");

150 return(((
TListNode
<
T
> *)
tail
)->
data
);

151 
	}
}

153 
	gtemplate
 <
class
 
	gT
>

154 
inline
 
	gT
 &
	gList
<T>::
	$getfound
() const

156 if (!
found
)

157 
	`error
("found not initialized");

158 return(((
TListNode
<
T
> *)
found
)->
data
);

159 
	}
}

161 
	gtemplate
 <
class
 
	gT
>

162 
inline
 
T
 *
	gList
<
	gT
>::
	$lookup
(const T &
n
)

164 
TListNode
<
T
> 
	`tmp
(
n
), *
t
;

165 
t
 = (
TListNode
<
T
> *)
BasList
::
	`lookup
(&
tmp
);

166 return(
t
 ? &t->
data
 : 0);

167 
	}
}

169 
	gtemplate
 <
class
 
	gT
>

170 
class
 
	gSortedList
 : 
public
 
List
<
T
>

172 
public
:

173 
SortedList
<
T
> &
operator
=(const SortedList<T> &);

174 int 
comparelt
(
ListNode
 *, ListNode *) const;

176 void 
insert
(const 
T
 &
a
) { 
	gList
<
	gT
>::insert(a); }

179 
	gtemplate
 <
class
 
	gT
>

180 
inline
 
	gSortedList
<
	gT
> &SortedList<T>::
operator
=(const 
SortedList
<
T
> &
other
)

182 
List
<
T
>::
operator
=(
other
);

183 return(*
	gthis
);

186 
	gtemplate
 <
class
 
	gT
>

187 
inline
 int 
	gSortedList
<
	gT
>::
	$comparelt
(
ListNode
 *
n1
, ListNode *
n2
) const

189 return(((
TListNode
<
T
> *)
n1
)->
data
 < ((TListNode<T> *)
n2
)->data);

190 
	}
}

192 
	gtemplate
 <
class
 
	gT
>

193 
class
 
	cPtrList
 : 
private
 
BasList


195 
public
:

196 
	$PtrList
(int 
do_manage
 = 1) { 
manage
 = do_manage; }

197 #ifdef 
NEED_CAST


198 
	`PtrList
(const 
PtrList
<
T
> &
other
) { 
BasList
::
	`copylist
((BasList &)other);

199 
manage
 = 
other
.manage; 
	}
}

200 int 
	goperator
==(const 
PtrList
<
T
> &
other
) const { return(
BasList
::
operator
==((BasList &)other)); }

202 
PtrList
(const PtrList<
T
> &
other
) { 
	gBasList
::
copylist
(other);

203 
	gmanage
 = 
other
.
manage
; }

205 ~
	$PtrList
() { 
	`clear
(
manage
); 
	}
}

206 
	gPtrList
<
	gT
> &
	goperator
=(const 
PtrList
<
T
> &
other
);

208 int 
	$compareeq
(
ListNode
 *, ListNode *) const;

209 void 
	`clearnode
(
ListNode
 *);

210 
ListNode
 *
	$copynode
(ListNode *) const;

212 void 
	$addtohead
(
T
 *
a
) { 
BasList
::
	`addtohead
(
new
 
TListNode
<T *>(a)); 
	}
}

213 void 
	$addtotail
(
T
 *
a
) { 
BasList
::
	`addtotail
(
new
 
TListNode
<T *>(a)); 
	}
}

215 
T
 *
	goperator
[](int);

216 const 
T
 *
	goperator
[](int) const;

217 
T
 *
	$gethead
() const;

218 
T
 *
	$gettail
() const;

219 
T
 *
	$getfound
() const;

220 int 
	$getcount
() const { return(
BasList
::
	`getcount
()); 
	}
}

221 int 
	$is_empty
() const { return(
BasList
::
	`is_empty
()); 
	}
}

222 int 
	$getmanage
() const { return(
manage
); 
	}
}

223 void 
	$setmanage
(int 
m
) { 
manage
 = m; 
	}
}

225 int 
find
(
T
 *);

226 
T
 *
lookup
(T *);

228 void 
	$remove_head
(int 
clr
) { 
BasList
::
	`remove_head
(clr); 
	}
}

229 void 
	$remove_tail
(int 
clr
) { 
BasList
::
	`remove_tail
(clr); 
	}
}

230 void 
	$remove_found
(int 
clr
) { 
BasList
::
	`remove_found
(clr); 
	}
}

232 void 
	$clear
(int 
clr
) { 
BasList
::
	`clear
(clr); 
	}
}

233 
	gprivate
:

234 int 
manage
;

235 
	gprotected
:

236 void 
	$insert
(
T
 *
a
) { 
BasList
::
	`insert
(
new
 
TListNode
<T *>(a)); 
	}
}

239 
	gtemplate
 <
class
 
	gT
>

240 
inline
 
ListNode
 *
	gPtrList
<
	gT
>::
	$copynode
(ListNode *
n
) const

242 if (
manage
)

243 return(
new
 
TListNode
<
T
 *>(((TListNode<T *> *)
n
)->
data
->
	`clone
()));

245 return(
new
 
TListNode
<
T
 *>(((TListNode<T *> *)
n
)->
data
));

246 
	}
}

248 
	gtemplate
 <
class
 
	gT
>

249 
inline
 void 
	gPtrList
<
	gT
>::
	$clearnode
(
ListNode
 *
n
)

251 
	`delete
 ((
TListNode
<
T
 *> *)
n
)->
data
;

252 
	}
}

254 
	gtemplate
 <
class
 
	gT
>

255 
inline
 int 
	gPtrList
<
	gT
>::
	$compareeq
(
ListNode
 *
n1
, ListNode *
n2
) const

257 return(*((
TListNode
<
T
 *> *)
n1
)->
data
 == *((TListNode<T *> *)
n2
)->data);

258 
	}
}

260 
	gtemplate
 <
class
 
	gT
>

261 
	gPtrList
<
	gT
> &PtrList<T>::
operator
=(const 
PtrList
<
T
>&
other
)

263 if (
this
 == &
other
)

264 return(*
this
);

266 
	gBasList
::
clear
(
manage
);

267 
	gmanage
 = 
other
.
manage
;

268 
	gBasList
::
operator
=(
other
);

269 return(*
	gthis
);

272 
	gtemplate
 <
class
 
	gT
>

273 
inline
 
T
 *
	gPtrList
<
	gT
>::
	$gethead
() const

275 return(
head
? ((
TListNode
<
T
 *> *)head)->
data
 : 0);

276 
	}
}

278 
	gtemplate
 <
class
 
	gT
>

279 
inline
 
T
 *
	gPtrList
<
	gT
>::
	$gettail
() const

281 return(
tail
? ((
TListNode
<
T
 *> *)tail)->
data
 : 0);

282 
	}
}

284 
	gtemplate
 <
class
 
	gT
>

285 
inline
 
T
 *
	gPtrList
<
	gT
>::
	$getfound
() const

287 return(
found
? ((
TListNode
<
T
 *> *)found)->
data
 : 0);

288 
	}
}

290 
	gtemplate
 <
class
 
	gT
>

291 
inline
 
T
 *
	gPtrList
<
	gT
>::
operator
[](int 
index
)

293 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasList
::
operator
[](
index
);

294 return(
	gn
 ? n->
	gdata
 : 0);

297 
	gtemplate
 <
class
 
	gT
>

298 
inline
 const 
T
 *
	gPtrList
<
	gT
>::
operator
[](int 
index
) const

300 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasList
::
operator
[](
index
);

301 return(
	gn
 ? n->
	gdata
 : 0);

304 
	gtemplate
 <
class
 
	gT
>

305 
inline
 int 
	gPtrList
<
	gT
>::
	$find
(
T
 *
s
)

307 
TListNode
<
T
 *> 
	`tmp
(
s
);

308 return(
BasList
::
	`find
(&
tmp
));

309 
	}
}

311 
	gtemplate
 <
class
 
	gT
>

312 
inline
 
T
 *
	gPtrList
<
	gT
>::
	$lookup
(T *
s
)

314 
TListNode
<
T
 *> 
	`tmp
(
s
), *
n
;

315 
n
 = (
TListNode
<
T
 *> *)
BasList
::
	`lookup
(&
tmp
);

316 return(
n
 ? n->
data
 : 0);

317 
	}
}

320 
	gtemplate
 <
class
 
	gT
>

321 
class
 
	gSortedPtrList
 : 
private
 
PtrList
<
T
>

323 
public
:

324 
SortedPtrList
<
T
> &
operator
=(const SortedPtrList<T> &);

325 int 
comparelt
(
ListNode
 *, ListNode *) const;

327 void 
insert
(
T
 *
a
) { 
	gPtrList
<
	gT
>::insert(a); }

330 
	gtemplate
 <
class
 
	gT
>

331 
inline
 
	gSortedPtrList
<
	gT
> &SortedPtrList<T>::
operator
=(const 
SortedPtrList
<
T
> &
other
)

333 
PtrList
<
T
>::
operator
=(
other
);

334 return(*
	gthis
);

337 
	gtemplate
 <
class
 
	gT
>

338 
inline
 int 
	gSortedPtrList
<
	gT
>::
	$comparelt
(
ListNode
 *
n1
, ListNode *
n2
) const

340 return(*((
TListNode
<
T
> *)
n1
)->
data
 < *((TListNode<T> *)
n2
)->data);

341 
	}
}

343 
	gtemplate
 <
class
 
	gT
>

344 
class
 
	cIntrList
 : 
private
 
BasList


346 
public
:

347 
	$IntrList
(int 
do_manage
 = 1) { 
manage
 = do_manage; }

348 #ifdef 
NEED_CAST


349 
	`IntrList
(const 
IntrList
<
T
> &
other
) { 
BasList
::
	`copylist
((BasList &)other);

350 
manage
 = 
other
.manage; 
	}
}

351 int 
	goperator
==(const 
IntrList
<
T
> &
other
) const { return(
BasList
::
operator
==((BasList &)other)); }

353 
IntrList
(const IntrList<
T
> &
other
) { 
	gBasList
::
copylist
(other);

354 
	gmanage
 = 
other
.
manage
; }

356 ~
	$IntrList
() { 
	`clear
(
manage
); 
	}
}

357 
	gIntrList
<
	gT
> &
	goperator
=(const 
IntrList
<
T
> &
other
);

359 int 
	$compareeq
(
ListNode
 *, ListNode *) const;

360 
ListNode
 *
	$copynode
(ListNode *) const;

362 
T
 *
operator
[](int 
n
) { return((T *)
BasList
::operator[](n)); 
	}
}

363 const 
T
 *
	goperator
[](int 
	gn
) const { return((
	gT
 *)
	gBasList
::
operator
[](
n
)); }

365 void 
	$addtohead
(
T
 *
n
) { 
BasList
::
	`addtohead
(n); 
	}
}

366 void 
	$addtotail
(
T
 *
n
) { 
BasList
::
	`addtotail
(n); 
	}
}

368 
T
 *
	$gethead
() const { return((T *)
BasList
::
	`gethead
()); 
	}
}

369 
T
 *
	$gettail
() const { return((T *)
BasList
::
	`gettail
()); 
	}
}

370 
T
 *
	$getfound
() const { return((T *)
BasList
::
	`getfound
()); 
	}
}

371 int 
	$getcount
() const { return(
BasList
::
	`getcount
()); 
	}
}

372 int 
	$is_empty
() const { return(
BasList
::
	`is_empty
()); 
	}
}

373 int 
	$getmanage
() const { return(
manage
); 
	}
}

374 void 
	$setmanage
(int 
m
) { 
manage
 = m; 
	}
}

376 int 
	$find
(
T
* 
n
) { return(
BasList
::
	`find
(n)); 
	}
}

377 
T
* 
	$lookup
(T *
n
) { return((T *)
BasList
::
	`lookup
(n)); 
	}
}

379 void 
	$remove_head
(int 
del
) { 
BasList
::
	`remove_head
(0, del); 
	}
}

380 void 
	$remove_tail
(int 
del
) { 
BasList
::
	`remove_tail
(0, del); 
	}
}

381 void 
	$remove_found
(int 
del
) { 
BasList
::
	`remove_found
(0, del); 
	}
}

389 void 
	$remove_node
(
T
 *
n
, int 
del
) { 
BasList
::
	`remove_node
(n, 0, del); 
	}
}

391 void 
	$clear
(int 
del
) { 
BasList
::
	`clear
(0, del); 
	}
}

392 
	gprivate
:

393 int 
manage
;

394 
	gprotected
:

395 void 
	$insert
(
T
 *
n
) { 
BasList
::
	`insert
(n); 
	}
}

398 
	gtemplate
 <
class
 
	gT
>

399 
	gIntrList
<
	gT
> &IntrList<T>::
operator
=(const 
IntrList
<
T
> &
other
)

401 if (
this
 == &
other
)

402 return(*
this
);

404 
clear
(
manage
);

405 
	gmanage
 = 
other
.
manage
;

406 
	gBasList
::
operator
=(
other
);

407 return(*
	gthis
);

410 
	gtemplate
 <
class
 
	gT
>

411 
inline
 int 
	gIntrList
<
	gT
>::
	$compareeq
(
ListNode
 *
n1
, ListNode *
n2
) const

413 return(*(
T
*)
n1
 == *(T*)
n2
);

414 
	}
}

416 
	gtemplate
 <
class
 
	gT
>

417 
inline
 
ListNode
 *
	gIntrList
<
	gT
>::
	$copynode
(ListNode *
n
) const

419 return(((
T
 *)
n
)->
	`clone
());

420 
	}
}

422 
	gtemplate
 <
class
 
	gT
>

423 
class
 
	gSortedIntrList
 : 
public
 
IntrList
<
T
>

425 
public
:

426 
SortedIntrList
(int 
do_manage
 = 1) : 
IntrList
<
T
>(do_manage) { }

427 
SortedIntrList
<
T
> &
operator
=(const SortedIntrList<T> &
other
);

429 int 
comparelt
(
ListNode
 *, ListNode *) const;

431 void 
insert
(
T
 *
n
) { 
	gIntrList
<
	gT
>::insert(n); }

434 
	gtemplate
 <
class
 
	gT
>

435 
inline
 
	gSortedIntrList
<
	gT
> &SortedIntrList<T>::
operator
=(const 
SortedIntrList
<
T
> &
other
)

437 
IntrList
<
T
>::
operator
=(
other
);

438 return(*
	gthis
);

441 
	gtemplate
 <
class
 
	gT
>

442 
inline
 int 
	gSortedIntrList
<
	gT
>::
	$comparelt
(
ListNode
 *
n1
, ListNode *
n2
) const

444 return(*(
T
*)
n1
 < *(T*)
n2
);

445 
	}
}

448 
	gtemplate
 <
class
 
	gT
>

449 
class
 
	cListIterator
 : 
private
 
BasListIterator


451 
public
:

452 
	$ListIterator
() : 
	$BasListIterator
() { }

453 #ifdef 
NEED_CAST


454 
	`ListIterator
(
List
<
T
> &
li
) : 
	$BasListIterator
((
BasList
 &)li) { 
	}
}

455 void 
setlist
(
List
<
T
> &
li
) { 
BasListIterator
::setlist((
BasList
 &)li); }

457 
ListIterator
(
List
<
T
> &
li
) : 
	$BasListIterator
(li) { 
	}
}

458 void 
setlist
(
List
<
T
> &
li
) { 
BasListIterator
::setlist(li); }

461 
	gT
 &
getfirst
();

462 
	gT
 &
getlast
();

463 
	gT
 &
getnext
();

464 
	gT
 &
getprev
();

465 
	gT
 &
getcurrent
();

466 int 
	$notempty
() const { return(
BasListIterator
::
	`notempty
()); 
	}
}

468 void 
	$remove_current
() { 
BasListIterator
::
	`remove_current
(); 
	}
}

469 
	gprivate
:

470 void 
	$error
(const char *) const;

471 
	}
};

473 
	gtemplate
 <
class
 
	gT
>

474 
	gT
 &
	gListIterator
<T>::
	$getfirst
()

476 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
BasListIterator
::
	`getfirst
();

477 if (!
tmp
)

478 
	`error
("Iter - getfirst() from empty list");

479 return(
tmp
->
data
);

480 
	}
}

482 
	gtemplate
 <
class
 
	gT
>

483 
	gT
 &
	gListIterator
<T>::
	$getlast
()

485 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
BasListIterator
::
	`getlast
();

486 if (!
tmp
)

487 
	`error
("Iter - getlast() from empty list");

488 return(
tmp
->
data
);

489 
	}
}

491 
	gtemplate
 <
class
 
	gT
>

492 
	gT
 &
	gListIterator
<T>::
	$getnext
()

494 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
BasListIterator
::
	`getnext
();

495 if (!
tmp
)

496 
	`error
("Iter - getnext() is empty");

497 return(
tmp
->
data
);

498 
	}
}

500 
	gtemplate
 <
class
 
	gT
>

501 
	gT
 &
	gListIterator
<T>::
	$getprev
()

503 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
BasListIterator
::
	`getprev
();

504 if (!
tmp
)

505 
	`error
("Iter - getprev() is empty");

506 return(
tmp
->
data
);

507 
	}
}

509 
	gtemplate
 <
class
 
	gT
>

510 
	gT
 &
	gListIterator
<T>::
	$getcurrent
()

512 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
BasListIterator
::
	`getcurrent
();

513 if (!
tmp
)

514 
	`error
("Iter - getitem(): no current item");

515 return(
tmp
->
data
);

516 
	}
}

518 
	gtemplate
 <
class
 
	gT
>

519 void 
	gListIterator
<
	gT
>::
	$error
(const char *
str
) const

521 
	`puts
(
str
);

522 
	`exit
(0);

523 
	}
}

525 
	gtemplate
 <
class
 
	gT
>

526 
class
 
	cROListIterator
 : 
private
 
ROBasListIterator


528 
public
:

529 
	$ROListIterator
() : 
	$ROBasListIterator
() { }

530 #ifdef 
NEED_CAST


531 
	`ROListIterator
(const 
List
<
T
> &
li
) : 
	$ROBasListIterator
((
BasList
 &)li) { 
	}
}

532 void 
setlist
(const 
List
<
T
> &
li
) { 
ROBasListIterator
::setlist((
BasList
 &)li); }

534 
ROListIterator
(const 
List
<
T
> &
li
) : 
	$ROBasListIterator
(li) { 
	}
}

535 void 
setlist
(const 
List
<
T
> &
li
) { 
ROBasListIterator
::setlist(li); }

538 const 
	gT
 &
getfirst
();

539 const 
	gT
 &
getlast
();

540 const 
	gT
 &
getnext
();

541 const 
	gT
 &
getprev
();

542 const 
	gT
 &
getcurrent
();

543 int 
	$notempty
() const { return(
ROBasListIterator
::
	`notempty
()); 
	}
}

544 
	gprivate
:

545 void 
	$error
(const char *) const;

546 
	}
};

548 
	gtemplate
 <
class
 
	gT
>

549 const 
	gT
 &
	gROListIterator
<T>::
	$getfirst
()

551 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
ROBasListIterator
::
	`getfirst
();

552 if (!
tmp
)

553 
	`error
("Iter - getfirst() from empty list");

554 return(
tmp
->
data
);

555 
	}
}

557 
	gtemplate
 <
class
 
	gT
>

558 const 
	gT
 &
	gROListIterator
<T>::
	$getlast
()

560 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
ROBasListIterator
::
	`getlast
();

561 if (!
tmp
)

562 
	`error
("Iter - getlast() from empty list");

563 return(
tmp
->
data
);

564 
	}
}

566 
	gtemplate
 <
class
 
	gT
>

567 const 
	gT
 &
	gROListIterator
<T>::
	$getnext
()

569 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
ROBasListIterator
::
	`getnext
();

570 if (!
tmp
)

571 
	`error
("Iter - getnext() is empty");

572 return(
tmp
->
data
);

573 
	}
}

575 
	gtemplate
 <
class
 
	gT
>

576 const 
	gT
 &
	gROListIterator
<T>::
	$getprev
()

578 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
ROBasListIterator
::
	`getprev
();

579 if (!
tmp
)

580 
	`error
("Iter - getprev() is empty");

581 return(
tmp
->
data
);

582 
	}
}

584 
	gtemplate
 <
class
 
	gT
>

585 const 
	gT
 &
	gROListIterator
<T>::
	$getcurrent
()

587 
TListNode
<
T
> *
tmp
 = (TListNode<T> *)
ROBasListIterator
::
	`getcurrent
();

588 if (!
tmp
)

589 
	`error
("Iter - getitem(): no current item");

590 return(
tmp
->
data
);

591 
	}
}

593 
	gtemplate
 <
class
 
	gT
>

594 void 
	gROListIterator
<
	gT
>::
	$error
(const char *
str
) const

596 
	`puts
(
str
);

597 
	`exit
(0);

598 
	}
}

601 
	gtemplate
 <
class
 
	gT
>

602 
class
 
	cPtrListIterator
 : 
private
 
BasListIterator


604 
public
:

605 
	$PtrListIterator
() : 
	$BasListIterator
() { }

606 #ifdef 
NEED_CAST


607 
	`PtrListIterator
(
PtrList
<
T
> &
li
) : 
	$BasListIterator
((
BasList
 &)li) { 
	}
}

608 void 
setlist
(
PtrList
<
T
> &
li
) { 
BasListIterator
::setlist((
BasList
 &)li); }

610 
PtrListIterator
(
PtrList
<
T
> &
li
) : 
	$BasListIterator
(li) { 
	}
}

611 void 
setlist
(
PtrList
<
T
> &
li
) { 
BasListIterator
::setlist(li); }

614 
T
 *
getfirst
();

615 
T
 *
getlast
();

616 
T
 *
getnext
();

617 
T
 *
getprev
();

618 
T
 *
getcurrent
();

619 int 
	$notempty
() const { return(
BasListIterator
::
	`notempty
()); 
	}
}

621 void 
	$remove_current
(int 
clr
) { 
BasListIterator
::
	`remove_current
(clr); 
	}
}

624 
	gtemplate
 <
class
 
	gT
>

625 
T
 *
	gPtrListIterator
<
	gT
>::
	$getfirst
()

627 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasListIterator
::
	`getfirst
();

628 return(
n
 ? n->
data
 : 0);

629 
	}
}

631 
	gtemplate
 <
class
 
	gT
>

632 
T
 *
	gPtrListIterator
<
	gT
>::
	$getlast
()

634 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasListIterator
::
	`getlast
();

635 return(
n
 ? n->
data
 : 0);

636 
	}
}

638 
	gtemplate
 <
class
 
	gT
>

639 
T
 *
	gPtrListIterator
<
	gT
>::
	$getnext
()

641 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasListIterator
::
	`getnext
();

642 return(
n
 ? n->
data
 : 0);

643 
	}
}

645 
	gtemplate
 <
class
 
	gT
>

646 
T
 *
	gPtrListIterator
<
	gT
>::
	$getprev
()

648 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasListIterator
::
	`getprev
();

649 return(
n
 ? n->
data
 : 0);

650 
	}
}

652 
	gtemplate
 <
class
 
	gT
>

653 
T
 *
	gPtrListIterator
<
	gT
>::
	$getcurrent
()

655 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
BasListIterator
::
	`getcurrent
();

656 return(
n
 ? n->
data
 : 0);

657 
	}
}

660 
	gtemplate
 <
class
 
	gT
>

661 
class
 
	cROPtrListIterator
 : 
private
 
ROBasListIterator


663 
public
:

664 
	$ROPtrListIterator
() : 
	$ROBasListIterator
() { }

665 #ifdef 
NEED_CAST


666 
	`ROPtrListIterator
(const 
PtrList
<
T
> &
li
) : 
	$ROBasListIterator
((
BasList
 &)li) { 
	}
}

667 void 
setlist
(const 
PtrList
<
T
> &
li
) { 
ROBasListIterator
::setlist((
BasList
 &)li); }

669 
ROPtrListIterator
(const 
PtrList
<
T
> &
li
) : 
	$ROBasListIterator
(li) { 
	}
}

670 void 
setlist
(const 
PtrList
<
T
> &
li
) { 
ROBasListIterator
::setlist(li); }

673 const 
T
 *
getfirst
();

674 const 
T
 *
getlast
();

675 const 
T
 *
getnext
();

676 const 
T
 *
getprev
();

677 const 
T
 *
getcurrent
();

678 int 
	$notempty
() const { return(
ROBasListIterator
::
	`notempty
()); 
	}
}

681 
	gtemplate
 <
class
 
	gT
>

682 const 
T
 *
	gROPtrListIterator
<
	gT
>::
	$getfirst
()

684 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
ROBasListIterator
::
	`getfirst
();

685 return(
n
 ? n->
data
 : 0);

686 
	}
}

688 
	gtemplate
 <
class
 
	gT
>

689 const 
T
 *
	gROPtrListIterator
<
	gT
>::
	$getlast
()

691 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
ROBasListIterator
::
	`getlast
();

692 return(
n
 ? n->
data
 : 0);

693 
	}
}

695 
	gtemplate
 <
class
 
	gT
>

696 const 
T
 *
	gROPtrListIterator
<
	gT
>::
	$getnext
()

698 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
ROBasListIterator
::
	`getnext
();

699 return(
n
 ? n->
data
 : 0);

700 
	}
}

702 
	gtemplate
 <
class
 
	gT
>

703 const 
T
 *
	gROPtrListIterator
<
	gT
>::
	$getprev
()

705 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
ROBasListIterator
::
	`getprev
();

706 return(
n
 ? n->
data
 : 0);

707 
	}
}

709 
	gtemplate
 <
class
 
	gT
>

710 const 
T
 *
	gROPtrListIterator
<
	gT
>::
	$getcurrent
()

712 
TListNode
<
T
 *> *
n
 = (TListNode<T *> *)
ROBasListIterator
::
	`getcurrent
();

713 return(
n
 ? n->
data
 : 0);

714 
	}
}

717 
	gtemplate
 <
class
 
	gT
>

718 
class
 
	cIntrListIterator
 : 
private
 
BasListIterator


720 
public
:

721 
	$IntrListIterator
() : 
	$BasListIterator
() { }

722 #ifdef 
NEED_CAST


723 
	`IntrListIterator
(
IntrList
<
T
> &
li
) : 
	$BasListIterator
((
BasList
 &)li) { 
	}
}

724 void 
setlist
(
IntrList
<
T
> &
li
) { 
BasListIterator
::setlist((
BasList
 &)li); }

726 
IntrListIterator
(
IntrList
<
T
> &
li
) : 
	$BasListIterator
(li) { 
	}
}

727 void 
setlist
(
IntrList
<
T
> &
li
) { 
BasListIterator
::setlist(li); }

730 
T
 *
	$getfirst
() { return((T*)
BasListIterator
::
	`getfirst
()); 
	}
}

731 
T
 *
	$getlast
() { return((T*)
BasListIterator
::
	`getlast
()); 
	}
}

732 
T
 *
	$getnext
() { return((T*)
BasListIterator
::
	`getnext
()); 
	}
}

733 
T
 *
	$getprev
() { return((T*)
BasListIterator
::
	`getprev
()); 
	}
}

734 
T
 *
	$getcurrent
() { return((T*)
BasListIterator
::
	`getcurrent
()); 
	}
}

735 int 
	$notempty
() const { return(
BasListIterator
::
	`notempty
()); 
	}
}

737 void 
	$remove_current
(int 
del
) { 
BasListIterator
::
	`remove_current
(0, del); 
	}
}

740 
	gtemplate
 <
class
 
	gT
>

741 
class
 
	cROIntrListIterator
 : 
private
 
ROBasListIterator


743 
public
:

744 
	$ROIntrListIterator
() : 
	$ROBasListIterator
() { }

745 #ifdef 
NEED_CAST


746 
	`ROIntrListIterator
(const 
IntrList
<
T
> &
li
) : 
	$ROBasListIterator
((
BasList
 &)li) { 
	}
}

747 void 
setlist
(const 
IntrList
<
T
> &
li
) { 
ROBasListIterator
::setlist((
BasList
 &)li); }

749 
ROIntrListIterator
(const 
IntrList
<
T
> &
li
) : 
	$ROBasListIterator
(li) { 
	}
}

750 void 
setlist
(const 
IntrList
<
T
> &
li
) { 
ROBasListIterator
::setlist(li); }

753 const 
T
 *
	$getfirst
() { return((T*)
ROBasListIterator
::
	`getfirst
()); 
	}
}

754 const 
T
 *
	$getlast
() { return((T*)
ROBasListIterator
::
	`getlast
()); 
	}
}

755 const 
T
 *
	$getnext
() { return((T*)
ROBasListIterator
::
	`getnext
()); 
	}
}

756 const 
T
 *
	$getprev
() { return((T*)
ROBasListIterator
::
	`getprev
()); 
	}
}

757 const 
T
 *
	$getcurrent
() { return((T*)
ROBasListIterator
::
	`getcurrent
()); 
	}
}

758 int 
	$notempty
() const { return(
ROBasListIterator
::
	`notempty
()); 
	}
}

	@include/xstring.h

25 #ifndef 
_XSTRING_H_


26 #define 
	#_XSTRING_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<iostream.h
>

30 #include 
	~<string.h
>

32 
class
 
	cString


34 
	mpublic
:

35 
String
();

36 
String
(const char *);

37 
String
(const String &);

38 ~
String
();

39 
	mString
 &
	moperator
=(const 
String
 &);

40 
	mString
 &
	moperator
=(const char *);

41 int 
	moperator
==(const 
String
 &) const;

42 int 
	moperator
!=(const 
String
 &) const;

43 int 
	moperator
==(const char *) const;

44 int 
	moperator
!=(const char *) const;

45 void 
	$display
() const;

46 
String
 *
	$clone
() const;

47 int 
	$length
() const;

48 void 
	`setstring
(const char *);

49 const char *
	$getstring
() const;

50 
private
:

51 char *
rep
;

54 
inline
 
String
::
	$String
()

56 
rep
 = 
new
 char[1];

57 
rep
[0] = '\0';

58 
	}
}

60 
inline
 
	gString
::~
	$String
()

62 
delete
 [] 
rep
;

63 
	}
}

65 
inline
 int 
	gString
::
operator
==(const 
String
 &
other
) const

67 return(
strcmp
(
rep
, 
other
.rep) == 0);

70 
inline
 int 
	gString
::
operator
!=(const 
String
 &
other
) const

72 return(
strcmp
(
rep
, 
other
.rep) != 0);

75 
inline
 int 
	gString
::
operator
==(const char *
s
) const

77 return(
strcmp
(
rep
, 
s
) == 0);

80 
inline
 int 
	gString
::
operator
!=(const char *
s
) const

82 return(
strcmp
(
rep
, 
s
) != 0);

85 
inline
 
	gString
 &String::
operator
=(const char *
str
)

87 
setstring
(
str
);

88 return(*
	gthis
);

91 
inline
 
String
 *
	gString
::
	$clone
() const

93 return(
new
 
	`String
(*
this
));

94 
	}
}

96 
inline
 int 
	gString
::
	$length
() const

98 return(
	`strlen
(
rep
));

99 
	}
}

101 
inline
 const char *
	gString
::
	$getstring
() const

103 return(
rep
);

104 
	}
}

106 
inline
 void 
	gString
::
	$display
() const

108 
	`printf
("%s", 
rep
);

109 
	}
}

111 
inline
 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gString
 &
	gs
)

113 return(
	gstream
 << 
	gs
.
getstring
());

116 
inline
 int 
	goperator
==(const char *
s
, const 
	gString
 &
	gstr
)

118 return(
	gstr
 == 
s
);

121 
inline
 int 
	goperator
!=(const char *
s
, const 
	gString
 &
	gstr
)

123 return(
	gstr
 != 
s
);

	@programs/8puzzle/8puzzle.cc

25 #include 
	~"8puzzle.h
"

27 
	gPuzzle
::
	$Puzzle
(
PNode
 *
start
, PNode *
target
)

28 :
	$DepthGraph
(4, 
start
, 
target
)

30 
	}
}

36 
	gPNode
::
	$PNode
(const char *
b
, int 
empty_x
, int 
empty_y
)

39 *
p
 = *
board
;

41 
i
;

43 for (
i
 = 0; i <= 8; i++)

44 *(
p
 + 
i
) = *(
b
 + i);

46 
x
 = 
empty_x
;

47 
y
 = 
empty_y
;

48 
	}
}

57 
	gPNode
::
	$PNode
(const char *
b
, int 
old_x
, int 
old_y
, int 
new_x
, int 
new_y
)

60 *
p
 = *
board
;

62 
i
;

64 for (
i
 = 0; i <= 8; i++)

65 *(
p
 + 
i
) = *(
b
 + i);

67 
board
[
old_x
][
old_y
] = board[
new_x
][
new_y
];

68 
board
[
new_x
][
new_y
] = 0;

70 
x
 = 
new_x
;

71 
y
 = 
new_y
;

72 
	}
}

75 void 
	gPNode
::
	$display
() const

78 
row
,

79 
col
;

81 for (
row
 = 0; row < 3; row++)

83 for (
col
 = 0; col < 3; col++)

84 
	`printf
("%d ", 
board
[
row
][
col
]);

85 
	`putchar
('\n');

87 
	`putchar
('\n');

88 
	}
}

97 int 
	gPNode
::
operator
==(const 
Node
 &
other
) const

99 const 
PNode
 &
pnother
 = (PNode &)
other
;

101 if (
	gx
 != 
pnother
.
x
 && 
y
 != pnother.y)

103 return(
compare_board
(
pnother
.
board
));

111 int 
	gPNode
::
	$compare_board
(const char 
bo
[3][3]) const

114 *
p
 = *
board
,

115 *
b
 = *
bo
;

117 
i
;

119 for (
i
 = 0; i <= 8; i++)

120 if (*(
p
 + 
i
) != *(
b
 + i))

124 
	}
}

133 
Node
 *
	gPNode
::
	$do_operator
(int 
index
)

135 switch(
index
)

138 return(
	`do_down
());

140 return(
	`do_up
());

142 return(
	`do_right
());

144 return(
	`do_left
());

145 
	}
}

148 
PNode
 *
	gPNode
::
	$do_left
() const

150 if (!
y
)

153 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y - 1));

154 
	}
}

157 
PNode
 *
	gPNode
::
	$do_right
() const

159 if (
y
 == (2))

162 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y + 1));

163 
	}
}

166 
PNode
 *
	gPNode
::
	$do_up
() const

168 if (!
x
)

171 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x - 1, y));

172 
	}
}

175 
PNode
 *
	gPNode
::
	$do_down
() const

177 if (
x
 == (2))

180 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x + 1, y));

181 
	}
}

184 #ifdef 
_MSC_VER


185 int 
	$no_mem
(
size_t
 
size
)

187 
	`fprintf
(
stderr
, "Out of memory\n");

188 
	`exit
(1);

190 
	}
}

192 void 
	$no_mem
()

194 
	`fprintf
(
stderr
, "Out of memory\n");

195 
	`exit
(1);

196 
	}
}

200 int 
	$main
()

203 
start
[3][3] = {

210 
goal
[3][3] = {

217 #ifdef 
_MSC_VER


218 
	`_set_new_handler
(
no_mem
);

220 
	`set_new_handler
(
no_mem
);

227 
Puzzle


228 
	`puzzle
(
new
 
	`PNode
(*
start
, 1, 1), new PNode(*
goal
, 1, 1));

230 if (
puzzle
.
	`generate
())

231 
puzzle
.
	`display
();

233 
	}
}

	@programs/8puzzle/8puzzle.h

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"aigraph.h
"

41 
class
 
	cPNode
 : 
public
 
DepthNode


43 
public
:

44 
PNode
(const char *, int 
empty_x
, int 
empty_y
);

45 
PNode
(const char *, int 
old_x
, int 
old_y
, int 
new_x
, int 
new_y
);

51 int 
	moperator
==(const 
Node
 &) const;

52 void 
	$display
() const;

53 
Node
 *
	`do_operator
(int);

54 
private
:

59 
PNode


60 *
	$do_left
() const,

61 *
	$do_right
() const,

62 *
	$do_up
() const,

63 *
	$do_down
() const;

64 int 
	$compare_board
(const char [3][3]) const;

66 
x
,

67 
y
;

69 
board
[3][3];

77 
class
 
	cPuzzle
 : 
public
 
DepthGraph


79 
public
:

80 
	`Puzzle
(
PNode
 *
start
, PNode *
target
);

	@programs/8puzzle/8puzzle2.cc

25 #include 
	~"8puzzle2.h
"

32 
	gPuzzle
::
	$Puzzle
(
PNode
 *
start
, PNode *
target
)

33 :
	$AStar
(4, 
start
, 
target
)

35 
goal
 = 
target
;

36 
	}
}

42 
	gPNode
::
	$PNode
(const char *
b
, int 
empty_x
, int 
empty_y
)

45 *
p
 = *
board
;

47 
i
;

49 for (
i
 = 0; i <= 8; i++)

50 *(
p
 + 
i
) = *(
b
 + i);

52 
x
 = 
empty_x
;

53 
y
 = 
empty_y
;

54 
	}
}

63 
	gPNode
::
	$PNode
(const char *
b
, int 
old_x
, int 
old_y
, int 
new_x
, int 
new_y
)

66 *
p
 = *
board
;

68 
i
;

70 for (
i
 = 0; i <= 8; i++)

71 *(
p
 + 
i
) = *(
b
 + i);

73 
board
[
old_x
][
old_y
] = board[
new_x
][
new_y
];

74 
board
[
new_x
][
new_y
] = 0;

76 
x
 = 
new_x
;

77 
y
 = 
new_y
;

78 
	}
}

81 void 
	gPNode
::
	$display
() const

84 
row
,

85 
col
;

87 for (
row
 = 0; row < 3; row++)

89 for (
col
 = 0; col < 3; col++)

90 
	`printf
("%d ", 
board
[
row
][
col
]);

91 
	`putchar
('\n');

93 
	`putchar
('\n');

94 
	}
}

103 int 
	gPNode
::
operator
==(const 
Node
 &
other
) const

105 const 
PNode
 &
pnother
 = (PNode &)
other
;

107 if (
	gx
 != 
pnother
.
x
 && 
y
 != pnother.y)

109 return(
compare_board
(
pnother
.
board
));

113 const char (*
	gPNode
::
	$get_board
() const)[3]

115 return(
board
);

116 
	}
}

123 int 
	gPNode
::
	$compare_board
(const char 
bo
[3][3]) const

126 *
p
 = *
board
,

127 *
b
 = *
bo
;

130 
i
;

132 for (
i
 = 0; i <= 8; i++)

133 if (*(
p
 + 
i
) != *(
b
 + i))

137 
	}
}

146 
Node
 *
	gPNode
::
	$do_operator
(int 
index
)

148 switch(
index
)

151 return(
	`do_left
());

153 return(
	`do_up
());

155 return(
	`do_right
());

157 return(
	`do_down
());

158 
	}
}

161 
PNode
 *
	gPNode
::
	$do_left
() const

163 if (!
y
)

166 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y - 1));

167 
	}
}

170 
PNode
 *
	gPNode
::
	$do_right
() const

172 if (
y
 == (2))

175 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y + 1));

176 
	}
}

179 
PNode
 *
	gPNode
::
	$do_down
() const

181 if (
x
 == (2))

184 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x + 1, y));

185 
	}
}

188 
PNode
 *
	gPNode
::
	$do_up
() const

190 if (!
x
)

193 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x - 1, y));

194 
	}
}

201 int 
	gPuzzle
::
	$compute_g
(const 
Node
 *)

204 
	}
}

211 int 
	gPuzzle
::
	$compute_h
(const 
Node
 *
node
)

213 const 
PNode
 *
pnode
 = (PNode *)
node
;

214 return(
	`totdist
(
pnode
->
	`get_board
(), 
goal
->get_board()));

215 
	}
}

226 int 
	gPuzzle
::
	$totdist
(const char 
now
[3][3], const char 
target
[3][3])

228 int 
nrow
, 
ncol
,

229 
trow
, 
tcol
,

230 
found
, 
tot
 = 0;

232 for (
nrow
 = 0; nrow < 3; nrow++)

234 for (
ncol
 = 0; ncol < 3; ncol++)

236 
found
 = 0;

237 if (
now
[
nrow
][
ncol
] == 0)

239 for (
trow
 = 0; trow < 3 && !
found
; trow++)

240 for (
tcol
 = 0; tcol < 3 && !
found
; tcol++)

241 if (
now
[
nrow
][
ncol
] == 
target
[
trow
][
tcol
])

243 
tot
 += 
	`abs
(
ncol
 - 
tcol
) + abs(
nrow
 - 
trow
);

244 
found
 = 1;

249 return(
tot
);

250 
	}
}

253 #ifdef 
_MSC_VER


254 int 
	$no_mem
(
size_t
 
size
)

256 
	`fprintf
(
stderr
, "Out of memory\n");

257 
	`exit
(1);

259 
	}
}

261 void 
	$no_mem
()

263 
	`fprintf
(
stderr
, "Out of memory\n");

264 
	`exit
(1);

265 
	}
}

269 int 
	$main
()

272 
start
[3][3] = {

279 
goal
[3][3] = {

287 #ifdef 
_MSC_VER


288 
	`_set_new_handler
(
no_mem
);

290 
	`set_new_handler
(
no_mem
);

297 
Puzzle


298 
	`puzzle
(
new
 
	`PNode
(*
start
, 2, 1), new PNode(*
goal
, 1, 1));

305 if (
puzzle
.
	`generate
())

307 
IntrList
<
Node
> *
sol
 = 
puzzle
.
	`get_sol
();

308 
IntrListIterator
<
Node
> 
	`iter
(*
sol
);

310 for (
PNode
 *
p
 = (PNode *)
iter
.
	`getfirst
(); p; p = (PNode *)iter.
	`getnext
())

311 
p
->
	`display
();

313 
delete
 
sol
;

316 
	}
}

	@programs/8puzzle/8puzzle2.h

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"aigraph.h
"

44 
class
 
	cPNode
 : 
public
 
BestNode


46 
public
:

47 
PNode
(const char *, int 
empty_x
, int 
empty_y
);

48 
PNode
(const char *, int, int, int, int);

49 const char (*
	$get_board
() const)[3];

55 int 
operator
==(const 
Node
 &) const;

56 void 
	$display
() const;

57 
Node
 *
	`do_operator
(int);

58 
private
:

63 
PNode


64 *
	$do_left
() const,

65 *
	$do_right
() const,

66 *
	$do_up
() const,

67 *
	$do_down
() const;

68 int 
	$compare_board
(const char [3][3]) const;

70 
x
,

71 
y
;

73 
board
[3][3];

81 
class
 
	cPuzzle
 : 
public
 
AStar


83 
public
:

84 
	`Puzzle
(
PNode
 *
start
, PNode *
target
);

89 int 
	`compute_g
(const 
Node
 *);

90 int 
	`compute_h
(const 
Node
 *);

91 
private
:

96 int 
	`totdist
(const char [3][3], const char[3][3]);

97 
PNode
 *
goal
;

	@programs/8puzzle/8puzzle3.cc

25 #include 
	~"8puzzle3.h
"

27 
	gPuzzle
::
	$Puzzle
(
PNode
 *
start
, PNode *
target
)

28 :
	$BiDepthGraph
(4, 
start
, 
target
)

30 
	}
}

36 
	gPNode
::
	$PNode
(const char *
b
, int 
empty_x
, int 
empty_y
)

39 *
p
 = *
board
;

41 
i
;

43 for (
i
 = 0; i <= 8; i++)

44 *(
p
 + 
i
) = *(
b
 + i);

46 
x
 = 
empty_x
;

47 
y
 = 
empty_y
;

48 
	}
}

57 
	gPNode
::
	$PNode
(const char *
b
, int 
old_x
, int 
old_y
, int 
new_x
, int 
new_y
)

60 *
p
 = *
board
;

62 
i
;

64 for (
i
 = 0; i <= 8; i++)

65 *(
p
 + 
i
) = *(
b
 + i);

67 
board
[
old_x
][
old_y
] = board[
new_x
][
new_y
];

68 
board
[
new_x
][
new_y
] = 0;

70 
x
 = 
new_x
;

71 
y
 = 
new_y
;

72 
	}
}

75 void 
	gPNode
::
	$display
() const

78 
row
,

79 
col
;

81 for (
row
 = 0; row < 3; row++)

83 for (
col
 = 0; col < 3; col++)

84 
	`printf
("%d ", 
board
[
row
][
col
]);

85 
	`putchar
('\n');

87 
	`putchar
('\n');

88 
	}
}

97 int 
	gPNode
::
operator
==(const 
Node
 &
other
) const

99 const 
PNode
 &
pnother
 = (PNode &)
other
;

101 if (
	gx
 != 
pnother
.
x
 && 
y
 != pnother.y)

103 return(
compare_board
(
pnother
.
board
));

111 int 
	gPNode
::
	$compare_board
(const char 
bo
[3][3]) const

114 *
p
 = *
board
,

115 *
b
 = *
bo
;

117 
i
;

119 for (
i
 = 0; i <= 8; i++)

120 if (*(
p
 + 
i
) != *(
b
 + i))

124 
	}
}

133 
Node
 *
	gPNode
::
	$do_operator
(int 
index
)

135 switch(
index
)

138 return(
	`do_left
());

140 return(
	`do_right
());

142 return(
	`do_up
());

144 return(
	`do_down
());

145 
	}
}

148 
PNode
 *
	gPNode
::
	$do_left
() const

150 if (!
y
)

153 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y - 1));

154 
	}
}

157 
PNode
 *
	gPNode
::
	$do_right
() const

159 if (
y
 == (2))

162 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x, y + 1));

163 
	}
}

166 
PNode
 *
	gPNode
::
	$do_up
() const

168 if (!
x
)

171 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x - 1, y));

172 
	}
}

175 
PNode
 *
	gPNode
::
	$do_down
() const

177 if (
x
 == (2))

180 return(
new
 
	`PNode
(*
board
, 
x
, 
y
, x + 1, y));

181 
	}
}

184 #ifdef 
_MSC_VER


185 int 
	$no_mem
(
size_t
 
size
)

187 
	`fprintf
(
stderr
, "Out of memory\n");

188 
	`exit
(1);

190 
	}
}

192 void 
	$no_mem
()

194 
	`fprintf
(
stderr
, "Out of memory\n");

195 
	`exit
(1);

196 
	}
}

200 int 
	$main
()

203 
start
[3][3] = {

210 
goal
[3][3] = {

217 #ifdef 
_MSC_VER


218 
	`_set_new_handler
(
no_mem
);

220 
	`set_new_handler
(
no_mem
);

223 
Puzzle


224 
	`puzzle
(
new
 
	`PNode
(*
start
, 1, 1), new PNode(*
goal
, 1, 1));

226 if (
puzzle
.
	`generate
())

227 
puzzle
.
	`display
();

230 
	}
}

	@programs/8puzzle/8puzzle3.h

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"aigraph.h
"

41 
class
 
	cPNode
 : 
public
 
Node


43 
public
:

44 
PNode
(const char *, int 
empty_x
, int 
empty_y
);

45 
PNode
(const char *, int, int, int, int);

51 int 
	moperator
==(const 
Node
 &) const;

52 void 
	$display
() const;

53 
Node
 *
	`do_operator
(int);

54 
private
:

59 
PNode


60 *
	$do_left
() const,

61 *
	$do_right
() const,

62 *
	$do_up
() const,

63 *
	$do_down
() const;

64 int 
	$compare_board
(const char [3][3]) const;

66 
x
,

67 
y
;

69 
board
[3][3];

78 
class
 
	cPuzzle
 : 
public
 
BiDepthGraph


80 
public
:

81 
	`Puzzle
(
PNode
 *
start
, PNode *
target
);

	@programs/logic/logic.cc

42 #include 
	~"logic.h
"

47 
TermType
 
	gVar
::
type
 = 
Var_T
;

48 
TermType
 
	gConstant
::
type
 = 
Constant_T
;

49 
TermType
 
	gComplex
::
type
 = 
Complex_T
;

56 unsigned int 
	gVar
::
vartable
[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

58 
	gTerm
::~
	$Term
()

60 
	}
}

62 
Term
 *Term::
	$clone
() const

64 return(
	`dup
());

65 
	}
}

67 int 
	gTerm
::
operator
==(const 
Term
 &
other
)

69 return(
match
(
other
));

76 int 
	gTerm
::
	$occurs_in
(const 
Var
 *) const

79 
	}
}

89 
	gVar
::
	$Var
(const char *
str
)

91 
name
 = *
str
;

93 
val
 = 
	`atoi
(
str
 + 1);

94 if (
val
 > 
vartable
[
name
 - 'A'])

95 
vartable
[
name
 - 'A'] = 
val
;

96 
	}
}

98 
TermType
 
	gVar
::
	$gettype
() const

100 return(
type
);

101 
	}
}

110 const 
Term
 *
	gVar
::
	$get_realvalue
(const 
Substitution
 &
subst
) const

112 const 
Term
 *
ret
 = 
subst
.
	`get_bound
(*
this
);

113 return(
ret
 ? ret: 
this
);

114 
	}
}

116 int 
	gVar
::
	$unify_me
(const 
Term
 &
other
, 
Substitution
 &
subst
) const

118 const 
Term
 *
one
, *
two
;

126 
one
 = 
	`get_realvalue
(
subst
);

127 if (
one
->
	`gettype
() != 
Var_T
)

128 return(
one
->
	`unify_me
(
other
, 
subst
));

134 
two
 = 
other
.
	`get_realvalue
(
subst
);

137 if (
one
->
	`match
(*
two
))

144 if (
two
->
	`occurs_in
((
Var
 *)
one
))

148 
subst
.
	`add_binding
(*(
Var
 *)
one
, *
two
);

150 
	}
}

152 int 
	gVar
::
	$match
(const 
Term
 &
other
) const

154 if (
other
.
	`gettype
() != 
type
)

156 return((((
Var
 &)
other
).
name
 == name) && (((Var &)other).
val
 == val));

157 
	}
}

159 
Term
 *
	gVar
::
	$dup
() const

161 return(
new
 
	`Var
(*
this
));

162 
	}
}

164 void 
	gVar
::
	$display
(
ostream
 &
stream
) const

166 
stream
 << 
name
;

167 if (
val
)

168 
stream
 << 
val
;

169 
	}
}

176 void 
	gVar
::
	$update
()

178 
vartable
[
name
 - 'A']++;

179 
val
 = 
vartable
[
name
 - 'A'];

180 
	}
}

182 
	gConstant
::
	$Constant
(const char *
str
)

184 
val
 = 
str
;

185 
	}
}

187 
TermType
 
	gConstant
::
	$gettype
() const

189 return(
type
);

190 
	}
}

192 const 
Term
 *
	gConstant
::
	$get_realvalue
(const 
Substitution
 &
subst
) const

195 return(
this
);

196 
	}
}

198 int 
	gConstant
::
	$unify_me
(const 
Term
 &
other
, 
Substitution
 &
subst
) const

200 const 
Term
 *
two
;

206 
two
 = 
other
.
	`get_realvalue
(
subst
);

209 if (
	`match
(*
two
))

213 if (
two
->
	`gettype
() == 
Var_T
)

215 
subst
.
	`add_binding
(*(
Var
 *)
two
, *
this
);

219 
	}
}

221 int 
	gConstant
::
	$match
(const 
Term
 &
other
) const

223 return((
other
.
	`gettype
() == 
type
) && (((
Constant
 &)other).
val
 == val));

224 
	}
}

226 
Term
 *
	gConstant
::
	$dup
() const

228 return(
new
 
	`Constant
(*
this
));

229 
	}
}

231 void 
	gConstant
::
	$display
(
ostream
 &
stream
) const

233 
stream
 << 
val
;

234 
	}
}

236 
	gComplex
::
	$Complex
()

238 
	}
}

240 
Complex
::
	$Complex
(const char *
str
)

242 
	`parse_string
(
str
);

243 
	}
}

245 
	gComplex
 &Complex::
operator
=(const 
Complex
 &
other
)

247 if (
this
 != &
other
)

249 
functor
 = 
other
.functor;

250 
	garguments
 = 
other
.
arguments
;

253 return(*
	gthis
);

256 
	gComplex
 &Complex::
operator
=(const char *
str
)

258 
arguments
.
clear
(
DoDel
);

259 
parse_string
(
str
);

260 return(*
	gthis
);

263 int 
	gComplex
::
operator
==(const 
Complex
 &
other
) const

265 return(
match
(
other
));

268 int 
	gComplex
::
operator
!=(const 
Complex
 &
other
) const

270 return(!
match
(
other
));

273 
TermType
 
	gComplex
::
	$gettype
() const

275 return(
type
);

276 
	}
}

278 const 
Term
 *
	gComplex
::
	$get_realvalue
(const 
Substitution
 &
subst
) const

281 return(
this
);

282 
	}
}

288 int 
	gComplex
::
	$unify
(const 
Complex
 &
other
, 
Substitution
 &
subst
) const

290 if (!
	`unify_me
(
other
, 
subst
))

292 
subst
.
	`clear
();

296 
	}
}

298 int 
	gComplex
::
	$unify_me
(const 
Term
 &
other
, 
Substitution
 &
subst
) const

300 const 
Term
 *
two
;

301 
Complex
 *
c_two
;

302 int 
arity
;

308 
two
 = 
other
.
	`get_realvalue
(
subst
);

311 if (
	`match
(*
two
))

318 if (
two
->
	`gettype
() == 
Var_T
 && !
	`occurs_in
((
Var
 *)two))

320 
subst
.
	`add_binding
(*(
Var
 *)
two
, *
this
);

325 if (
two
->
	`gettype
() == 
Constant_T
)

333 
c_two
 = (
Complex
 *)
two
;

334 
arity
 = 
arguments
.
	`getsize
();

335 if ((
c_two
->
functor
 != functor) || (c_two->
arguments
.
	`getsize
() != 
arity
))

342 for (int 
i
 = 0; i < 
arity
; i++)

344 if (!
arguments
[
i
]->
	`unify_me
(*
c_two
->arguments[i], 
subst
))

348 
	}
}

350 int 
	gComplex
::
	$match
(const 
Term
 &
other
) const

352 if (
other
.
	`gettype
() != 
type
)

355 
Complex
 &
c_other
 = (Complex &)
other
;

358 if (
c_other
.
functor
 != functor)

365 return(
arguments
 == 
c_other
.arguments);

366 
	}
}

368 
Complex
 *
	gComplex
::
	$clone
() const

370 return(
new
 
	`Complex
(*
this
));

371 
	}
}

373 
Term
 *
	gComplex
::
	$dup
() const

375 return(
new
 
	`Complex
(*
this
));

376 
	}
}

378 void 
	gComplex
::
	$display
(
ostream
 &
stream
) const

380 int 
arity
 = 
arguments
.
	`getsize
();

382 
stream
 << 
functor
 << "(";

383 if (
arity
)

385 
arguments
[0]->
	`display
(
stream
);

386 for (int 
i
 = 1; i < 
arity
; i++)

388 
stream
 << ", ";

389 
arguments
[
i
]->
	`display
(
stream
);

392 
stream
 << ")";

393 
	}
}

395 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gComplex
 &
	gcomplex
)

397 
	gcomplex
.
display
(
stream
);

398 return(
	gstream
);

401 void 
	gComplex
::
	$display
() const

403 
cout
 << *
this
;

404 
	}
}

406 int 
	gComplex
::
	$notempty
() const

408 return(
arguments
.
	`getsize
());

409 
	}
}

415 int 
	gComplex
::
	$occurs_in
(const 
Var
 *
var
) const

417 int 
arity
 = 
arguments
.
	`getsize
();

419 for (int 
i
 = 0; i < 
arity
; i++)

425 if (
arguments
[
i
]->
	`gettype
() == 
Complex_T
)

427 if (
arguments
[
i
]->
	`occurs_in
(
var
))

431 else if (
arguments
[
i
]->
	`match
(*
var
))

435 
	}
}

442 void 
	gComplex
::
	$apply_subst
(
Substitution
 &
subst
)

444 const 
Term
 *
val
;

445 int 
i
, 
arity
 = 
arguments
.
	`getsize
();

447 for (
i
 = 0; i < 
arity
; i++)

454 if (
arguments
[
i
]->
	`gettype
() == 
Var_T
)

456 
val
 = 
subst
.
	`get_bound
(*(
Var
 *)
arguments
[
i
]);

457 if (
val
)

459 
	`delete
(
arguments
[
i
]);

460 
arguments
[
i
] = 
val
->
	`dup
();

467 else if (
arguments
[
i
]->
	`gettype
() == 
Complex_T
)

468 ((
Complex
 *)
arguments
[
i
])->
	`apply_subst
(
subst
);

470 
	}
}

487 void 
	gComplex
::
	$update_vars
(
Substitution
 &
subst
)

489 const 
Term
 *
term
;

490 int 
i
, 
arity
 = 
arguments
.
	`getsize
();

492 for (
i
 = 0; i < 
arity
; i++)

501 if (
arguments
[
i
]->
	`gettype
() == 
Var_T
)

503 
term
 = 
subst
.
	`get_bound
(*(
Var
 *)
arguments
[
i
]);

504 if (!
term
)

506 
Var
 
old
 = *(Var *)
arguments
[
i
];

507 ((
Var
 *)
arguments
[
i
])->
	`update
();

509 
subst
.
	`add_binding
(
old
, *
arguments
[
i
]);

513 
delete
 
arguments
[
i
];

514 
arguments
[
i
] = 
term
->
	`dup
();

521 else if (
arguments
[
i
]->
	`gettype
() == 
Complex_T
)

522 ((
Complex
 *)
arguments
[
i
])->
	`update_vars
(
subst
);

524 
	}
}

526 void 
	gComplex
::
	$update_vars
()

528 
Substitution
 
subst
;

529 
	`update_vars
(
subst
);

530 
	}
}

532 
	gBinding
::
	$Binding
(const 
Var
 &
t1
, const 
Term
 &
t2
)

534 
first
 = (
Var
 *)
t1
.
	`dup
();

535 
second
 = 
t2
.
	`dup
();

536 
	}
}

538 
	gBinding
::
	$Binding
(const 
Binding
 &
other
)

540 
first
 = (
Var
 *)
other
.first->
	`dup
();

541 
second
 = 
other
.second->
	`dup
();

542 
	}
}

544 
	gBinding
 &Binding::
operator
=(const 
Binding
 &
other
)

546 if (
this
 != &
other
)

548 
delete
 
first
;

549 
delete
 
	gsecond
;

551 
	gfirst
 = (
Var
 *)
other
.
first
->
dup
();

552 
	gsecond
 = 
other
.
second
->
dup
();

554 return(*
	gthis
);

557 
	gBinding
::~
	$Binding
()

559 
delete
 
first
;

560 
delete
 
second
;

561 
	}
}

563 int 
	gBinding
::
operator
==(const 
Binding
 &
other
) const

565 if (!
first
->
match
(*
other
.first))

567 return(
	gsecond
->
match
(*
other
.
second
));

570 
Binding
 *
	gBinding
::
	$clone
() const

572 return(
new
 
	`Binding
(*
this
));

573 
	}
}

581 void 
	gBinding
::
	$replace_binding
(
Binding
 *
bind
)

592 if (
second
->
	`gettype
() == 
Complex_T
)

594 
Substitution
 
s
;

596 
s
.
	`add_binding
(*
bind
->
first
, *bind->
second
);

597 ((
Complex
 *)
second
)->
	`apply_subst
(
s
);

606 else if(
second
->
	`match
(*
bind
->
first
))

608 
	`delete
(
second
);

609 
second
 = 
bind
->second->
	`dup
();

611 
	}
}

613 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gBinding
 &
	gbind
)

615 
	gbind
.
	gfirst
->
display
(
stream
);

616 
	gstream
 << "/";

617 
	gbind
.
	gsecond
->
display
(
stream
);

618 return(
	gstream
);

621 int 
	gSubstitution
::
operator
==(const 
Substitution
 &
other
) const

623 if (
bindings
.
getsize
() != 
other
.bindings.getsize())

626 for (int 
	gi
 = 0; i < 
	gbindings
.
getsize
(); i++)

627 if (
	gother
.
	gbindings
.
find
(
bindings
[
i
]) < 0)

632 int 
	gSubstitution
::
operator
!=(const 
Substitution
 &
other
) const

634 return(!(*
this
 == 
other
));

637 
Substitution
 *
	gSubstitution
::
	$clone
() const

639 return(
new
 
	`Substitution
(*
this
));

640 
	}
}

642 int 
	gSubstitution
::
	$is_empty
() const

644 return(
bindings
.
	`getsize
() == 0);

645 
	}
}

654 void 
	gSubstitution
::
	$add_binding
(const 
Var
 &
var
, const 
Term
 &
term
)

657 
Binding
 *
bind
 = 
new
 
	`Binding
(
var
, 
term
);

660 for (int 
i
 = 0; i < 
bindings
.
	`getsize
(); i++)

661 
bindings
[
i
]->
	`replace_binding
(
bind
);

664 
bindings
 += 
bind
;

665 
	}
}

678 int 
	gSubstitution
::
	$compose
(const 
Substitution
 &
other
)

680 const 
Term
 *
term
;

681 int 
i
;

683 for (
i
 = 0; i < 
bindings
.
	`getsize
(); i++)

689 
term
 = 
other
.
	`get_bound
(*(
Var
 *)
bindings
[
i
]->
first
);

691 if (
term
)

697 if (!
bindings
[
i
]->
second
->
	`match
(*
term
))

706 if (
other
.
	`occurs_in
((
Var
 *)
bindings
[
i
]->
first
))

716 for (
i
 = 0; i < 
other
.
bindings
.
	`getsize
(); i++)

717 if (
bindings
.
	`find
(
other
.bindings[
i
]) < 0)

718 
	`add_binding
(*
other
.
bindings
[
i
]->
first
, *other.bindings[i]->
second
);

721 
	}
}

732 void 
	gSubstitution
::
	$update
(const 
Substitution
 &
other
)

734 const 
Term
 *
term
;

735 int 
i
, 
numbind
 = 
bindings
.
	`getsize
();

737 for (
i
 = 0; i < 
numbind
; i++)

739 if (
bindings
[
i
]->
second
->
	`gettype
() == 
Var_T
)

746 
term
 = 
other
.
	`get_bound
(*(
Var
 *)
bindings
[
i
]->
second
);

747 if (
term
)

749 
delete
 
bindings
[
i
]->
second
;

750 
bindings
[
i
]->
second
 = 
term
->
	`dup
();

754 
	}
}

760 int 
	gSubstitution
::
	$occurs_in
(const 
Var
 *
var
) const

762 int 
numbind
 = 
bindings
.
	`getsize
();

764 for (int 
i
 = 0; i < 
numbind
; i++)

765 if (
bindings
[
i
]->
second
->
	`occurs_in
(
var
))

769 
	}
}

775 const 
Term
 *
	gSubstitution
::
	$get_bound
(const 
Var
 &
term
) const

777 int 
i
, 
numbind
 = 
bindings
.
	`getsize
();

779 for (
i
 = 0; i < 
numbind
; i++)

781 if (
bindings
[
i
]->
first
->
	`match
(
term
))

782 return(
bindings
[
i
]->
second
);

784 return(
NULL
);

785 
	}
}

787 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gSubstitution
 &
	gsubst
)

789 int 
	gnumbind
 = 
subst
.
bindings
.
getsize
();

791 
	gstream
 << "(";

793 if (
	gnumbind
)

795 
	gstream
 << *
	gsubst
.
	gbindings
[0];

796 for (int 
	gi
 = 1; i < 
	gnumbind
; i++)

797 
	gstream
 << ", " << *
	gsubst
.
	gbindings
[
i
];

799 
	gstream
 << ")";

800 return(
	gstream
);

803 void 
	gSubstitution
::
	$clear
()

805 
bindings
.
	`clear
(
DoDel
);

806 
	}
}

813 void 
	gComplex
::
	$parse_string
(const char *
str
)

815 char 
tmp
, *
foo
, *
p
;

817 if (!(
foo
 = 
	`strdup
(
str
)))

819 
	`puts
("Complex::Complex() - Out of memory");

820 
	`exit
(0);

823 for (
p
 = 
foo
; *p && 
	`isalpha
(*p); p++)

825 if (!*
p
)

826 
	`parse_error
("Unexpected end of term", 
foo
, 
p
);

827 if (*
p
 != '(')

828 
	`parse_error
("Unexpected character", 
foo
, 
p
);

830 
tmp
 = *
p
;

831 *
p
 = '\0';

833 
functor
 = 
foo
;

835 *
p
 = 
tmp
;

837 
	`read_body
(
foo
, 
p
 + 1);

838 
	`delete
(
foo
);

839 
	}
}

841 char *
	gComplex
::
	$read_body
(char *
str
, char *
pos
)

843 
Term
 *
term
;

844 char 
c
, *
p
, *
start
, *
space
;

845 char *
end_msg
 = "unexpected end of term";

847 for (
p
 = 
pos
; *p; p++)

849 while (*
p
 && 
	`isspace
(*p))

850 
p
++;

851 if (!*
p
)

852 
	`parse_error
(
end_msg
, 
str
, 
p
);

853 
start
 = 
p
;

856 if (
	`isupper
(*
p
))

858 while (*++
p
 && 
	`isdigit
(*p))

860 if (!*
p
)

861 
	`parse_error
(
end_msg
, 
str
, 
p
);

863 if (
	`isspace
(*
p
))

865 
space
 = 
p
;

866 while (*++
p
 && 
	`isspace
(*p))

868 if (!*
p
)

869 
	`parse_error
(
end_msg
, 
str
, 
p
);

870 if (*
p
 != ',' && *p != ')')

871 
	`parse_error
("unexpected character", 
str
, 
p
);

872 
c
 = *
space
;

873 *
space
 = '\0';

874 
term
 = 
new
 
	`Var
(
start
);

875 *
space
 = 
c
;

879 if (*
p
 != ',' && *p != ')')

880 
	`parse_error
("digit expected", 
str
, 
p
);

881 
c
 = *
p
;

882 *
p
 = '\0';

883 
term
 = 
new
 
	`Var
(
start
);

884 *
p
 = 
c
;

891 while (*++
p
 && 
	`isalpha
(*p))

893 if (!*
p
)

894 
	`parse_error
(
end_msg
, 
str
, 
p
);

897 if (*
p
 == '(')

899 
Complex
 *
cp
 = 
new
 Complex;

901 
c
 = *
p
;

902 *
p
 = '\0';

903 
cp
->
functor
 = 
start
;

904 *
p
 = 
c
;

905 
p
 = 
cp
->
	`read_body
(
str
, p + 1);

906 if (!*
p
)

907 
	`parse_error
(
end_msg
, 
str
, 
p
);

908 if (*
p
 != ')')

909 
	`parse_error
(") expected", 
str
, 
p
);

911 
p
++;

912 
term
 = 
cp
;

918 if (!*
p
)

919 
	`parse_error
(
end_msg
, 
str
, 
p
);

920 if (
	`isspace
(*
p
))

922 
space
 = 
p
;

923 while (*++
p
 && 
	`isspace
(*p))

925 if (!*
p
)

926 
	`parse_error
(
end_msg
, 
str
, 
p
);

927 if (*
p
 != ',' && *p != ')')

928 
	`parse_error
("unexpected character", 
str
, 
p
);

929 
c
 = *
space
;

930 *
space
 = '\0';

931 
term
 = 
new
 
	`Constant
(
start
);

932 *
space
 = 
c
;

936 if (*
p
 != ',' && *p != ')')

937 
	`parse_error
("character or digit expected", 
str
, 
p
);

938 
c
 = *
p
;

939 *
p
 = '\0';

940 
term
 = 
new
 
	`Constant
(
start
);

941 *
p
 = 
c
;

946 
arguments
 += 
term
;

947 if (!
	`isspace
(*
p
) && *p != ',')

948 return(
p
);

951 return(
p
);

952 
	}
}

954 void 
	gComplex
::
	$parse_error
(char *
msg
, char *
str
, char *
pos
)

956 int 
i
 = 
pos
 - 
str
;

958 
	`printf
("%s\n", 
str
);

960 while (
i
--)

961 
	`putchar
(' ');

963 if (*
pos
)

964 
	`printf
("^ '%c': %s\n", *
pos
, 
msg
);

966 
	`printf
("^: %s\n", 
msg
);

968 
	`exit
(0);

969 
	}
}

	@programs/logic/test1.cc

25 #include 
	~"logic.h
"

27 int 
	$main
()

29 
Complex
 
a
,

30 
	`b
("f(g(Y), f(g(a), Z))"),

31 
	`c
("f(X11, g(b))"),

32 
	`d
("f(a, Y1234)"),

33 
	`e
("g(a)"),

34 
	`f
(
b
);

36 
Substitution
 
s
, 
s2
, 
s3
;

38 
cout
 << 
a
 << " " << 
f
 << "\n";

39 
a
 = "f(X, f(X, Y))";

41 
cout
 << 
a
 << "\n" << 
b
 << "\n" << a.
	`unify
(b, 
s
) << "\n";

42 
cout
 << 
s
 << "\n";

44 
a
.
	`apply_subst
(
s
);

45 
cout
 << 
a
 << "\n";

46 
cout
 << (
a
 == 
b
) << " " << (a == a) << "\n";

48 
c
.
	`unify
(
d
, 
s2
);

49 
s3
 = 
s2
;

50 
cout
 << 
s2
 << " " << (
s
 == s) << " " << " " << (s == s2) << " " << 
s3
 << "\n";

52 
cout
 << 
e
 << "\n";

53 
e
 = 
d
;

54 
cout
 << 
e
 << " " << 
d
 << "\n";

57 
	}
}

	@programs/logic/test2.cc

25 #include 
	~"logic.h
"

27 int 
	$main
()

29 
Complex
 
	`a
("f(X)"), 
	`a2
("f(g(Y))"),

30 
	`a3
("f(Y)"), 
	`a4
("f(f(X))"), 
	`a5
("f(f(a))");

31 
Substitution
 
s
, 
s2
, 
s3
;

33 
a
.
	`unify
(
a2
, 
s
);

34 
cout
 << 
s
 << "\n";

36 
a3
.
	`unify
(
a4
, 
s2
);

37 
cout
 << 
s2
 << "\n" << 
s
.
	`compose
(s2) << " " << s << "\n";

39 
a3
.
	`unify
(
a5
, 
s3
);

40 
cout
 << 
s3
 << "\n" << 
s
.
	`compose
(s3) << "\n" << s << "\n";

42 
a
.
	`apply_subst
(
s
);

43 
cout
 << 
a
 << "\n";

46 
	}
}

	@programs/logic/test3.cc

25 #include 
	~"logic.h
"

27 int 
	$main
()

29 
Substitution
 
s
, 
s2
, 
s3
;

30 
Complex
 
	`c
("f(X, g(X, f(g(X2, X))), X2, X)"),

31 
	`c2
("f(X, X2, X4)"),

32 
	`c3
("f(X, X2, a)"),

33 
	`a
("f(X)"),

34 
	`b
("f(a)");

36 
cout
 << 
c
 << "\n";

37 
c
.
	`update_vars
(
s
);

38 
cout
 << 
c
 << " " << 
s
 << "\n";

39 
cout
 << 
c2
 << "\n";

40 
c2
.
	`unify
(
c3
, 
s
);

41 
c2
.
	`update_vars
(
s
);

42 
cout
 << 
c2
 << "\n";

44 
a
.
	`unify
(
b
, 
s2
);

45 
s3
 = 
s2
;

46 
cout
 << 
s3
 << "\n" << 
s2
.
	`compose
(s3) << " " << s2 << "\n";

49 
	}
}

	@programs/parser/data.cc

25 #include 
	~"parser.h
"

32 
Rule


33 
	grules
[] = {

34 
Rule
(
S
, 
NP
, 
VP
, 
END
),

35 
Rule
(
NP
, 
NP1
, 
END
),

36 
Rule
(
NP
, 
DET
, 
N
, 
END
),

37 
Rule
(
VP
, 
IV
, 
END
),

38 
Rule
(
VP
, 
TV
, 
NP
, 
END
),

39 
Rule
(
VP
, 
TV2
, 
CN
, 
S
, 
END
),

42 int 
	gMaxRule
 = 6;

48 
Word


49 
	glexicon
[] = {

50 
Word
(
TV
, "kills"),

51 
Word
(
TV2
, "thinks"),

52 
Word
(
IV
, "sleeps"),

53 
Word
(
NP1
, "john"),

54 
Word
(
N
, "man"),

55 
Word
(
DET
, "the"),

56 
Word
(
CN
, "that"),

59 int 
	gMaxWord
 = 7;

	@programs/parser/parser.cc

25 #include 
	~"parser.h
"

32 *
	gtable
[] = {"s", "vp", "iv", "tv", "tv2", "np", "np1",

35 
	gRule
::
	$Rule
(
Item
 
item1
, ...)

37 
Item
 
p
;

38 
va_list
 
args
;

40 
	`va_start
(
args
, 
item1
);

41 
head
 = 
item1
;

43 while ((
p
 = 
	`va_arg
(
args
, 
Item
)) != 
END
)

44 
body
.
	`addtotail
(
p
);

46 
	`va_end
(
args
);

47 
	}
}

49 void 
	gRule
::
	$display
() const

51 
ROListIterator
<
Item
> 
	`iter
(
body
);

52 int 
i
;

53 
Item
 
n
;

55 
	`printf
("%s --> ", 
table
[
head
]);

57 
n
 = 
iter
.
	`getfirst
();

58 
	`printf
("%s ", 
table
[
n
]);

59 for (
i
 = 1; i < 
body
.
	`getcount
(); i++)

61 
n
 = 
iter
.
	`getnext
();

62 
	`printf
("%s ", 
table
[
n
]);

64 
	`putchar
('\n');

65 
	}
}

72 const 
	gList
<
	gItem
> *
	gRule
::
	$match
(
Item
 
item
) const

74 return(
item
 == 
head
 ? &
body
 : 0);

75 
	}
}

77 
	gWord
::
	$Word
(
Item
 
item
, const char *
wrd
)

79 
head
 = 
item
;

80 
word
 = 
wrd
;

81 
	}
}

83 void 
	gWord
::
	$display
() const

85 
cout
 << 
table
[
head
] << ":" << 
word
 << "\n";

86 
	}
}

92 int 
	gWord
::
	$match
(
Item
 
item
, const char *
wrd
) const

94 return(
head
 == 
item
 && 
word
 == 
wrd
);

95 
	}
}

97 
	gParse
::
	$Parse
(char **
sntnc
, int 
length
, 
Element
 *
start
)

98 : 
	$AODepthTree
(0, 
start
)

100 
sentence
 = 
sntnc
;

101 
index
 = 0;

102 
size
 = 
length
;

103 
	}
}

105 
	gElement
::
	$Element
(
Item
 
it
)

107 
item
 = 
it
;

108 
	}
}

110 void 
	gElement
::
	$display
() const

112 
	`printf
("%s\n", 
table
[
item
]);

113 
	}
}

119 int 
	gElement
::
operator
==(const 
Node
 &
other
) const

121 return(
item
 == ((
Element
 &)
other
).item);

124 
Item
 
	gElement
::
	$get_item
() const

126 return(
item
);

127 
	}
}

138 
	gIntrList
<
	gNode
> *
	gElement
::
	$expand
(int )

140 
IntrList
<
Node
> *
ret
 = 
new
 IntrList<Node>;

141 int 
i
;

143 for (
i
 = 0; i < 
MaxRule
; i++)

145 const 
List
<
Item
> *
rhs
;

146 
AndNode
 *
andnode
;

148 if ((
rhs
 = 
rules
[
i
].
	`match
(
item
)))

150 
Item
 
lhs_element
;

151 
ROListIterator
<
Item
> 
	`iter
(*
rhs
);

152 int 
d
;

154 
andnode
 = 
new
 
	`AndNode
();

155 
lhs_element
 = 
iter
.
	`getfirst
();

156 
andnode
->
	`addsucc
(
new
 
	`Element
(
lhs_element
));

157 for (
d
 = 1; d < 
rhs
->
	`getcount
(); d++)

159 
lhs_element
 = 
iter
.
	`getnext
();

160 
andnode
->
	`addsucc
(
new
 
	`Element
(
lhs_element
));

163 
ret
->
	`addtotail
(
andnode
);

166 return(
ret
);

167 
	}
}

178 int 
	gParse
::
	$is_terminal
(const 
AONode
 *
node
)

181 
i
;

183 if (
index
 >= 
size
)

186 for (
i
 = 0; i < 
MaxWord
; i++)

187 if (
lexicon
[
i
].
	`match
(((
Element
 *)
node
)->
	`get_item
(), 
sentence
[
index
]))

189 
index
++;

194 
	}
}

	@programs/parser/parser.h

25 #ifndef 
_PARSER_H_


26 #define 
	#_PARSER_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<stdarg.h
>

30 #include 
	~"aitree.h
"

31 #include 
	~"xarray.h
"

32 #include 
	~"xlist.h
"

33 #include 
	~"xstring.h
"

41 enum 
	eItem


43 
	mS
,

44 
	mVP
,

45 
	mIV
,

46 
	mTV
,

47 
	mTV2
,

48 
	mNP
,

49 
	mNP1
,

50 
	mN
,

51 
	mDET
,

52 
	mCN
,

55 #define 
	#END
 -1

	)
67 
class
 
	cRule


69 
	mpublic
:

70 
Rule
(
Item
, ...);

71 void 
	$display
() const;

72 const 
List
<
Item
> *
	$match
(Item) const;

73 
private
:

74 
Item
 
head
;

75 
List
<
Item
> 
body
;

83 
class
 
	cWord


85 
public
:

86 
	`Word
(
Item
, const char *);

87 void 
	$display
() const;

88 int 
	$match
(
Item
, const char *) const;

89 
private
:

90 
Item
 
head
;

91 
String
 
word
;

94 extern 
Rule
 
rules
[];

95 extern int 
MaxRule
;

96 extern 
Word
 
lexicon
[];

97 extern int 
MaxWord
;

109 
class
 
	cElement
 : 
public
 
OrNode


111 
public
:

112 
	`Element
(
Item
);

113 
Item
 
	$get_item
() const;

115 int 
operator
==(const 
Node
 &) const;

116 void 
	$display
() const;

117 
IntrList
<
Node
> *
	`expand
(int);

118 
private
:

119 
Item


120 
item
;

130 
class
 
	cParse
 : 
public
 
AODepthTree


132 
public
:

133 
	`Parse
(char **, int, 
Element
 *);

134 int 
	`is_terminal
(const 
AONode
 *);

135 
private
:

137 **
sentence
;

139 
index
,

140 
size
;

	@programs/parser/run.cc

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"parser.h
"

29 #ifdef 
_MSC_VER


30 int 
	$no_mem
(
size_t
 
size
)

32 
	`fprintf
(
stderr
, "Out of memory\n");

33 
	`exit
(1);

35 
	}
}

37 void 
	$no_mem
()

39 
	`fprintf
(
stderr
, "Out of memory\n");

40 
	`exit
(1);

41 
	}
}

45 int 
	$main
(int 
argc
, char *
argv
[])

49 #ifdef 
_MSC_VER


50 
	`_set_new_handler
(
no_mem
);

52 
	`set_new_handler
(
no_mem
);

55 if (
argc
 == 1)

57 
	`printf
("Usage: %s <string>\n", 
argv
[0]);

58 
	`exit
(0);

60 
Parse


61 
	`sentence
(++
argv
, 
argc
 -1, 
new
 
	`Element
(
S
));

63 if (
sentence
.
	`generate
())

64 
sentence
.
	`display
();

65 
	}
}

	@programs/planner/frule.cc

25 #include 
	~"strips.h
"

32 
Frule
 
	gfrulearr
[
MAXFRULE
] = {

33 
Frule
("stack(X, Y)",

38 
Frule
("unstack(X, Y)",

43 
Frule
("pickup(X)",

48 
Frule
("putdown(X)",

	@programs/planner/planner.cc

25 #include 
	~"strips.h
"

27 
StackItemType
 
	gFact
::
TypeId
 = 
T_Fact
;

28 
StackItemType
 
	gFactList
::
TypeId
 = 
T_FactList
;

29 
StackItemType
 
	gAction
::
TypeId
 = 
T_Action
;

31 
	gBasFact
::~
	$BasFact
()

33 
	}
}

35 
BasFact
 *BasFact::
	$clone
() const

37 return(
	`basdup
());

38 
	}
}

40 
	gFact
::
	$Fact
(const char *
str
)

41 : 
	$Complex
(
str
)

43 
	}
}

45 int 
Fact
::
operator
==(const 
BasFact
 &
other
) const

47 if (
other
.
getstacktype
() != 
T_Fact
)

49 return(
	gComplex
::
operator
==((
Fact
 &)
other
));

52 
StackItemType
 
	gFact
::
	$getstacktype
() const

54 return(
TypeId
);

55 
	}
}

57 
BasFact
 *
	gFact
::
	$basdup
() const

59 return(
	`clone
());

60 
	}
}

62 
Fact
 *
	gFact
::
	$clone
() const

64 return(
new
 
	`Fact
(*
this
));

65 
	}
}

67 void 
	gFact
::
	$display
() const

69 
Complex
::
	`display
();

70 
	}
}

72 void 
	gFact
::
	$apply_subst
(
Substitution
 &
s
)

74 
Complex
::
	`apply_subst
(
s
);

75 
	}
}

77 void 
	gFact
::
process_strips
(
StripsObject
 *
parent
, 
IntrList
<
Node
> *
succs
)

79 
	gPtrListIterator
<
	gFact
> 
iter
(
parent
->
world
);

80 
Fact
 *
	gf
;

82 
StripsObject
 *
	gkid
 = 0;

93 for (
	gf
 = 
iter
.
getfirst
(); f; f = iter.
getnext
())

95 
Substitution
 
subst
;

98 
	gsubst
.
clear
();

101 if (
unify
(*
f
, 
subst
))

108 
	gkid
 = 
parent
->
dup
();

109 
	gkid
->
	gstack
.
remove_head
(
DoDel
);

112 
	gsuccs
->
addtotail
(
kid
);

118 if (
	gsubst
.
is_empty
())

127 
	gPtrListIterator
<
	gBasFact
> 
it
(
kid
->
stack
);

129 for (
BasFact
 *
	gb
 = 
it
.
getfirst
(); b; b = it.
getnext
())

130 
b
->
apply_subst
(
subst
);

139 if (!
	gkid
)

141 
Action
 *
	gact
;

144 for (int 
	gi
 = 0; i < 
	gMAXFRULE
; i ++)

153 
	gact
 = 
frulearr
[
i
].
create_action
(*
this
);

155 if (
	gact
)

162 if (
	gparent
->
	gstack
.
lookup
(
act
) != 0)

163 
delete
 
act
;

166 
FactList
 *
	gprecond
;

169 
	gkid
 = 
parent
->
dup
();

176 
	gkid
->
	gstack
.
addtohead
(
act
);

177 
	gprecond
 = 
act
->
get_prelist
();

178 
	gkid
->
	gstack
.
addtohead
(
precond
);

181 
	gsuccs
->
addtotail
(
kid
);

189 
	gFactList
::
	$FactList
(int 
do_manage
)

190 : 
PtrList
<
Fact
>(
do_manage
)

192 
	}
}

194 
FactList
::
	$FactList
(const char *
str
)

196 
	`process
(
str
);

197 
	}
}

199 
	gFactList
 &FactList::
operator
=(const 
FactList
 &
other
)

201 
PtrList
<
Fact
>::
operator
=(
other
);

202 return(*
	gthis
);

205 
	gFactList
 &FactList::
operator
=(const char *
str
)

207 
process
(
str
);

208 return(*
	gthis
);

211 
StackItemType
 
	gFactList
::
	$getstacktype
() const

213 return(
TypeId
);

214 
	}
}

216 
BasFact
 *
	gFactList
::
	$basdup
() const

218 return(
	`clone
());

219 
	}
}

221 
FactList
 *
	gFactList
::
	$clone
() const

223 
FactList
 *
ret
 = 
new
 FactList;

224 *
ret
 = *
this
;

225 return(
ret
);

226 
	}
}

228 int 
	gFactList
::
operator
==(const 
BasFact
 &
other
) const

230 if (
other
.
getstacktype
() != 
T_FactList
)

232 return(
	gPtrList
<
	gFact
>::
operator
==((
PtrList
<
Fact
> &)
other
));

239 void 
	gFactList
::
	$process
(const char *
str
)

241 char 
foo
[256];

242 const char *
a
 = 
str
;

243 
Fact
 *
f
;

247 if (
a
 = 
	`strchr
(
str
, '&'))

249 
	`strncpy
(
foo
, 
str
, 
a
 - str);

250 *(
foo
 + (
a
 - 
str
)) = '\0';

251 
f
 = 
new
 
	`Fact
(
foo
);

252 
	`addtotail
(
f
);

253 while (
	`isspace
(*++
a
))

255 
str
 = 
a
;

257 else if (
a
 = 
	`strchr
(
str
, '\0'))

259 
f
 = 
new
 
	`Fact
(
str
);

260 
	`addtotail
(
f
);

264 
	}
}

266 void 
	gFactList
::
	$display
() const

268 const 
Fact
 *
f
;

269 
ROPtrListIterator
<
Fact
> 
	`iter
(*
this
);

271 if (
	`is_empty
())

274 
f
 = 
iter
.
	`getfirst
();

275 
f
->
	`display
();

277 while (
f
 = 
iter
.
	`getnext
())

279 
cout
 << " & ";

280 
f
->
	`display
();

282 
	}
}

284 void 
	gFactList
::
process_strips
(
StripsObject
 *
parent
, 
IntrList
<
Node
> *
succs
)

286 
	gPtrListIterator
<
	gFact
> 
iter
(*
this
);

287 
	gPtrList
<
	gFact
> 
nottrue
(
DontManage
);

288 
StripsObject
 *
	gkid
;

309 for (
Fact
 *
	gf
 = 
iter
.
getfirst
(); f; f = iter.
getnext
())

310 if (!
parent
->
world
.
lookup
(
f
))

311 
nottrue
.
addtohead
(
f
->
clone
());

322 if (!
	gnottrue
.
is_empty
())

324 
Fact
 *
	gf
;

326 
	gkid
 = 
parent
->
dup
();

328 
	gsuccs
->
addtotail
(
kid
);

330 
	giter
.
setlist
(
nottrue
);

331 for (
	gf
 = 
iter
.
getfirst
(); f; f = iter.
getnext
())

332 
kid
->
stack
.
addtohead
(
f
);

341 
	gkid
 = 
parent
->
dup
();

343 
	gkid
->
	gstack
.
remove_head
(
DoDel
);

344 
	gsuccs
->
addtotail
(
kid
);

348 void 
	gFactList
::
	$apply_subst
(
Substitution
 &
subst
)

350 
PtrListIterator
<
Fact
> 
	`iter
(*
this
);

352 for (
Fact
 *
f
 = 
iter
.
	`getfirst
(); f; f = iter.
	`getnext
())

353 
f
->
	`apply_subst
(
subst
);

354 
	}
}

356 
	gFrule
::
	$Frule
(char *
rule
, char *
prelist
, char *
dellist
, char *
addlist
)

358 
name
 = 
rule
;

359 
pre
 = 
prelist
;

360 
del
 = 
dellist
;

361 
add
 = 
addlist
;

362 
	}
}

364 void 
	gFrule
::
	$display
() const

366 
name
.
	`display
();

367 
cout
 << "\n\tP: ";

368 
pre
.
	`display
();

369 
cout
 << "\n\tD: ";

370 
del
.
	`display
();

371 
cout
 << "\n\tA: ";

372 
add
.
	`display
();

373 
cout
 << '\n';

374 
	}
}

376 
Action
 *
	gFrule
::
	$create_action
(
Fact
 &
findme
)

378 
PtrListIterator
<
Fact
> 
	`iter
(
add
);

379 
Substitution
 
subst
;

380 
Action
 *
act
 = 0;

397 for (
Fact
 *
f
 = 
iter
.
	`getfirst
(); f; f = iter.
	`getnext
())

398 if (
f
->
	`unify
(
findme
, 
subst
))

411 
Complex
 
copy
 = 
name
;

413 
copy
.
	`update_vars
(
subst
);

414 
act
 = 
new
 
	`Action
(
copy
, 
this
);

418 return(
act
);

419 
	}
}

421 
	gAction
::
	$Action
(
Complex
 &
c
, 
Frule
 *
f
)

423 
action
 = 
c
;

424 
rule
 = 
f
;

425 
	}
}

427 int 
	gAction
::
operator
==(const 
BasFact
 &
other
) const

429 if (
other
.
getstacktype
() != 
T_Action
)

432 
Substitution
 
	gs
;

433 
	gAction
 &
	galter
 = (
Action
 &)
other
;

435 return(
	gaction
.
unify
(
alter
.
action
, 
s
));

438 
StackItemType
 
	gAction
::
	$getstacktype
() const

440 return(
TypeId
);

441 
	}
}

443 void 
	gAction
::
	$display
() const

445 
action
.
	`display
();

446 
	}
}

448 
BasFact
 *
	gAction
::
	$basdup
() const

450 return(
	`clone
());

451 
	}
}

453 
Action
 *
	gAction
::
	$clone
() const

455 return(
new
 
	`Action
(*
this
));

456 
	}
}

458 void 
	gAction
::
process_strips
(
StripsObject
 *
parent
, 
IntrList
<
Node
> *
succs
)

460 
StripsObject
 *
	gkid
;

461 
	gPtrListIterator
<
	gFact
> 
	giter
;

462 
Substitution
 
	gsubst
;

463 
Fact
 *
	gf
;

477 
	gparent
->
	gaction
 = 
action
;

480 
	gkid
 = 
parent
->
dup
();

481 
	gsuccs
->
addtotail
(
kid
);

484 
	gkid
->
	gstack
.
remove_head
(
DoDel
);

497 
	grule
->
	gname
.
unify
(
action
, 
subst
);

499 
	giter
.
setlist
(
rule
->
del
);

505 for (
	gf
 = 
iter
.
getfirst
(); f; f = iter.
getnext
())

511 
Fact
 
c
 = *
f
;

512 
	gc
.
apply_subst
(
subst
);

515 
	gkid
->
	gworld
.
lookup
(&
c
);

516 
	gkid
->
	gworld
.
remove_found
(
DoDel
);

523 
	giter
.
setlist
(
rule
->
add
);

524 for (
	gf
 = 
iter
.
getfirst
(); f; f = iter.
getnext
())

530 
Fact
 *
c
 = 
f
->
clone
();

531 
	gc
->
apply_subst
(
subst
);

537 if (!
	gkid
->
	gworld
.
lookup
(
c
))

538 
	gkid
->
	gworld
.
addtohead
(
c
);

540 
delete
 
	gc
;

545 void 
	gAction
::
	$apply_subst
(
Substitution
 &
s
)

547 
action
.
	`apply_subst
(
s
);

548 
	}
}

553 
FactList
* 
	gAction
::
	$get_addlist
() const

555 return(
	`get_list
(
rule
->
add
));

556 
	}
}

561 
FactList
* 
	gAction
::
	$get_prelist
() const

563 return(
	`get_list
(
rule
->
pre
));

564 
	}
}

569 
FactList
* 
	gAction
::
	$get_dellist
() const

571 return(
	`get_list
(
rule
->
del
));

572 
	}
}

583 
FactList
 *
	gAction
::
	$get_list
(const FactList &
list
) const

585 
ROPtrListIterator
<
Fact
> 
	`iter
(
list
);

586 
Substitution
 
subst
;

587 
FactList
 *
ret
 = 
new
 FactList;

588 const 
Fact
 *
f
;

595 
rule
->
name
.
	`unify
(
action
, 
subst
);

601 for (
f
 = 
iter
.
	`getfirst
(); f; f = iter.
	`getnext
())

603 
Fact
 *
c
;

605 
c
 = 
f
->
	`clone
();

606 
c
->
	`apply_subst
(
subst
);

607 
ret
->
	`addtotail
(
c
);

610 return(
ret
);

611 
	}
}

	@programs/planner/run.cc

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"strips.h
"

29 #ifdef 
_MSC_VER


30 int 
	$no_mem
(
size_t
 
size
)

32 
	`fprintf
(
stderr
, "Out of memory\n");

33 
	`exit
(1);

35 
	}
}

37 void 
	$no_mem
()

39 
	`fprintf
(
stderr
, "Out of memory\n");

40 
	`exit
(1);

41 
	}
}

44 int 
	$main
()

47 #ifdef 
_MSC_VER


48 
	`_set_new_handler
(
no_mem
);

50 
	`set_new_handler
(
no_mem
);

53 
StripsObject
 *
s1
 = 
new
 
	`StripsObject
(

57 
StripsObject
 *
s2
 = 
new
 
	`StripsObject
(

61 
StripsObject
 *
s3
 = 
new
 
	`StripsObject
(

65 
StripsObject
 *
s4
 = 
new
 
	`StripsObject
(

69 
StripsObject
 *
s5
 = 
new
 
	`StripsObject
(

73 
StripsObject
 *
s6
 = 
new
 
	`StripsObject
(

77 
Strips
 
planner
;

79 
cout
 << "** Plan for problem 1: **\n";

80 
planner
.
	`set_startnode
(
s1
);

81 if (
planner
.
	`generate
())

82 
planner
.
	`display
();

84 
cout
 << "\nPress enter to coninue.\n";

85 
cin
.
	`get
();

87 
cout
 << "** Plan for problem 2: **\n";

88 
planner
.
	`set_startnode
(
s2
);

89 if (
planner
.
	`generate
())

90 
planner
.
	`display
();

92 
cout
 << "\nPress enter to coninue.\n";

93 
cin
.
	`get
();

95 
cout
 << "** Plan for problem 3: **\n";

96 
planner
.
	`set_startnode
(
s3
);

97 if (
planner
.
	`generate
())

98 
planner
.
	`display
();

100 
cout
 << "\nPress enter to coninue.\n";

101 
cin
.
	`get
();

103 
cout
 << "** Plan for problem 4: **\n";

104 
planner
.
	`set_startnode
(
s4
);

105 if (
planner
.
	`generate
())

106 
planner
.
	`display
();

108 
cout
 << "\nPress enter to coninue.\n";

109 
cin
.
	`get
();

111 
cout
 << "** Plan for problem 5: **\n";

112 
planner
.
	`set_startnode
(
s5
);

113 if (
planner
.
	`generate
())

114 
planner
.
	`display
();

116 
cout
 << "\nPress enter to coninue.\n";

117 
cin
.
	`get
();

119 
cout
 << "** Plan for problem 6: **\n";

120 
planner
.
	`set_startnode
(
s6
);

121 if (
planner
.
	`generate
())

122 
planner
.
	`display
();

125 
	}
}

	@programs/planner/strips.cc

25 #include 
	~"strips.h
"

27 
	gStripsObject
::
	$StripsObject
()

29 
	}
}

31 
StripsObject
::
	$StripsObject
(const char *
wrld
, const char *
stck
)

33 
FactList
 *
fl
 = 
new
 
	`FactList
(
stck
);

35 
world
 = 
wrld
;

36 
stack
.
	`addtohead
(
fl
);

37 
	}
}

39 int 
	gStripsObject
::
operator
==(const 
Node
 &
other
) const

41 if (!(
world
 == ((
StripsObject
 &)
other
).world))

43 if (!(
	gstack
 == ((
StripsObject
 &)
other
).
stack
))

45 return(
	gaction
 == ((
StripsObject
 &)
other
).
action
);

48 void 
	gStripsObject
::
	$display
() const

50 if (
action
.
	`notempty
())

52 
action
.
	`display
();

53 
cout
 << '\n';

55 
	}
}

60 
StripsObject
 *
	gStripsObject
::
	$dup
() const

62 
StripsObject
 *
ret
 = 
new
 StripsObject;

63 
ret
->
world
 = world;

64 
ret
->
stack
 = stack;

65 return(
ret
);

66 
	}
}

75 
	gIntrList
<
	gNode
> *
	gStripsObject
::
	$expand
(int)

77 
BasFact
 *
object
;

78 
IntrList
<
Node
> *
succs
 = 
new
 IntrList<Node>;

84 
object
 = 
stack
.
	`gethead
();

86 if (!
object
)

93 
StripsObject
 *
kid
 = 
new
 StripsObject;

94 
succs
->
	`addtohead
(
kid
);

102 
object
->
	`process_strips
(
this
, 
succs
);

110 
stack
.
	`clear
(
DoDel
);

111 
world
.
	`clear
(
DoDel
);

113 #ifdef 
DEBUG


114 
IntrListIterator
<
Node
> 
	`iter
(*
succs
);

115 
StripsObject
 *
b
;

117 
cout
 << "\nSuccessors are:\n";

118 for (
b
 = (
StripsObject
 *)
iter
.
	`getfirst
(); b; b = (StripsObject *)iter.
	`getnext
())

120 
PtrListIterator
<
BasFact
> 
	`it
(
b
->
stack
);

121 
BasFact
 *
bf
;

123 
cout
 << "world is:\n";

124 
b
->
world
.
	`display
();

126 
cout
 << "\nstack is:\n";

127 for (
bf
 = 
it
.
	`getfirst
(); bf; bf = it.
	`getnext
())

129 
bf
->
	`display
();

130 
cout
 << '\t';

132 
cout
 << '\n';

135 
cout
 << "Action object is:\n";

136 
action
.
	`display
();

137 
cout
 << '\n';

140 return(
succs
);

141 
	}
}

143 
	gStrips
::
	$Strips
()

144 : 
	$DepthTree
(0)

146 
	}
}

148 
Strips
::
	$Strips
(
StripsObject
 *
start
)

149 : 
	$DepthTree
(0, 
start
)

151 
	}
}

153 int 
	gStrips
::
	$is_goal
(const 
Node
 *
g
)

155 const 
StripsObject
 *
s
 = (StripsObject *)
g
;

161 return(
s
->
stack
.
	`is_empty
());

162 
	}
}

	@programs/planner/strips.h

25 #ifndef 
_STRIPS_H_


26 #define 
	#_STRIPS_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"xlist.h
"

30 #include 
	~"logic.h
"

31 #include 
	~"ainodes.h
"

32 #include 
	~"aitree.h
"

40 enum 
	eStackItemType
 { 
	mT_Fact
, 
	mT_FactList
, 
	mT_Action
 };

43 
class
 
	gStripsObject
;

57 
class
 
	cBasFact


59 
	mpublic
:

60 
virtual
 ~
BasFact
();

61 
virtual
 int 
	moperator
==(const 
BasFact
 &) const = 0;

62 
virtual
 
StackItemType
 
	$getstacktype
() const = 0;

63 
virtual
 
BasFact
 *
	$basdup
() const = 0;

64 
BasFact
 *
	$clone
() const;

65 
virtual
 void 
	$display
() const = 0;

66 
virtual
 void 
	`process_strips
(
StripsObject
 *, 
IntrList
<
Node
> *) = 0;

67 
virtual
 void 
	`apply_subst
(
Substitution
 &) = 0;

74 
class
 
Fact
 : 
public
 
BasFact
, public 
Complex


76 
public
:

77 
	`Fact
(const char *
str
);

78 int 
operator
==(const 
BasFact
 &) const;

79 
StackItemType
 
	`getstacktype
() const;

80 
BasFact
 *
	`basdup
() const;

81 
Fact
 *
	`clone
() const;

82 void 
	`display
() const;

83 void 
	`process_strips
(
StripsObject
 *, 
IntrList
<
Node
> *);

84 void 
	`apply_subst
(
Substitution
 &
s
);

85 
private
:

86 static 
StackItemType
 
TypeId
;

87 
	}
};

94 
class
 
	gFactList
 : 
public
 
BasFact
, public 
	gPtrList
<
	gFact
>

96 
	gpublic
:

97 
FactList
(int 
do_manage
 = 1);

98 
	gFactList
 &
	goperator
=(const 
FactList
 &);

99 
	gFactList
 &
	goperator
=(const char *);

100 int 
	goperator
==(const 
BasFact
 &) const;

101 
StackItemType
 
getstacktype
() const;

102 
FactList
(const char *);

103 
BasFact
 *
basdup
() const;

104 
FactList
 *
clone
() const;

105 void 
display
() const;

106 void 
process_strips
(
StripsObject
 *, 
IntrList
<
Node
> *);

107 void 
apply_subst
(
Substitution
 &);

108 
	gprivate
:

109 void 
process
(const char *);

111 static 
StackItemType
 
	gTypeId
;

114 
class
 
	gFrule
;

122 
class
 
	cAction
 : 
public
 
BasFact


124 
public
:

125 
Action
(
Complex
 &, 
Frule
 *);

126 int 
	moperator
==(const 
BasFact
 &
other
) const;

127 
StackItemType
 
	$getstacktype
() const;

128 void 
	$display
() const;

129 void 
	`process_strips
(
StripsObject
 *, 
IntrList
<
Node
> *);

130 void 
	`apply_subst
(
Substitution
 &
s
);

131 
BasFact
 *
	$basdup
() const;

132 
Action
 *
	$clone
() const;

133 
FactList
* 
	$get_addlist
() const;

134 
FactList
* 
	$get_prelist
() const;

135 
FactList
* 
	$get_dellist
() const;

136 
private
:

137 
FactList
 *
	$get_list
(const FactList &) const;

138 static 
StackItemType
 
TypeId
;

140 
Complex
 
action
;

141 
Frule
 *
rule
;

153 
class
 
	cFrule


155 
public
:

156 
friend
 
Action
;

157 
	`Frule
(char *, char *, char *, char *);

158 void 
	$display
() const;

159 
Action
 *
	`create_action
(
Fact
 &);

160 
private
:

161 
Complex
 
name
;

162 
FactList
 
pre
,

163 
del
,

164 
add
;

170 #define 
	#MAXFRULE
 4

	)
171 extern 
Frule
 
frulearr
[
MAXFRULE
];

181 
class
 
	cStripsObject
 : 
public
 
Node


183 
public
:

184 
	`StripsObject
();

185 ~
	$StripsObject
() { }

186 
	`StripsObject
(const char *, const char *);

187 int 
operator
==(const 
Node
 &) const;

188 void 
	$display
() const;

189 
IntrList
<
Node
> *
	`expand
(int);

190 
StripsObject
 *
	$dup
() const;

192 
FactList
 
world
;

193 
PtrList
<
BasFact
> 
stack
;

194 
Complex
 
action
;

195 
	}
};

201 
class
 
	cStrips
 : 
public
 
DepthTree


203 
public
:

204 
Strips
();

205 
Strips
(
StripsObject
 *);

206 int 
is_goal
(const 
Node
 *);

	@programs/prolog/pclause.cc

25 #include 
	~"pclause.h
"

33 int 
	gPrologBase
::
operator
==(const 
PrologBase
 &) const

38 
	gPrologFact
::
	$PrologFact
(const 
PrologFact
 &
other
)

39 : 
	$Complex
(
other
)

41 
	}
}

43 
PrologFact
::
	$PrologFact
(const char *
str
)

44 : 
	$Complex
(
str
)

46 
	}
}

54 int 
PrologFact
::
match
(const 
Complex
 &
matchme
, 
PtrList
<Complex> &
outgoals
,

55 
Substitution
 &
subst
)

57 
Complex
 
	gvariant
 = *
this
;

58 
	gvariant
.
update_vars
();

60 if (
	gmatchme
.
unify
(
variant
, 
subst
))

65 
PrologBase
 *
	gPrologFact
::
	$clone
() const

67 return(
new
 
	`PrologFact
(*
this
));

68 
	}
}

70 void 
	gPrologFact
::
	$display
() const

72 
cout
 << *(
Complex
 *)
this
 << ".";

73 
	}
}

75 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gPrologFact
 &
	gf
)

77 return(
	gstream
 << 
	gf
 << ".");

80 
	gPrologRule
::
	$PrologRule
(const 
PrologRule
 &
other
)

82 
head
 = 
other
.head;

83 
body
 = 
other
.body;

84 
	}
}

86 
PrologBase
 *
	gPrologRule
::
	$clone
() const

88 return(
new
 
	`PrologRule
(*
this
));

89 
	}
}

101 
	gPrologRule
::
	$PrologRule
(const char *
str
)

103 char 
buf
[256];

104 char const *
p
 = 
str
;

106 
p
 = 
	`strstr
(
str
, ":-");

107 
	`strncpy
(
buf
, 
str
, 
p
 - str);

108 *(
buf
 + (
p
 - 
str
)) = '\0';

110 
head
 = 
buf
;

112 ++
p
;

113 while (
	`isspace
(*++
p
))

115 
str
 = 
p
;

117 while ((
p
 = 
	`strchr
(
str
, '&')) || (p = strchr(str, '.')))

119 
Complex
 *
cplex
;

121 
	`strncpy
(
buf
, 
str
, 
p
 - str);

122 *(
buf
 + (
p
 - 
str
)) = '\0';

123 
cplex
 = 
new
 
	`Complex
(
buf
);

124 
body
.
	`addtotail
(
cplex
);

125 if (*
p
 != '.')

126 while (
	`isspace
(*++
p
))

130 
str
 = 
p
;

132 
	}
}

142 int 
	gPrologRule
::
match
(const 
Complex
 &
matchme
, 
PtrList
<Complex> &
outgoals
,

143 
Substitution
 &
subst
)

145 
Substitution
 
	gs
;

151 
Complex
 
	gvariant
 = 
head
;

152 
	gvariant
.
update_vars
(
s
);

154 if (
	gmatchme
.
unify
(
variant
, 
subst
))

156 
Complex
 *
	gc
;

157 
	gPtrListIterator
<
	gComplex
> 
iter
(
outgoals
);

164 
	goutgoals
 = 
body
;

165 for (
	gc
 = 
iter
.
getfirst
(); c; c = iter.
getnext
())

167 
c
->
update_vars
(
s
);

168 
	gc
->
apply_subst
(
subst
);

176 void 
	gPrologRule
::
	$display
() const

178 
cout
 << *
this
;

179 
	}
}

181 
	gostream
 &
	goperator
<<(ostream &
	gstream
, const 
	gPrologRule
 &
	grule
)

183 
	gROPtrListIterator
<
	gComplex
> 
iter
(
rule
.
body
);

184 const 
Complex
 *
	gc
;

186 
	gstream
 << 
	grule
.
	ghead
 << ":-\n";

188 
	gstream
 << "\t" << *
	giter
.
getfirst
();

189 while ((
	gc
 = 
iter
.
getnext
()))

190 
cout
 << ",\n\t" << *
c
;

192 
	gcout
 << ".";

194 return(
	gstream
);

	@programs/prolog/pclause.h

25 #ifndef 
_PCLAUSE_H_


26 #define 
	#_PCLAUSE_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~<iostream.h
>

30 #include 
	~"logic.h
"

31 #include 
	~"xlist.h
"

42 
class
 
	cPrologBase


44 
	mpublic
:

45 
virtual
 ~
	$PrologBase
() { };

46 int 
operator
==(const 
PrologBase
 &) const;

47 
virtual
 
PrologBase
 *
	$clone
() const = 0;

48 
virtual
 void 
	$display
() const = 0;

49 
virtual
 int 
	`match
(const 
Complex
 &
matchme
, 
PtrList
<Complex> &
newgoals
,

50 
Substitution
 &
subst
) = 0;

51 
	}
};

57 
class
 
	gPrologFact
 : 
public
 
PrologBase
, public 
	gComplex


59 
	gpublic
:

60 
PrologFact
(const char *);

61 
PrologFact
(const PrologFact &);

62 
PrologBase
 *
clone
() const;

63 void 
display
() const;

64 int 
match
(const 
Complex
 &, 
PtrList
<Complex> &, 
Substitution
 &);

67 
	gostream
 &
	goperator
<<(ostream &, const 
	gPrologFact
 &);

74 
class
 
	cPrologRule
 : 
public
 
PrologBase


76 
friend
 
ostream
 &
operator
<<(ostream &, const 
	mPrologRule
 &);

77 
	mpublic
:

78 
PrologRule
(const char *);

79 
PrologRule
(const PrologRule &);

80 
PrologBase
 *
	$clone
() const;

81 void 
	$display
() const;

82 int 
	`match
(const 
Complex
 &, 
PtrList
<Complex> &, 
Substitution
 &);

83 
private
:

84 
Complex
 
head
;

85 
PtrList
<
Complex
> 
body
;

	@programs/prolog/prolog.cc

25 #include 
	~"prolog.h
"

27 
PrologTable
 *
	gProlog
::
table
;

29 
	gPrologNode
::
	$PrologNode
()

31 
lastdone
 = -1;

32 
	}
}

34 
	gPrologNode
::~
	$PrologNode
()

36 
delete
 
goalstack
;

37 
	}
}

43 
	gPrologNode
::
PrologNode
(
PtrList
<
Complex
> *
solveme
)

45 
goalstack
 = 
solveme
;

46 
	glastdone
 = -1;

54 
	gPtrListIterator
<
	gComplex
> 
iter
(*
goalstack
);

55 for (
Complex
 *
	gc
 = 
iter
.
getfirst
(); c; c = iter.
getnext
())

56 
c
->
update_vars
(
subst
);

59 int 
	gPrologNode
::
operator
==(const 
BackNode
 &
other
) const

61 const 
PrologNode
 &
pother
 = (PrologNode &)
other
;

62 if (!(*
	ggoalstack
 == *
pother
.
goalstack
))

64 if (!(
	gsubst
 == 
pother
.
subst
))

66 return(
	glastdone
 == 
pother
.
lastdone
);

69 void 
	gPrologNode
::
	$display
() const

71 
cout
 << 
subst
 << "\n";

72 
	}
}

83 
BackNode
 *
	gPrologNode
::
	$expand_one
(int)

85 
Substitution
 
subst_used
;

86 
PtrList
<
Complex
> *
newgoals
;

87 
PrologNode
 *
succ
;

88 
Complex
 *
first
;

90 
newgoals
 = 
new
 
PtrList
<
Complex
>;

93 
first
 = 
goalstack
->
	`gethead
();

99 
lastdone
 = 
Prolog
::
table
->
	`findmatch
(lastdone + 1, *
first
, *
newgoals
,

100 
subst_used
);

103 if (
lastdone
 < 0)

105 
succ
 = 
NULL
;

106 
delete
 
newgoals
;

110 
PtrListIterator
<
Complex
> 
	`iter
(*
goalstack
);

111 
Complex
 *
c
, *
d
;

114 
succ
 = 
new
 
PrologNode
;

120 
succ
->
goalstack
 = 
newgoals
;

129 for (
iter
.
	`getfirst
(), 
c
 = iter.
	`getnext
(); c; c = iter.getnext())

131 
d
 = 
c
->
	`clone
();

132 
d
->
	`update_vars
(
subst_used
);

133 
succ
->
goalstack
->
	`addtotail
(
d
);

140 
succ
->
subst
 = subst;

141 
succ
->
subst
.
	`update
(
subst_used
);

144 return(
succ
);

145 
	}
}

147 
	gProlog
::
	$Prolog
(
PrologTable
 &
pt
)

148 : 
	$BackTrack
(0)

150 
table
 = &
pt
;

151 
	}
}

153 int 
	gProlog
::
	$is_goal
(const 
BackNode
 *
node
)

155 const 
PrologNode
 *
n
 = (PrologNode *)
node
;

158 return(
n
->
goalstack
->
	`getcount
() == 0);

159 
	}
}

165 void 
	gProlog
::
	$set_query
(const char *
str
)

167 
PtrList
<
Complex
> *
goal
;

168 
PrologNode
 *
start
;

171 
goal
 = 
new
 
PtrList
<
Complex
>;

172 
goal
->
	`addtohead
(
new
 
	`Complex
(
str
));

173 
start
 = 
new
 
	`PrologNode
(
goal
);

176 
	`clear
();

177 
	`set_startnode
(
start
);

178 
	}
}

185 int 
	gProlog
::
	$get_result
(
Substitution
 &
answer
)

187 if (
	`generate
())

189 const 
PrologNode
 *
sol
 = (PrologNode *)
	`get_goal
();

190 
answer
 = 
sol
->
subst
;

194 
	}
}

200 int 
	gProlog
::
	$get_next_result
(
Substitution
 &
answer
)

202 if (
	`generate_next
())

204 const 
PrologNode
 *
sol
 = (PrologNode *)
	`get_goal
();

205 
answer
 = 
sol
->
subst
;

209 
	}
}

	@programs/prolog/prolog.h

25 #ifndef 
_PROLOG_H_


26 #define 
	#_PROLOG_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"btrack.h
"

30 #include 
	~"pclause.h
"

31 #include 
	~"ptable.h
"

33 
class
 
	gProlog
;

40 
class
 
	cPrologNode
 : 
public
 
BackNode


42 
friend
 
Prolog
;

43 
	mpublic
:

44 
PrologNode
();

45 
PrologNode
(
PtrList
<
Complex
> *);

46 ~
PrologNode
();

48 int 
	moperator
==(const 
BackNode
 &) const;

49 void 
	$display
() const;

50 
BackNode
 *
	`expand_one
(int);

51 
private
:

52 
PtrList
<
Complex
> *
goalstack
;

53 
Substitution
 
subst
;

54 int 
lastdone
;

63 
class
 
	cProlog
 : 
public
 
BackTrack


65 
friend
 
PrologNode
;

66 
public
:

67 
	`Prolog
(
PrologTable
 &);

68 int 
	`is_goal
(const 
BackNode
 *);

69 void 
	`set_query
(const char *);

70 int 
	`get_result
(
Substitution
 &);

71 int 
	`get_next_result
(
Substitution
 &);

72 
private
:

73 static 
PrologTable
 *
table
;

	@programs/prolog/ptable.cc

25 #include 
	~"ptable.h
"

27 
	gPrologTable
::
	$PrologTable
()

29 
index
 = 0;

30 
	}
}

32 
	gPrologTable
::
	$PrologTable
(const char **
arrstr
)

34 
index
 = 0;

35 
	`addclauses
(
arrstr
);

36 
	}
}

38 const 
PrologBase
 *
	gPrologTable
::
operator
[](int 
i
) const

40 return(
table
[
i
]);

43 
	gPrologBase
 *&
	gPrologTable
::
operator
[](int 
i
)

45 return(
table
[
i
]);

53 void 
	gPrologTable
::
	$addclause
(const char *
str
)

55 
PrologBase
 *
add
;

57 if (
	`strstr
(
str
, ":-"))

58 
add
 = 
new
 
	`PrologRule
(
str
);

60 
add
 = 
new
 
	`PrologFact
(
str
);

61 if (
index
 == 
table
.
	`getsize
())

62 
table
.
	`grow
(
GROWSIZE
);

63 
table
[
index
] = 
add
;

64 
index
++;

65 
	}
}

71 void 
	gPrologTable
::
	$addclauses
(const char **
str
)

73 while (*
str
)

74 
	`addclause
(*
str
++);

75 
	}
}

77 void 
	gPrologTable
::
	$listclauses
() const

79 for (int 
i
 = 0; i < 
index
; i++)

81 
table
[
i
]->
	`display
();

82 
cout
 << '\n';

84 
	}
}

93 int 
	gPrologTable
::
findmatch
(int 
startclause
, const 
Complex
 &
findme
,

94 
PtrList
<
Complex
> &
newgoals
, 
Substitution
 &
subst
)

96 for (int 
	gi
 = 
startclause
; i < 
	gindex
; i++)

97 if (
	gtable
[
i
]->
match
(
findme
, 
newgoals
, 
subst
))

98 return(
	gi
);

	@programs/prolog/ptable.h

25 #include 
	~"xarray.h
"

26 #include 
	~"pclause.h
"

28 #define 
	#GROWSIZE
 1000

	)
42 
class
 
	cPrologTable


44 
	mpublic
:

45 
PrologTable
();

46 
PrologTable
(const char **);

47 const 
PrologBase
 *
	moperator
[](int) const;

48 
	mPrologBase
 *&
	moperator
[](int);

49 void 
addclause
(const char *);

50 void 
addclauses
(const char **);

51 void 
	$listclauses
() const;

52 int 
	`findmatch
(int 
startclause
, const 
Complex
 &
findme
,

53 
PtrList
<
Complex
> &
newgoals
, 
Substitution
 &
subst
);

54 
private
:

55 
PtrArray
<
PrologBase
> 
table
;

56 int 
index
;

	@programs/prolog/sample1.cc

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"prolog.h
"

29 const char *
	gclauses
[] =

35 
NULL


38 #ifdef 
_MSC_VER


39 int 
	$no_mem
(
size_t
 
size
)

41 
	`fprintf
(
stderr
, "Out of memory\n");

42 
	`exit
(1);

44 
	}
}

46 void 
	$no_mem
()

48 
	`fprintf
(
stderr
, "Out of memory\n");

49 
	`exit
(1);

50 
	}
}

54 int 
	$main
()

57 #ifdef 
_MSC_VER


58 
	`_set_new_handler
(
no_mem
);

60 
	`set_new_handler
(
no_mem
);

63 
Substitution
 
subst
;

66 
PrologTable
 
table
;

69 
Prolog
 
	`prolog
(
table
);

72 
table
.
	`addclauses
(
clauses
);

73 
table
.
	`listclauses
();

76 
prolog
.
	`set_query
("parent(X, Y)");

77 
prolog
.
	`get_result
(
subst
);

78 
cout
 << 
subst
 << "\n";

81 for (int 
i
 = 1; i < 5; i++)

84 
subst
.
	`clear
();

86 
prolog
.
	`get_next_result
(
subst
);

87 
cout
 << 
subst
 << "\n";

90 
	}
}

	@programs/prolog/sample2.cc

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"prolog.h
"

29 const char *
	gclauses
[] =

51 
NULL


54 #ifdef 
_MSC_VER


55 int 
	$no_mem
(
size_t
 
size
)

57 
	`fprintf
(
stderr
, "Out of memory\n");

58 
	`exit
(1);

60 
	}
}

62 void 
	$no_mem
()

64 
	`fprintf
(
stderr
, "Out of memory\n");

65 
	`exit
(1);

66 
	}
}

69 int 
	$main
()

72 #ifdef 
_MSC_VER


73 
	`_set_new_handler
(
no_mem
);

75 
	`set_new_handler
(
no_mem
);

78 
Substitution
 
subst
;

81 
PrologTable
 
table
;

84 
Prolog
 
	`prolog
(
table
);

87 
table
.
	`addclauses
(
clauses
);

90 
prolog
.
	`set_query
("isa(X, Y)");

91 
prolog
.
	`get_result
(
subst
);

92 
cout
 << 
subst
 << "\n";

95 
subst
.
	`clear
();

96 while (
prolog
.
	`get_next_result
(
subst
))

98 
cout
 << 
subst
 << "\n";

99 
subst
.
	`clear
();

102 
	}
}

	@programs/prover/clause.cc

25 #include 
	~<stdarg.h
>

26 #include 
	~"clause.h
"

28 
	gClause
::
	$Clause
()

30 
	}
}

32 
Clause
::
	$Clause
(const char *
string
)

34 
	`parse_string
(
string
);

35 
	}
}

37 int 
	gClause
::
operator
==(const 
Clause
 &
other
) const

39 return(
terms
 == 
other
.terms);

42 
Clause
 *
	gClause
::
	$clone
() const

44 return(
new
 
	`Clause
(*
this
));

45 
	}
}

47 
	gClause
 &Clause::
operator
=(const 
Clause
 &
other
)

49 if (
this
 != &
other
)

50 
terms
 = 
other
.terms;

51 return(*
	gthis
);

54 
	gClause
 &Clause::
operator
=(const char *
string
)

56 
terms
.
clear
(
DoDel
);

57 
parse_string
(
string
);

58 return(*
	gthis
);

61 void 
	gClause
::
	$display
() const

63 
ROIntrListIterator
<
Literal
> 
	`iter
(
terms
);

64 const 
Literal
 *
lit
;

66 
cout
 << '[';

67 if ((
lit
 = 
iter
.
	`getfirst
()))

68 
lit
->
	`display
();

69 while ((
lit
 = 
iter
.
	`getnext
()))

71 
cout
 << ", ";

72 
lit
->
	`display
();

74 
cout
 << ']';

75 
	}
}

80 int 
	gClause
::
	$is_tautology
()

82 
IntrListIterator
<
Literal
> 
	`iter
(
terms
);

83 
Literal
 *
plit
;

91 for (
plit
 = 
iter
.
	`getfirst
(); plit; plit = iter.
	`getnext
())

94 if (!
plit
->
	`is_framed
())

101 
Literal
 
lit
 = *
plit
;

102 
lit
.
	`negate
();

103 if (
terms
.
	`lookup
(&
lit
))

108 
	}
}

110 int 
	gClause
::
	$is_empty
() const

112 return(
terms
.
	`is_empty
());

113 
	}
}

124 void 
	gClause
::
	$merge_except
(int 
pos
, 
Clause
 &
other
)

126 
IntrListIterator
<
Literal
> 
	`iter
(
other
.
terms
);

127 
Literal
 *
lit
;

128 int 
i
;

130 for (
i
 = 0, 
lit
 = 
iter
.
	`getfirst
(); lit; lit = iter.
	`getnext
())

132 if (
pos
 != 
i
++)

137 if (!
terms
.
	`lookup
(
lit
))

138 
terms
.
	`addtotail
(
lit
->
	`clone
());

140 
	}
}

148 void 
	gClause
::
	$frame_last
()

150 
Literal
 
lit
 = *
terms
.
	`gettail
();

151 
lit
.
	`make_framed
();

153 if (!
terms
.
	`lookup
(&
lit
))

154 
terms
.
	`gettail
()->
	`make_framed
();

156 
terms
.
	`remove_tail
(
DoDel
);

157 
	}
}

164 void 
	gClause
::
	$delete_framed
()

166 
Literal
 *
lit
;

167 while ((
lit
 = 
terms
.
	`gettail
()) && lit->
	`is_framed
())

168 
terms
.
	`remove_tail
(
DoDel
);

169 
	}
}

179 void 
	gClause
::
	$reduce_order
()

183 if (
terms
.
	`is_empty
())

193 
Literal
 
lit
 = *
terms
.
	`gettail
();

194 
lit
.
	`negate
();

195 
lit
.
	`make_framed
();

197 if (
terms
.
	`lookup
(&
lit
))

198 
terms
.
	`remove_tail
(
DoDel
);

203 
	`delete_framed
();

205 
	}
}

213 
Clause
* 
	gClause
::
	$resolve
(Clause &
other
)

215 
Clause
 *
result
 = 
NULL
;

216 int 
pos
;

222 
Literal
 
neglast
 = *
terms
.
	`gettail
();

223 
neglast
.
	`negate
();

229 if ((
pos
 = 
other
.
terms
.
	`find
(&
neglast
)) >= 0)

238 
result
 = 
	`clone
();

239 
result
->
	`frame_last
();

240 
result
->
	`merge_except
(
pos
, 
other
);

241 
result
->
	`delete_framed
();

242 
result
->
	`reduce_order
();

244 return(
result
);

245 
	}
}

251 void 
	gClause
::
	$parse_string
(const char *
string
)

253 char *
p
, *
end
, *
buf
;

255 if (!(
buf
 = 
	`strdup
(
string
)))

257 
	`puts
("Clause::Clause() out of memory");

258 
	`exit
(0);

260 
p
 = 
buf
 + 1;

261 while (*
p
)

263 int 
neg
;

264 
Literal
 *
lit
;

266 
neg
 = 0;

267 while (*
p
 == ' ')

268 
p
++;

269 if (*
p
 == '~')

271 
neg
 = 1;

272 
p
++;

274 if (
end
 = 
	`strchr
(
p
, ','))

276 *
end
 = '\0';

277 
end
++;

281 
end
 = 
	`strchr
(
p
, ']');

282 *
end
 = '\0';

284 
lit
 = 
new
 
	`Literal
(
neg
, 
p
);

285 if (!
terms
.
	`lookup
(
lit
))

286 
terms
.
	`addtotail
(
lit
);

288 
delete
 
lit
;

289 
p
 = 
end
;

291 
	`delete
(
buf
);

292 
	}
}

	@programs/prover/clause.h

25 #ifndef 
_Clause_H_


26 #define 
	#_Clause_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"literal.h
"

30 #include 
	~"xlist.h
"

40 
class
 
	cClause


42 
	mpublic
:

43 
Clause
();

44 
Clause
(const char *);

45 
Clause
 *
	$clone
() const;

46 
Clause
 &
operator
=(const Clause &
other
);

47 
Clause
 &
operator
=(const char *);

48 int 
operator
==(const 
Clause
 &) const;

49 
Clause
 *
	`resolve
(Clause &);

50 int 
	$is_empty
() const;

51 void 
	$display
() const;

52 int 
	`is_tautology
();

53 
private
:

54 void 
	`merge_except
(int, 
Clause
 &);

55 void 
	`frame_last
();

56 void 
	`delete_framed
();

57 void 
	`reduce_order
();

58 void 
	`parse_string
(const char *);

60 
IntrList
<
Literal
> 
terms
;

	@programs/prover/ctable.cc

25 #include 
	~"ctable.h
"

27 
	gClauseTable
::
	$ClauseTable
()

29 
index
 = 0;

30 
	}
}

32 
	gClauseTable
::
	$ClauseTable
(const char **
arrstr
)

34 
index
 = 0;

35 
	`addclauses
(
arrstr
);

36 
	}
}

38 const 
Clause
 *
	gClauseTable
::
operator
[](int 
i
) const

40 return(
table
[
i
]);

43 
	gClause
 *&
	gClauseTable
::
operator
[](int 
i
)

45 return(
table
[
i
]);

48 
	gClause
 *&
	gClauseTable
::
	$getclause
(int 
i
)

50 return(
table
[
i
]);

51 
	}
}

53 void 
	gClauseTable
::
	$addclause
(const char *
str
)

55 
Clause
 *
add
;

57 
add
 = 
new
 
	`Clause
(
str
);

58 if (
index
 == 
table
.
	`getsize
())

59 
table
.
	`grow
(
GROWSIZE
);

60 
table
[
index
] = 
add
;

61 
index
++;

62 
	}
}

64 void 
	gClauseTable
::
	$addclauses
(const char **
str
)

66 while (*
str
)

67 
	`addclause
(*
str
++);

68 
	}
}

70 int 
	gClauseTable
::
	$getsize
() const

72 return(
index
);

73 
	}
}

	@programs/prover/ctable.h

25 #ifndef 
_CTABLE_H_


26 #define 
	#_CTABLE_H_


	)
28 #include 
	~"xarray.h
"

29 #include 
	~"clause.h
"

31 #define 
	#GROWSIZE
 1000

	)
38 
class
 
	cClauseTable


40 
	mpublic
:

41 
ClauseTable
();

42 
ClauseTable
(const char **);

43 const 
Clause
 *
	moperator
[](int) const;

44 
	mClause
 *&
	moperator
[](int);

45 
	mClause
 *&
getclause
(int);

46 void 
addclause
(const char *);

47 void 
addclauses
(const char **);

48 int 
	$getsize
() const;

49 
private
:

50 
PtrArray
<
Clause
> 
table
;

51 int 
index
;

	@programs/prover/literal.cc

25 #include 
	~"literal.h
"

31 
	gLiteral
::
	$Literal
(int 
negval
, const char *
txt
)

33 
negated
 = 
negval
;

34 
prop
 = 
txt
;

35 
framed
 = 0;

36 
	}
}

38 int 
	gLiteral
::
operator
==(const 
Literal
 &
other
) const

40 if (
negated
 != 
other
.negated)

42 if (
	gframed
 != 
other
.
framed
)

44 return(
	gprop
 == 
other
.
prop
);

47 
Literal
 *
	gLiteral
::
	$clone
() const

49 return(
new
 
	`Literal
(*
this
));

50 
	}
}

52 void 
	gLiteral
::
	$display
() const

54 
cout
 << (
framed
 ? "|" : "") << (
negated
 ? "~" : "") << 
prop
 << (framed ? "|" : "");

55 
	}
}

57 void 
	gLiteral
::
	$negate
()

59 
negated
 = (negated == 0) ? 1 : 0;

60 
	}
}

62 void 
	gLiteral
::
	$make_framed
()

64 
framed
 = 1;

65 
	}
}

67 int 
	gLiteral
::
	$is_framed
() const

69 return(
framed
);

70 
	}
}

	@programs/prover/literal.h

25 #ifndef 
_Literal_H_


26 #define 
	#_Literal_H_


	)
28 #include 
	~<stdio.h
>

29 #include 
	~"xstring.h
"

30 #include 
	~"xlist.h
"

41 
class
 
	cLiteral
 : 
public
 
ListNode


43 
public
:

44 
Literal
(int, const char *);

45 
	moperator
==(const 
Literal
 &) const;

46 
Literal
 *
	$clone
() const;

47 void 
	$display
() const;

48 void 
	`negate
();

49 void 
	`make_framed
();

50 int 
	$is_framed
() const;

51 
private
:

52 int 
negated
,

53 
framed
;

54 
String
 
prop
;

	@programs/prover/resnode.cc

25 #include 
	~"resnode.h
"

27 
ClauseTable
 *
	gResGraph
::
table
;

29 
	gResNode
::
	$ResNode
(
Clause
 *
resolv
, Clause *
sid
)

31 
resolvent
 = 
resolv
;

32 
side
 = 
sid
;

33 
	}
}

35 
	gResNode
::~
	$ResNode
()

37 
	`delete
(
resolvent
);

38 
	}
}

49 int 
	gResNode
::
operator
==(const 
Node
 &
other
) const

51 const 
ResNode
 &
resother
 = (ResNode &)
other
;

52 return(*
	gresolvent
 == *(
resother
.
resolvent
));

55 void 
	gResNode
::
	$display
() const

57 if (
side
)

59 
side
->
	`display
();

60 
cout
 << '\n';

62 
resolvent
->
	`display
();

63 
cout
 << '\t';

64 
	}
}

72 
	gIntrList
<
	gNode
> *
	gResNode
::
	$expand
(int)

74 
Clause


75 *
newclause
;

76 
ResNode


77 *
tmp
;

78 
IntrList
<
Node
>

79 *
ret
 = 
new
 
IntrList
<
Node
>;

81 int 
max
 = 
ResGraph
::
table
->
	`getsize
();

82 for (int 
i
 = 0; i < 
max
; i++)

92 
newclause
 = 
resolvent
->
	`resolve
(*
ResGraph
::
table
->
	`getclause
(
i
));

93 if (
newclause
)

95 if (!
newclause
->
	`is_tautology
())

97 
tmp
 = 
new
 
	`ResNode
(
newclause
, 
ResGraph
::
table
->
	`getclause
(
i
));

98 
ret
->
	`addtotail
(
tmp
);

101 
	`delete
(
newclause
);

104 return(
ret
);

105 
	}
}

107 
	gResGraph
::
	$ResGraph
(
ResNode
 *
start
, 
ClauseTable
 &
ct
)

108 :
	$DepthGraph
(0, 
start
)

110 
table
 = &
ct
;

111 
	}
}

113 void 
	gResGraph
::
	$settable
(
ClauseTable
 &
ct
)

115 
table
 = &
ct
;

116 
	}
}

122 int 
	gResGraph
::
	$is_goal
(const 
Node
 *
n
)

124 
ResNode
 *
node
 = (ResNode *)
n
;

125 return(
node
->
resolvent
->
	`is_empty
());

126 
	}
}

	@programs/prover/resnode.h

25 #include 
	~<stdio.h
>

26 #include 
	~"clause.h
"

27 #include 
	~"ctable.h
"

28 #include 
	~"literal.h
"

29 #include 
	~"aigraph.h
"

31 
class
 
	gResGraph
;

40 
class
 
	cResNode
 : 
public
 
Node


42 
friend
 
ResGraph
;

43 
	mpublic
:

44 
ResNode
(
Clause
 *, Clause *);

45 ~
ResNode
();

47 int 
	moperator
==(const 
Node
 &) const;

48 void 
	$display
() const;

49 
IntrList
<
Node
> *
	`expand
(int);

50 
private
:

51 
Clause
 *
resolvent
,

52 *
side
;

61 
class
 
	cResGraph
 : 
public
 
DepthGraph


63 
friend
 
ResNode
;

64 
public
:

65 
	`ResGraph
(
ResNode
 *, 
ClauseTable
 &);

66 void 
	`settable
(
ClauseTable
 &);

67 int 
	`is_goal
(const 
Node
 *);

68 
private
:

69 static 
ClauseTable
 *
table
;

	@programs/prover/run.cc

25 #include 
	~<stdio.h
>

26 #include 
	~<new.h
>

27 #include 
	~"resnode.h
"

29 #ifdef 
_MSC_VER


30 int 
	$no_mem
(
size_t
 
size
)

32 
	`fprintf
(
stderr
, "Out of memory\n");

33 
	`exit
(1);

35 
	}
}

37 void 
	$no_mem
()

39 
	`fprintf
(
stderr
, "Out of memory\n");

40 
	`exit
(1);

41 
	}
}

45 *
	gclauses
[] = {

54 
NULL


57 int 
	$main
()

60 #ifdef 
_MSC_VER


61 
	`_set_new_handler
(
no_mem
);

63 
	`set_new_handler
(
no_mem
);

66 
ClauseTable


67 
table
;

68 
table
.
	`addclauses
(
clauses
);

69 
Clause


70 
topclause
 = 
clauses
[0];

71 
ResGraph


72 
	`prover
(
new
 
	`ResNode
(
topclause
.
	`clone
(), 
NULL
), 
table
);

74 if (
prover
.
	`generate
())

75 
prover
.
	`display
();

77 
	`puts
("no solution found");

78 
	`putchar
('\n');

81 
	}
}

	@programs/route/route.cc

25 #include 
	~"route.h
"

30 
Route


31 
	gtable
[] = {

83 
	gPath
::
	$Path
(
City
 *
start
, City *
target
)

84 :
	$UnicostGraph
(0, 
start
, 
target
)

86 
	}
}

89 
	gCity
::
	$City
(const char *
p
, int 
d
)

91 
city
 = 
p
;

92 
dist
 = 
d
;

93 
	}
}

100 void 
	gCity
::
	$display
() const

102 
	`printf
("%15s %5d\n", 
city
, 
	`get_g
());

103 
	}
}

106 int 
	gCity
::
operator
==(const 
Node
 &
other
) const

108 const 
City
 &
cother
 = (City &)
other
;

109 return(!
strcmp
(
city
, 
cother
.city));

113 int 
	gCity
::
	$getdist
() const

115 return(
dist
);

116 
	}
}

129 
	gIntrList
<
	gNode
> *
	gCity
::
	$expand
(int )

132 
i
;

133 
City


134 *
tmp
;

135 
IntrList
<
Node
>

136 *
ret
 = 
new
 
IntrList
<
Node
>;

138 for (
i
 = 0; 
table
[i].
from
 != 0; i++)

140 if (!
	`strcmp
(
table
[
i
].
from
, 
city
))

141 
tmp
 = 
new
 
	`City
(
table
[
i
].
to
, table[i].
distance
);

142 else if (!
	`strcmp
(
table
[
i
].
to
, 
city
))

143 
tmp
 = 
new
 
	`City
(
table
[
i
].
from
, table[i].
distance
);

147 
ret
->
	`addtohead
(
tmp
);

149 return(
ret
);

150 
	}
}

160 int 
	gPath
::
	$compute_g
(const 
Node
 *
node
)

162 const 
City
 *
cnode
 = (City *)
node
;

163 return(
cnode
->
	`getdist
());

164 
	}
}

167 #ifdef 
_MSC_VER


168 int 
	$no_mem
(
size_t
 
size
)

170 
	`fprintf
(
stderr
, "Out of memory\n");

171 
	`exit
(1);

173 
	}
}

175 void 
	$no_mem
()

177 
	`fprintf
(
stderr
, "Out of memory\n");

178 
	`exit
(1);

179 
	}
}

183 int 
	$main
()

186 #ifdef 
_MSC_VER


187 
	`_set_new_handler
(
no_mem
);

189 
	`set_new_handler
(
no_mem
);

192 
Path


193 
	`path
(
new
 
	`City
("copenhagen", 0), new City("rome", 0));

195 if (
path
.
	`generate
())

196 
path
.
	`display
();

198 
	}
}

	@programs/route/route.h

25 #include 
	~<stdio.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

28 #include 
	~<new.h
>

29 #include 
	~"aigraph.h
"

46 typedef struct 
	sRoute


49 *
	mfrom
,

50 *
	mto
;

52 
	mdistance
;

53 } 
	tRoute
;

62 
class
 
	cCity
 : 
public
 
UniNode


64 
public
:

65 
City
(const char *, int);

66 int 
	$getdist
() const;

72 int 
operator
==(const 
Node
 &) const;

73 void 
	$display
() const;

74 
IntrList
<
Node
> *
	`expand
(int);

75 
private
:

77 *
city
;

79 
dist
;

88 
class
 
	cPath
 : 
public
 
UnicostGraph


90 
public
:

91 
	`Path
(
City
 *
start
, City *
target
);

92 int 
	`compute_g
(const 
Node
 *);

	@programs/tictac/tictac.cc

30 #include 
	~"tictac.h
"

32 
	gTicMove
::
	$TicMove
()

34 
square
 = -1;

35 
	}
}

37 
	gTicMove
::
	$TicMove
(
Square_Type
 
move
)

39 
square
 = 
move
;

40 
	}
}

42 
Square_Type
 
	gTicMove
::
	$getmove
() const

44 return(
square
);

45 
	}
}

47 void 
	gTicMove
::
	$setmove
(
Square_Type
 
move
)

49 
square
 = 
move
;

50 
	}
}

52 int 
	gTicMove
::
operator
==(const 
TicMove
 &
other
) const

54 return(
square
 == 
other
.square);

62 int 
	gTicGame
::
	$game_ends
() const

64 int 
i
;

67 for (
i
 = 0; i < 
Possible_Wins
; i++)

69 
Square_Type
 
possible_winner
;

71 
possible_winner
 = 
MyBoard
[
Three_in_a_Row
[
i
][0]];

72 if (
possible_winner
 != 
Empty
 &&

73 
possible_winner
 == 
MyBoard
[
Three_in_a_Row
[
i
][1]] &&

74 
possible_winner
 == 
MyBoard
[
Three_in_a_Row
[
i
][2]])

75 return(
possible_winner
);

79 for (
i
 = 0; i < 
Squares
; i++)

80 if (
MyBoard
[
i
] == 
Empty
)

85 
	}
}

93 int 
	gTicGame
::
	$evaluate_board
(
Player
 
pl
) const

95 int 
val
 = 0;

96 
Square_Type
 
player
;

98 
player
 = (
pl
 == 
PlayerOne
) ? 'X' : 'O';

100 for (int 
i
 = 0; i < 
Possible_Wins
; i++)

102 int 
j
, 
players
 = 0, 
others
 = 0;

104 for (
j
 = 0; j < 3; j++)

106 
Square_Type
 
piece
 = 
MyBoard
[
Three_in_a_Row
[
i
][
j
]];

107 if (
piece
 == 
player
)

108 
players
++;

109 else if (
piece
 == 
	`other_player
(
player
))

110 
others
++;

112 
val
 += 
Heuristic_Array
[
players
][
others
];

114 return(
val
);

115 
	}
}

121 
	gList
<
	gTicMove
> *
	gTicGame
::
	$generate_moves
(
Player
)

123 
List
<
TicMove
> *
ret
 = 
new
 List<TicMove>;

125 for (
Square_Type
 
i
 = 0; i < 
Squares
; i++)

126 if (
MyBoard
[
i
] == 
Empty
)

127 
ret
->
	`addtotail
(
	`TicMove
(
i
));

129 if (
ret
->
	`is_empty
())

131 
	`delete
(
ret
);

134 return(
ret
);

135 
	}
}

140 void 
	gTicGame
::
	$do_move
(const 
TicMove
 &
move
, 
Player
 
pl
)

142 
Square_Type
 
player
;

143 
Square_Type
 
sq
;

145 
player
 = (
pl
 == 
PlayerOne
) ? 'X' : 'O';

146 
sq
 = 
move
.
	`getmove
();

148 
MyBoard
[
sq
] = 
player
;

149 
	}
}

154 void 
	gTicGame
::
	$undo_move
(const 
TicMove
 &
move
, 
Player
)

156 
Square_Type
 
sq
 = 
move
.
	`getmove
();

158 
MyBoard
[
sq
] = 
Empty
;

159 
	}
}

161 int 
	gTicGame
::
	$legal_move
(const 
TicMove
 &
move
)

163 if (
move
.
	`getmove
() < 0 || move.getmove() > 8)

165 return(
MyBoard
[
move
.
	`getmove
()] == 
Empty
);

166 
	}
}

168 
Square_Type
 
	gTicGame
::
	$other_player
(Square_Type 
player
) const

170 return(
player
 == 'X' ? 'O' : 'X');

171 
	}
}

173 void 
	gTicGame
::
	$init_board
()

175 for (int 
i
 = 0; i < 
Squares
; i++)

176 
MyBoard
[
i
] = 
Empty
;

177 
	}
}

179 void 
	gTicGame
::
	$display
() const

181 for (int 
i
 = 0; i < 
Squares
; i += 3)

183 if (
i
 > 0)

184 
	`printf
("---+---+---\n");

185 
	`printf
(" %c | %c | %c \n", 
MyBoard
[
i
], MyBoard[i + 1], MyBoard[i + 2]);

187 
	`printf
("\n");

188 
	}
}

190 #ifdef 
_MSC_VER


191 int 
	$no_mem
(
size_t
 
size
)

193 
	`fprintf
(
stderr
, "Out of memory\n");

194 
	`exit
(1);

196 
	}
}

198 void 
	$no_mem
()

200 
	`fprintf
(
stderr
, "Out of memory\n");

201 
	`exit
(1);

202 
	}
}

206 int 
	$main
()

208 int 
depth
;

209 char 
answer
[80];

210 
TicGame
 
game
;

211 int 
winner
, 
computer
, 
human
, 
tomove
;

214 #ifdef 
_MSC_VER


215 
	`_set_new_handler
(
no_mem
);

217 
	`set_new_handler
(
no_mem
);

220 
	`printf
("Do you want alpha-beta cut offs? ");

221 
	`gets
(
answer
);

222 if (
answer
[0] != 'y' && answer[0] != 'Y')

223 
game
.
	`do_cutoff
(0);

225 
	`printf
("Depth of search? ");

226 
	`gets
(
answer
);

227 
depth
 = 
	`atoi
(
answer
);

230 
	`printf
("Do you want to move first? ");

231 
	`gets
(
answer
);

232 if (
answer
[0] == 'y' || answer[0] == 'Y')

234 
tomove
 = 
human
 = 'X';

235 
computer
 = 'O';

239 
tomove
 = 
computer
 = 'X';

240 
human
 = 'O';

244 
game
.
	`init_board
();

245 
game
.
	`display
();

248 while (!(
winner
 = 
game
.
	`game_ends
()))

250 
TicMove
 
move
;

251 int 
val
;

253 if (
tomove
 == 
human
)

257 
	`printf
("What is your move? ");

258 
	`gets
(
answer
);

259 
move
 = (
Square_Type
)
	`atoi
(
answer
) - 1;

261 while (!
game
.
	`legal_move
(
move
));

264 
val
 = 
game
.
	`do_minimax
(
computer
 == 'X' ? 
PlayerOne
 : 
PlayerTwo
,

265 
depth
, &
move
);

267 
game
.
	`do_move
(
move
, 
tomove
 == 'X' ? 
PlayerOne
 : 
PlayerTwo
);

268 if (
tomove
 == 
computer
)

270 
	`printf
("My move is: %d\n", 
move
.
	`getmove
() + 1);

271 
	`printf
("evaluation of this move: %d\n", 
val
);

273 
game
.
	`display
();

274 
tomove
 = tomove == 
human
 ? 
computer
 : human;

276 if (
winner
 == 'T')

277 
	`puts
("It's a tie.");

278 else if (
winner
 == 
computer
)

279 
	`puts
("I win.");

281 
	`puts
("You win.");

283 
	}
}

	@programs/tictac/tictac.h

30 #include 
	~<stdio.h
>

31 #include 
	~<new.h
>

32 #include 
	~"minimax.h
"

34 #define 
	#Squares
 9

	)
35 typedef char 
	tSquare_Type
;

36 typedef 
Square_Type
 
	tBoard_Type
[
Squares
];

37 #define 
	#Empty
 ' '

	)
42 #define 
	#Possible_Wins
 8

	)
43 const int 
	gThree_in_a_Row
[
Possible_Wins
][3] = {

67 const int 
	gHeuristic_Array
[4][4] = {

78 
class
 
	cTicMove


80 
	mpublic
:

81 
TicMove
();

82 
TicMove
(
Square_Type
);

83 int 
	moperator
==(const 
TicMove
 &) const;

84 
Square_Type
 
	$getmove
() const;

85 void 
	`setmove
(
Square_Type
);

86 
private
:

87 
Square_Type
 
square
;

94 
class
 
TicGame
: 
public
 
Minimax
<
TicMove
>

96 
public
:

97 int 
	`game_ends
() const;

98 int 
	`evaluate_board
(
Player
) const;

99 
List
<
TicMove
> *
	`generate_moves
(
Player
);

100 void 
	`do_move
(const 
TicMove
 &, 
Player
);

101 void 
	`undo_move
(const 
TicMove
 &, 
Player
);

102 int 
	`legal_move
(const 
TicMove
 &);

103 void 
	`init_board
();

104 void 
	`display
() const;

105 
private
:

106 
Square_Type
 
	`other_player
(Square_Type) const;

108 
Board_Type
 
MyBoard
;

109 
	}
};

	@search/aosear/aosearch.cc

25 #include 
	~"aosearch.h
"

42 
	gAOSearch
::
	$AOSearch
(int 
num
, 
AONode
 *
start
)

44 if (
start
)

45 
open
.
	`addtohead
(
start
);

46 
startnode
 = 
start
;

47 
num_op
 = 
num
;

48 
	}
}

55 
	gAOSearch
::~
	$AOSearch
()

57 
	}
}

64 int 
AOSearch
::
	$generate
()

66 if (!
	`solve
())

68 
startnode
 = 0;

72 
	}
}

79 void 
	gAOSearch
::
	$display
()

81 if (
startnode
)

82 
	`print_sol
(
startnode
);

83 
	}
}

93 void 
	gAOSearch
::
	$set_startnode
(
AONode
 *
node
)

95 
open
.
	`addtohead
(
node
);

96 
startnode
 = 
node
;

97 
	}
}

104 void 
	gAOSearch
::
	$clear
()

106 
closed
.
	`clear
(
DoDel
);

107 
open
.
	`clear
(
DoDel
);

108 
startnode
 = 0;

109 
	}
}

117 void 
	gAOSearch
::
	$print_sol
(
AONode
 *
node
)

119 
AONode


120 *
cur
 = 
node
;

124 if (
cur
->
	`gettype
() == 
AND
)

126 int 
i
, 
num
;

128 
num
 = 
cur
->
	`get_nsucc
();

129 for (
i
 = 0; i < 
num
; i++)

130 
	`print_sol
(
cur
->
	`getsucc
(
i
));

139 
cur
->
	`display
();

145 if (!(
cur
 = cur->
	`getsucc
()))

149 
	}
}

166 
	gIntrList
<
	gNode
> *
	gAOSearch
::
	$get_sol
()

168 
IntrList
<
Node
> *
ret
;

170 if (!
startnode
)

173 
ret
 = 
new
 
IntrList
<
Node
>;

174 
	`addnodetosol
(
ret
, 
startnode
);

175 
	`clear
();

176 return(
ret
);

177 
	}
}

185 void 
	gAOSearch
::
addnodetosol
(
IntrList
<
Node
> *
list
, 
AONode
 *
node
)

187 
AONode


188 *
	gcur
 = 
node
;

192 if (
	gcur
->
gettype
() == 
AND
)

194 int 
i
, 
num
;

196 
	gnum
 = 
cur
->
get_nsucc
();

197 for (
	gi
 = 0; i < 
	gnum
; i++)

198 
addnodetosol
(
list
, 
cur
->
getsucc
(
i
));

203 
	gclosed
.
remove_node
(
cur
, 
NoDel
);

204 
	glist
->
addtotail
(
cur
);

205 if (!(
	gcur
 = 
cur
->
getsucc
()))

230 int 
	gAOSearch
::
	$solvable
(
AONode
 *
node
)

232 
AONode


233 *
parent
;

235 
node
->
	`setstatus
(
Solved
);

237 while ((
parent
 = (
AONode
 *)
node
->
	`getparent
()))

245 if (!
parent
->
	`setsolved
(
node
))

247 
node
 = 
parent
;

249 return(!
parent
);

250 
	}
}

269 int 
	gAOSearch
::
	$unsolvable
(
AONode
 *
node
)

271 
node
->
	`setstatus
(
Unsolvable
);

273 while ((
node
 = (
AONode
 *)node->
	`getparent
()))

282 if (!
node
->
	`setunsolvable
())

285 return(!
node
);

286 
	}
}

297 int 
	gAOSearch
::
	$deletable
(
AONode
 *
node
, 
NodeStat
 
stat
)

299 
AONode


300 *
parent
;

302 for (
parent
 = 
node
; parent; parent = (
AONode
 *)parent->
	`getparent
())

303 if (
parent
->
	`getstatus
() == 
stat
)

306 
	}
}

314 void 
	gAOSearch
::
	$prune
(
NodeStat
 
stat
)

316 
AONode


317 *
node
;

318 
IntrListIterator
<
AONode
>

319 
	`iter
(
open
);

321 
node
 = 
iter
.
	`getfirst
();

322 while (
node
)

328 if (
	`deletable
(
node
, 
stat
))

330 
iter
.
	`remove_current
(
DoDel
);

331 
node
 = 
iter
.
	`getcurrent
();

334 
node
 = 
iter
.
	`getnext
();

336 
	}
}

372 int 
	gAOSearch
::
	$solve
()

374 
IntrList
<
Node
>

375 *
succlist
;

376 
AONode


377 *
father
,

378 *
child
;

380 while((
father
 = 
open
.
	`gethead
()) != 0)

382 
open
.
	`remove_head
(
NoDel
);

383 
closed
.
	`addtohead
(
father
);

385 if (
	`is_terminal
(
father
))

387 if (
	`solvable
(
father
))

389 
	`prune
(
Solved
);

393 
succlist
 = 
father
->
	`expand
(
num_op
);

395 if (!
succlist
 || succlist->
	`is_empty
())

397 if (
	`unsolvable
(
father
))

399 
	`delete
(
succlist
);

402 
	`prune
(
Unsolvable
);

406 while ((
child
 = (
AONode
 *)
succlist
->
	`gethead
()) != 0)

408 
succlist
->
	`remove_head
(
NoDel
);

410 
child
->
	`setparent
(
father
);

411 
father
->
	`incn_left
();

419 if (
child
->
	`gettype
() == 
AND
)

420 
closed
.
	`addtohead
(
child
);

422 if (!
	`add
(
child
))

423 
	`delete
(
child
);

424 #ifdef 
DEBUG


427 
	`puts
("adding node:");

428 
child
->
	`display
();

429 
	`putchar
('\n');

433 
	`delete
(
succlist
);

436 
	}
}

	@search/aosear/taobread.cc

25 #include 
	~"aitree.h
"

31 
	gAOBreadthTree
::
	$AOBreadthTree
(int 
op
, 
AONode
 *
start
)

32 :
	$AOSearch
(
op
, 
start
)

34 
	}
}

45 int 
	gAOBreadthTree
::
	$add
(
AONode
 *
succ
)

47 
AONode


48 *
node
;

50 
i
,

51 
num
;

53 if (
succ
->
	`gettype
() == 
AND
)

60 
num
 = 
succ
->
	`get_nsucc
();

61 for (
i
 = 0 ;i < 
num
; i++)

63 
node
 = 
succ
->
	`getsucc
(
i
);

64 
node
->
	`setparent
(
succ
);

65 
open
.
	`addtotail
(
node
);

69 
open
.
	`addtotail
(
succ
);

72 
	}
}

	@search/aosear/taodepth.cc

25 #include 
	~"aitree.h
"

31 
	gAODepthTree
::
	$AODepthTree
(int 
op
, 
AONode
 *
start
)

32 :
	$AOSearch
(
op
, 
start
)

34 
	}
}

45 int 
	gAODepthTree
::
	$add
(
AONode
 *
succ
)

47 
AONode


48 *
node
;

50 
i
;

52 if (
succ
->
	`gettype
() == 
AND
)

59 
i
 = 
succ
->
	`get_nsucc
() - 1;

60 for ( ;
i
 >= 0; i--)

62 
node
 = 
succ
->
	`getsucc
(
i
);

63 
node
->
	`setparent
(
succ
);

64 
open
.
	`addtohead
(
node
);

68 
open
.
	`addtohead
(
succ
);

71 
	}
}

	@search/bisear/bisearch.cc

25 #include 
	~"bisearch.h
"

31 
	gBiSearch
::
	$BiSearch
(int 
op
, 
Node
 *
start
, Node *
goal
)

33 if (
start
)

34 
s_open
.
	`addtohead
(
start
);

35 if (
goal
)

36 
t_open
.
	`addtohead
(
goal
);

37 
num_op
 = 
op
;

38 
	}
}

46 
	gBiSearch
::~
	$BiSearch
()

48 
	}
}

65 
IntrList
<
Node
> *
BiSearch
::
	$get_sol
()

67 
Node
 *
cur
;

68 
IntrList
<
Node
> *
ret
;

70 if (!
foundsol
)

73 
ret
 = 
new
 
IntrList
<
Node
>;

85 for (
cur
 = 
s_closed
.
	`gethead
()->
	`getparent
(); cur; cur = cur->getparent())

87 
s_closed
.
	`remove_node
(
cur
, 
NoDel
);

88 
ret
->
	`addtohead
(
cur
);

90 for (
cur
 = 
t_closed
.
	`gethead
(); cur; cur = cur->
	`getparent
())

92 
t_closed
.
	`remove_node
(
cur
, 
NoDel
);

93 
ret
->
	`addtotail
(
cur
);

95 
	`clear
();

96 return(
ret
);

97 
	}
}

106 void 
	gBiSearch
::
	$set_goalnode
(
Node
 *
node
)

108 
t_open
.
	`addtohead
(
node
);

109 
	}
}

119 void 
	gBiSearch
::
	$set_startnode
(
Node
 *
node
)

121 
s_open
.
	`addtohead
(
node
);

122 
	}
}

129 void 
	gBiSearch
::
	$clear
()

131 
s_open
.
	`clear
(
DoDel
);

132 
s_closed
.
	`clear
(
DoDel
);

133 
t_open
.
	`clear
(
DoDel
);

134 
t_closed
.
	`clear
(
DoDel
);

135 
	}
}

141 void 
	gBiSearch
::
	$display
() const

143 if (
foundsol
)

145 #ifdef 
DEBUG


146 
	`puts
("Printing first half of solution path");

148 
	`print_sol
(
s_closed
.
	`gethead
()->
	`getparent
());

149 #ifdef 
DEBUG


150 
	`puts
("Printing second half of solution path");

152 
	`print_sol_2
(
t_closed
.
	`gethead
());

154 
	}
}

164 void 
	gBiSearch
::
	$print_sol
(
Node
 *
sol
) const

166 if (!
sol
)

168 
	`print_sol
(
sol
->
	`getparent
());

169 
sol
->
	`display
();

170 
	}
}

177 void 
	gBiSearch
::
	$print_sol_2
(
Node
 *
sol
) const

179 while (
sol
)

181 
sol
->
	`display
();

182 
sol
 = sol->
	`getparent
();

184 
	}
}

191 int 
	gBiSearch
::
	$generate
()

193 
foundsol
 = 
	`bisolve
() ? 1 : 0;

194 return(
foundsol
);

195 
	}
}

204 
Node
 *
	gBiSearch
::
	$bisolve
()

206 
Node


207 *
node
 = 0;

209 while (
node
 == 0)

211 if (
s_open
.
	`getcount
() && s_open.getcount() <= 
t_open
.getcount())

212 
node
 = 
	`solve
(&
s_open
, &
s_closed
, &
t_closed
);

213 else if (
t_open
.
	`getcount
())

214 
node
 = 
	`solve
(&
t_open
, &
t_closed
, &
s_closed
);

218 return(
node
);

219 
	}
}

248 
Node
 *
	gBiSearch
::
solve
(
IntrList
<Node> *
x_open
, IntrList<Node> *
x_closed
,

249 
IntrList
<
Node
> *
y_closed
)

251 
	gIntrList
<
	gNode
>

252 *
	gsucclist
;

253 
Node


254 *
	gfather
,

255 *
	gchild
,

256 *
	gaux
 = 0;

258 
	gfather
 = 
x_open
->
gethead
();

259 
	gx_open
->
remove_head
(
NoDel
);

260 
	gx_closed
->
addtohead
(
father
);

262 if (!(
	gsucclist
 = 
father
->
expand
(
num_op
)))

265 while ((
	gchild
 = 
succlist
->
gethead
()) != 0)

267 
succlist
->
remove_head
(
NoDel
);

268 
	gchild
->
setparent
(
father
);

270 if ((
	gaux
 = 
y_closed
->
lookup
(
child
)) != 0)

276 
y_closed
->
remove_found
(
NoDel
);

277 
	gy_closed
->
addtohead
(
aux
);

278 
	gx_closed
->
addtohead
(
child
);

282 if (!
add
(
x_open
, 
x_closed
, 
child
))

283 
delete
(
child
);

284 #ifdef 
DEBUG


287 
puts
("adding node:");

288 
	gchild
->
display
();

289 
putchar
('\n');

293 
delete
(
succlist
);

294 return(
	gaux
);

	@search/bisear/gbibread.cc

25 #include 
	~"aigraph.h
"

31 
	gBiBreadthGraph
::
	$BiBreadthGraph
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$BiSearch
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBiBreadthGraph
::
add
(
IntrList
<
Node
> *
x_open
, IntrList<Node> *
x_closed
,

43 
Node
 *
succ
)

49 if (!
	gx_closed
->
lookup
(
succ
) && !
	gx_open
->lookup(succ))

51 
	gx_open
->
addtotail
(
succ
);

	@search/bisear/gbidepth.cc

25 #include 
	~"aigraph.h
"

31 
	gBiDepthGraph
::
	$BiDepthGraph
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$BiSearch
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBiDepthGraph
::
add
(
IntrList
<
Node
> *
x_open
, IntrList<Node> *
x_closed
,

43 
Node
 *
succ
)

49 if (!
	gx_closed
->
lookup
(
succ
) && !
	gx_open
->lookup(succ))

51 
	gx_open
->
addtohead
(
succ
);

	@search/bisear/tbibread.cc

25 #include 
	~"aitree.h
"

31 
	gBiBreadthTree
::
	$BiBreadthTree
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$BiSearch
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBiBreadthTree
::
add
(
IntrList
<
Node
> *
x_open
, IntrList<Node> *, Node *
succ
)

44 
	gx_open
->
addtotail
(
succ
);

	@search/bisear/tbidepth.cc

25 #include 
	~"aitree.h
"

31 
	gBiDepthTree
::
	$BiDepthTree
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$BiSearch
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBiDepthTree
::
add
(
IntrList
<
Node
> *
x_open
, IntrList<Node> *, Node *
succ
)

44 
	gx_open
->
addtohead
(
succ
);

	@search/btrack/btrack.cc

25 #include 
	~"btrack.h
"

32 
	gBackTrack
::
	$BackTrack
(int 
op
, 
BackNode
 *
start
, BackNode *
goal
)

34 if (
start
)

35 
stack
.
	`addtohead
(
start
);

36 
goalnode
 = 
goal
;

37 
num_op
 = 
op
;

38 
depth
 = 
do_lookup
 = 0;

39 
	}
}

47 
	gBackTrack
::~
	$BackTrack
()

49 
	`delete
(
goalnode
);

50 
	}
}

59 int 
	gBackTrack
::
	$is_goal
(const 
BackNode
 *
node
)

61 #ifdef 
DEBUG


62 if (!
node
)

64 
	`puts
("BackTrack::is_goal() called with 0 (NULL) argument - did you forget to implement is_goal()?");

65 
	`exit
(0);

68 return(*
goalnode
 == *
node
);

69 
	}
}

76 void 
	gBackTrack
::
	$setdepth
(int 
dpth
)

78 
depth
 = 
dpth
;

79 
	}
}

86 void 
	gBackTrack
::
	$setcheck
(int 
check
)

88 
do_lookup
 = 
check
;

89 
	}
}

95 void 
	gBackTrack
::
	$display
() const

97 
ROIntrListIterator
<
BackNode
> 
	`iter
(
stack
);

99 for (const 
BackNode
 *
n
 = 
iter
.
	`getfirst
(); n; n = iter.
	`getnext
())

100 
n
->
	`display
();

101 
	}
}

111 const 
BackNode
 *
	gBackTrack
::
	$get_goal
() const

113 return(
stack
.
	`gettail
());

114 
	}
}

121 const 
	gIntrList
<
	gBackNode
> *
	gBackTrack
::
	$get_sol
()

123 return(&
stack
);

124 
	}
}

133 void 
	gBackTrack
::
	$set_goalnode
(
BackNode
 *
node
)

135 
goalnode
 = 
node
;

136 
	}
}

146 void 
	gBackTrack
::
	$set_startnode
(
BackNode
 *
node
)

148 
stack
.
	`addtohead
(
node
);

149 
	}
}

156 void 
	gBackTrack
::
	$clear
()

158 
stack
.
	`clear
(
DoDel
);

159 
delete
 
goalnode
;

160 
goalnode
 = 0;

161 
	}
}

168 int 
	gBackTrack
::
	$generate
()

170 return(
	`solve
());

171 
	}
}

178 int 
	gBackTrack
::
	$generate_next
()

184 
stack
.
	`remove_tail
(
DoDel
);

185 return(
	`solve
());

186 
	}
}

207 int 
	gBackTrack
::
	$solve
()

209 
BackNode


210 *
father
,

211 *
child
;

213 while((
father
 = 
stack
.
	`gettail
()) != 0)

215 if (
	`is_goal
(
father
))

217 if (
stack
.
	`getcount
() == 
depth
)

218 
stack
.
	`remove_tail
(
DoDel
);

221 
child
 = 
father
->
	`expand_one
(
num_op
);

223 if (!
child
)

224 
stack
.
	`remove_tail
(
DoDel
);

227 if (
do_lookup
 && 
stack
.
	`lookup
(
child
))

228 
delete
 
child
;

231 
stack
.
	`addtotail
(
child
);

232 #ifdef 
DEBUG


233 
	`puts
("adding node:");

234 
child
->
	`display
();

235 
	`putchar
('\n');

242 
	}
}

	@search/nodes/andnode.cc

25 #include 
	~"ainodes.h
"

43 
	gAndNode
::
	$AndNode
()

44 :
	$succlist
(0, 
DontManage
)

46 
	}
}

54 
	gAndNode
::
	$AndNode
(int 
num
)

55 :
	$AONode
(
num
), 
	$succlist
(0, 
DontManage
)

57 
succlist
.
	`grow
(
num
);

58 
	}
}

61 
TypeOfNode
 
	gAndNode
::
	$gettype
() const

63 return(
type
);

64 
	}
}

67 
NodeStat
 
	gAndNode
::
	$getstatus
() const

69 return(
status
);

70 
	}
}

73 void 
	gAndNode
::
	$setstatus
(
NodeStat
 
stat
)

75 
status
 = 
stat
;

76 
	}
}

89 int 
	gAndNode
::
	$setsolved
(
AONode
 *)

91 
n_left
--;

92 if (
n_left
 == 0)

94 
status
 = 
Solved
;

98 
	}
}

109 int 
	gAndNode
::
	$setunsolvable
()

111 
status
 = 
Unsolvable
;

113 
	}
}

120 void 
	gAndNode
::
	$addsucc
(
AONode
 *
node
)

122 
succlist
 += 
node
;

123 
n_left
++;

124 
	}
}

133 void 
	gAndNode
::
	$setsucc
(int 
index
, 
AONode
 *
node
)

135 
succlist
[
index
] = 
node
;

136 
	}
}

139 int 
	gAndNode
::
	$get_nsucc
() const

141 return(
succlist
.
	`getsize
());

142 
	}
}

145 
AONode
 *
	gAndNode
::
	$getsucc
(int 
index
) const

147 return((
AONode
 *)
succlist
[
index
]);

148 
	}
}

157 void 
	gAndNode
::
	$display
() const

159 
	`puts
("display() function of class AndNode not implemented - should never be called");

160 
	`exit
(0);

161 
	}
}

168 int 
	gAndNode
::
operator
==(const 
Node
 &) const

170 
puts
("operator==() function of class AndNode not implemented - should never be called");

171 
exit
(0);

	@search/nodes/aonode.cc

25 #include 
	~"ainodes.h
"

27 
TypeOfNode
 
	gOrNode
::
type
 = 
OR
,

28 
	gAndNode
::
type
 = 
AND
;

35 
	gAONode
::
	$AONode
()

37 
n_left
 = 0;

38 
status
 = 
Undef
;

39 
	}
}

48 
	gAONode
::
	$AONode
(int 
num_succ
)

50 
n_left
 = 
num_succ
;

51 
status
 = 
Undef
;

52 
	}
}

60 void 
	gAONode
::
	$incn_left
()

62 
n_left
++;

63 
	}
}

72 
AONode
 *
	gAONode
::
	$clone
() const

74 
	`puts
("AONode::clone() not implemented - should never be called");

75 
	`exit
(0);

77 
	}
}

	@search/nodes/backnode.cc

25 #include 
	~"ainodes.h
"

31 
	gBackNode
::
	$BackNode
()

33 
last_op
 = 0;

34 
	}
}

42 
BackNode
 *
	gBackNode
::
	$do_operator
(int)

44 
	`puts
("Wrong do_operator function called - did you forget to implement it (or expand_one)!?");

45 
	`exit
(0);

47 
	}
}

56 
BackNode
 *
	gBackNode
::
	$expand_one
(int 
numop
)

58 
BackNode
 *
succ
 = 0;

64 while (
last_op
 < 
numop
 && !
succ
)

65 
succ
 = 
	`do_operator
(
last_op
++);

67 return(
succ
);

68 
	}
}

76 
BackNode
 *
	gBackNode
::
	$clone
() const

78 
	`puts
("BackNode::clone() not implemented - should never be called");

79 
	`exit
(0);

81 
	}
}

	@search/nodes/bnode.cc

25 #include 
	~"ainodes.h
"

32 
	gBestNode
::
	$BestNode
()

34 
f
 = 0;

35 
	}
}

41 int 
	gBestNode
::
	$get_f
() const

43 return(
f
);

44 
	}
}

50 void 
	gBestNode
::
	$set_f
(int 
val
)

52 
f
 = 
val
;

53 
	}
}

63 int 
	gBestNode
::
operator
<(const 
Node
 &
other
) const

65 return(
f
 < ((
BestNode
 &)
other
).f);

	@search/nodes/dnode.cc

25 #include 
	~"ainodes.h
"

27 
	gDepthNode
::
	$DepthNode
()

29 
depth
 = 0;

30 
	}
}

32 void 
	gDepthNode
::
	$setdepth
(unsigned 
d
)

34 
depth
 = 
d
;

35 
	}
}

37 unsigned 
	gDepthNode
::
	$getdepth
() const

39 return(
depth
);

40 
	}
}

	@search/nodes/node.cc

25 #include 
	~"ainodes.h
"

30 
	gNode
::
	$Node
()

32 
parent
 = 0;

33 
	}
}

42 int 
	gNode
::
operator
<(const 
Node
 &
other
) const

44 
puts
("Node::operator< not implemented - should never be called");

45 
exit
(0);

57 
	gIntrList
<
	gNode
> *Node::
	$expand
(int 
max_op
)

59 
IntrList
<
Node
> *
ret
 = 
new
 IntrList<Node>(0);

60 
Node
 *
succ
;

61 int 
op
;

63 for (
op
 = 0; op < 
max_op
; op++)

65 
succ
 = 
	`do_operator
(
op
);

66 if (
succ
)

67 
ret
->
	`addtotail
(
succ
);

70 if (
ret
->
	`is_empty
())

72 
	`delete
(
ret
);

73 
ret
 = 
NULL
;

76 return(
ret
);

77 
	}
}

80 void 
	gNode
::
	$setparent
(
Node
 *
par
)

82 
parent
 = 
par
;

83 
	}
}

86 
Node
 *
	gNode
::
	$getparent
() const

88 return(
parent
);

89 
	}
}

97 
Node
 *
	gNode
::
	$do_operator
(int )

99 
	`puts
("Wrong do_operator() function called - did you forget to implement it (or expand)!?");

100 
	`exit
(0);

102 
	}
}

110 
Node
 *
	gNode
::
	$clone
() const

112 
	`puts
("Node::clone() not implemented - should not be called");

113 
	`exit
(0);

115 
	}
}

	@search/nodes/ornode.cc

25 #include 
	~"ainodes.h
"

30 
	gOrNode
::
	$OrNode
()

32 
succ
 = 0;

33 
	}
}

36 
TypeOfNode
 
	gOrNode
::
	$gettype
() const

38 return(
type
);

39 
	}
}

42 int 
	gOrNode
::
	$get_nsucc
() const

45 
	}
}

48 
AONode
 *
	gOrNode
::
	$getsucc
(int) const

50 return(
succ
);

51 
	}
}

54 void 
	gOrNode
::
	$setstatus
(
NodeStat
 
s
)

56 
status
 = 
s
;

57 
	}
}

60 
NodeStat
 
	gOrNode
::
	$getstatus
() const

62 return(
status
);

63 
	}
}

76 int 
	gOrNode
::
	$setsolved
(
AONode
 *
succnode
)

78 
status
 = 
Solved
;

79 
succ
 = 
succnode
;

81 
	}
}

95 int 
	gOrNode
::
	$setunsolvable
()

97 
n_left
--;

98 if (!
n_left
)

100 
status
 = 
Unsolvable
;

104 
	}
}

	@search/nodes/unode.cc

25 #include 
	~"ainodes.h
"

30 
	gUniNode
::
	$UniNode
()

32 
g
 = 0;

33 
	}
}

39 int 
	gUniNode
::
	$get_g
() const

41 return(
g
);

42 
	}
}

48 void 
	gUniNode
::
	$set_g
(int 
val
)

50 
g
 = 
val
;

51 
	}
}

61 int 
	gUniNode
::
operator
<(const 
Node
 &
other
) const

63 return(
g
 - ((
UniNode
 &)
other
).g);

	@search/unisear/astar.cc

25 #include 
	~"aigraph.h
"

33 
	gAStar
::
	$AStar
(int 
op
, 
Node
 *
start
, Node *
goal
)

34 :
	$Search
(
op
, 
start
, 
goal
)

36 
	}
}

63 int 
	gAStar
::
	$add
(
Node
 *
succ
)

65 
BestNode


66 *
parent
,

67 *
old
 = 0,

68 *
bsucc
 = (
BestNode
 *)
succ
;

71 
g
;

73 
parent
 = (
BestNode
 *)
bsucc
->
	`getparent
();

81 
g
 = 
parent
->
	`get_g
() + 
	`compute_g
(
bsucc
);

82 
bsucc
->
	`set_g
(
g
);

89 
bsucc
->
	`set_f
(
g
 + 
	`compute_h
(bsucc));

92 if ((
old
 = (
BestNode
 *)
open
.
	`lookup
(
succ
)) != 0)

95 if (*
bsucc
 < *
old
)

97 
open
.
	`remove_found
(
DoDel
);

98 
open
.
	`insert
(
bsucc
);

105 if ((
old
 = (
BestNode
 *)
closed
.
	`lookup
(
succ
)) != 0)

108 if (*
bsucc
 < *
old
)

110 
closed
.
	`remove_found
(
DoDel
);

111 
open
.
	`insert
(
bsucc
);

118 
open
.
	`insert
(
bsucc
);

120 
	}
}

	@search/unisear/gbreadth.cc

25 #include 
	~"aigraph.h
"

31 
	gBreadthGraph
::
	$BreadthGraph
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBreadthGraph
::
	$add
(
Node
 *
succ
)

48 if (!
closed
.
	`lookup
(
succ
) && !
open
.lookup(succ))

50 
open
.
	`addtotail
(
succ
);

54 
	}
}

	@search/unisear/gdepth.cc

25 #include 
	~"aigraph.h
"

31 
	gDepthGraph
::
	$DepthGraph
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
maxdepth
 = 0;

35 
	}
}

42 void 
	gDepthGraph
::
	$setdepth
(unsigned 
d
)

44 
maxdepth
 = 
d
;

45 
	}
}

47 unsigned 
	gDepthGraph
::
	$getdepth
() const

49 return(
maxdepth
);

50 
	}
}

58 int 
	gDepthGraph
::
	$add
(
Node
 *
succ
)

60 if (
maxdepth
)

62 unsigned 
depth
;

63 
DepthNode
 *
par
,

64 *
dsucc
 = (
DepthNode
 *)
succ
;

66 
par
 = (
DepthNode
 *)
dsucc
->
	`getparent
();

67 
depth
 = 
par
->
	`getdepth
() + 1;

73 if (
depth
 >= 
maxdepth
)

75 
dsucc
->
	`setdepth
(
depth
);

82 if (!
closed
.
	`lookup
(
succ
) && !
open
.lookup(succ))

84 
open
.
	`addtohead
(
succ
);

88 
	}
}

	@search/unisear/gucost.cc

25 #include 
	~"aigraph.h
"

31 
	gUnicostGraph
::
	$UnicostGraph
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
	}
}

47 int 
	gUnicostGraph
::
	$add
(
Node
 *
succ
)

49 
UniNode


50 *
parent
,

51 *
old
 = 0,

52 *
bsucc
 = (
UniNode
 *)
succ
;

55 
g
;

63 
parent
 = (
UniNode
 *)
bsucc
->
	`getparent
();

64 
g
 = 
parent
->
	`get_g
() + 
	`compute_g
(
bsucc
);

65 
bsucc
->
	`set_g
(
g
);

69 if ((
old
 = (
UniNode
 *)
open
.
	`lookup
(
succ
)) != 0)

72 if (*
bsucc
 < *
old
)

74 
open
.
	`remove_found
(
DoDel
);

75 
open
.
	`insert
(
bsucc
);

82 if ((
old
 = (
UniNode
 *)
closed
.
	`lookup
(
succ
)) != 0)

86 
open
.
	`insert
(
bsucc
);

88 
	}
}

	@search/unisear/search.cc

25 #include 
	~"aisearch.h
"

32 
	gSearch
::
	$Search
(int 
op
, 
Node
 *
start
, Node *
goal
)

34 if (
start
)

35 
open
.
	`addtohead
(
start
);

36 
num_op
 = 
op
;

37 
goalnode
 = 
goal
;

38 
solgoal
 = 0;

39 
	}
}

47 
	gSearch
::~
	$Search
()

49 
	`delete
(
goalnode
);

50 
	}
}

57 
Node
 *
	gSearch
::
	$get_goal
() const

59 return(
solgoal
);

60 
	}
}

77 
	gIntrList
<
	gNode
> *
	gSearch
::
	$get_sol
()

79 
Node
 *
cur
;

80 
IntrList
<
Node
> *
ret
;

82 if (!
solgoal
)

85 
ret
 = 
new
 
IntrList
<
Node
>;

92 for (
cur
 = 
solgoal
; cur; cur = cur->
	`getparent
())

94 
closed
.
	`remove_node
(
cur
, 
NoDel
);

95 
ret
->
	`addtohead
(
cur
);

97 
	`clear
();

98 return(
ret
);

99 
	}
}

108 void 
	gSearch
::
	$set_goalnode
(
Node
 *
node
)

110 
goalnode
 = 
node
;

111 
	}
}

121 void 
	gSearch
::
	$set_startnode
(
Node
 *
node
)

123 
open
.
	`addtohead
(
node
);

124 
	}
}

133 int 
	gSearch
::
	$is_goal
(const 
Node
 *
node
)

135 #ifdef 
DEBUG


136 if (!
node
)

138 
	`puts
("Search::is_goal() called with 0 (NULL) argument - did you forget to implement is_goal()?");

139 
	`exit
(0);

142 return(*
goalnode
 == *
node
);

143 
	}
}

150 void 
	gSearch
::
	$clear
()

152 
open
.
	`clear
(
DoDel
);

153 
closed
.
	`clear
(
DoDel
);

155 
delete
 
goalnode
;

156 
goalnode
 = 
solgoal
 = 0;

157 
	}
}

163 void 
	gSearch
::
	$display
() const

165 if (
solgoal
)

166 
	`print_sol
(
solgoal
);

167 
	}
}

175 void 
	gSearch
::
	$print_sol
(
Node
 *
node
) const

177 if (!
node
)

179 
	`print_sol
(
node
->
	`getparent
());

180 
node
->
	`display
();

181 
	}
}

188 int 
	gSearch
::
	$generate
()

190 
solgoal
 = 
	`solve
();

191 return(
solgoal
 != 0);

192 
	}
}

216 
Node
 *
	gSearch
::
	$solve
()

218 
IntrList
<
Node
>

219 *
succlist
;

220 
Node


221 *
father
,

222 *
child
;

224 while((
father
 = 
open
.
	`gethead
()) != 0)

226 
open
.
	`remove_head
(
NoDel
);

227 
closed
.
	`addtohead
(
father
);

229 if (
	`is_goal
(
father
))

230 return(
father
);

232 if (!(
succlist
 = 
father
->
	`expand
(
num_op
)))

235 while ((
child
 = 
succlist
->
	`gethead
()))

237 
succlist
->
	`remove_head
(
NoDel
);

238 
child
->
	`setparent
(
father
);

239 if (!
	`add
(
child
))

240 
	`delete
(
child
);

241 #ifdef 
DEBUG


244 
	`puts
("adding node:");

245 
child
->
	`display
();

246 
	`putchar
('\n');

250 
	`delete
(
succlist
);

253 
	}
}

	@search/unisear/tbreadth.cc

25 #include 
	~"aitree.h
"

31 
	gBreadthTree
::
	$BreadthTree
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gBreadthTree
::
	$add
(
Node
 *
succ
)

44 
open
.
	`addtotail
(
succ
);

46 
	}
}

	@search/unisear/tdepth.cc

25 #include 
	~"aitree.h
"

31 
	gDepthTree
::
	$DepthTree
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
maxdepth
 = 0;

35 
	}
}

42 void 
	gDepthTree
::
	$setdepth
(unsigned 
depth
)

44 
maxdepth
 = 
depth
;

45 
	}
}

48 unsigned 
	gDepthTree
::
	$getdepth
() const

50 return(
maxdepth
);

51 
	}
}

61 int 
	gDepthTree
::
	$add
(
Node
 *
succ
)

63 if (
maxdepth
)

65 unsigned 
depth
;

66 
DepthNode
 *
par
,

67 *
dsucc
 = (
DepthNode
 *)
succ
;

73 
par
 = (
DepthNode
 *)
dsucc
->
	`getparent
();

74 
depth
 = 
par
->
	`getdepth
() + 1;

76 if (
depth
 >= 
maxdepth
)

79 
dsucc
->
	`setdepth
(
depth
);

82 
open
.
	`addtohead
(
succ
);

84 
	}
}

	@search/unisear/tucost.cc

25 #include 
	~"aitree.h
"

31 
	gUnicostTree
::
	$UnicostTree
(int 
op
, 
Node
 *
start
, Node *
goal
)

32 :
	$Search
(
op
, 
start
, 
goal
)

34 
	}
}

42 int 
	gUnicostTree
::
	$add
(
Node
 *
succ
)

44 
UniNode


45 *
parent
,

46 *
bsucc
 = (
UniNode
 *)
succ
;

49 
g
;

57 
parent
 = (
UniNode
 *)
bsucc
->
	`getparent
();

58 
g
 = 
parent
->
	`get_g
() + 
	`compute_g
(
bsucc
);

59 
bsucc
->
	`set_g
(
g
);

61 
open
.
	`insert
(
bsucc
);

63 
	}
}

	@util/biter.cc

25 #include 
	~"blist.h
"

27 void 
	gBasListIterator
::
	$remove_current
(int 
del
, int 
clr
)

29 
ListNode
 *
tmp
;

31 if (!
current
)

34 if (
current
 == 
mine
->
tail
)

35 
tmp
 = 
current
->
prev
;

37 
tmp
 = 
current
->
next
;

39 
mine
->
	`remove_node
(
current
, 
del
, 
clr
);

40 
current
 = 
tmp
;

41 
	}
}

	@util/blist.cc

25 #include 
	~"blist.h
"

27 
	gBasList
::
	$BasList
(const 
BasList
 &
other
)

29 
found
 = 0;

30 
	`copylist
(
other
);

31 
	}
}

33 
	gBasList
 &BasList::
operator
=(const 
BasList
 &
other
)

35 if (
this
 == &
other
)

36 return(*
this
);

38 
clear
();

39 
copylist
(
other
);

41 return(*
	gthis
);

44 void 
	gBasList
::
	$copylist
(const 
BasList
 &
other
)

46 
ListNode
 *
node
, *
prevnode
, *
newnode
;

48 if (!(
node
 = 
other
.
head
))

51 
newnode
 = 
	`copynode
(
node
);

52 
newnode
->
prev
 = 0;

53 
head
 = 
newnode
;

54 
prevnode
 = 
newnode
;

56 while ((
node
 = node->
next
))

58 
newnode
 = 
	`copynode
(
node
);

59 
newnode
->
prev
 = 
prevnode
;

60 
prevnode
->
next
 = 
newnode
;

61 
prevnode
 = 
newnode
;

63 
newnode
->
next
 = 0;

64 
tail
 = 
newnode
;

65 
nodecount
 = 
other
.nodecount;

66 
	}
}

68 int 
	gBasList
::
operator
==(const 
BasList
 &
other
) const

70 
ListNode
 *
n
, *
p
;

72 if (
	gnodecount
 != 
other
.
nodecount
)

75 for (
	gn
 = 
head
, 
	gp
 = 
other
.head; n; n = 
n
->
next
, p = 
p
->next)

76 if (!
compareeq
(
n
, 
p
))

81 
ListNode
 *
	gBasList
::
operator
[](int 
index
) const

83 
ListNode
 *
p
;

85 if (
	gindex
 < 0 || index >= 
nodecount
)

88 
	gp
 = 
head
;

89 for (int 
	gi
 = 0; i < 
	gindex
; i++)

90 
	gp
 = 
p
->
next
;

92 return(
	gp
);

96 void 
	gBasList
::
	$addtohead
(
ListNode
 *
node
)

98 
nodecount
++;

100 
node
->
prev
 = 0;

101 
node
->
next
 = 
head
;

102 if (
head
)

103 
head
->
prev
 = 
node
;

105 
tail
 = 
node
;

106 
head
 = 
node
;

107 
	}
}

110 void 
	gBasList
::
	$addtotail
(
ListNode
 *
node
)

112 
nodecount
++;

114 
node
->
next
 = 0;

115 
node
->
prev
 = 
tail
;

116 if (
tail
)

117 
tail
->
next
 = 
node
;

119 
head
 = 
node
;

120 
tail
 = 
node
;

121 
	}
}

124 void 
	gBasList
::
	$remove_node
(
ListNode
 *
node
, int 
clr
, int 
del
)

126 if (!
node
)

129 
nodecount
--;

131 if (
node
 == 
found
)

132 
found
 = 0;

134 if (
node
 == 
head
)

136 if ((
head
 = head->
next
) != 0)

137 
head
->
prev
 = 0;

138 if (
tail
 == 
node
)

139 
tail
 = 
head
;

141 else if (
node
 == 
tail
)

143 
tail
 = tail->
prev
;

144 
tail
->
next
 = 0;

148 
node
->
prev
->
next
 = node->next;

149 
node
->
next
->
prev
 = node->prev;

152 if (
del
)

154 if (
clr
)

155 
	`clearnode
(
node
);

156 
delete
 
node
;

158 
	}
}

161 void 
	gBasList
::
	$clear
(int 
clr
, int 
del
)

163 
ListNode
 *
p
;

165 if (
del
)

167 if (
clr
)

169 while(
head
)

171 
p
 = 
head
;

172 
head
 = head->
next
;

173 
	`clearnode
(
p
);

174 
delete
 
p
;

179 while(
head
)

181 
p
 = 
head
;

182 
head
 = head->
next
;

183 
delete
 
p
;

187 
head
 = 
tail
 = 
found
 = 0;

188 
nodecount
 = 0;

189 
	}
}

192 int 
	gBasList
::
	$find
(
ListNode
 *
findme
)

194 
ListNode
 *
p
;

195 int 
i
 = 0;

197 for (
p
 = 
head
; p; p = p->
next
)

199 if (
	`compareeq
(
findme
, 
p
))

201 
found
 = 
p
;

202 return(
i
);

204 
i
++;

208 
	}
}

211 
ListNode
 *
	gBasList
::
	$lookup
(ListNode *
findme
)

213 
ListNode
 *
p
;

215 for (
p
 = 
head
; p; p = p->
next
)

217 if (
	`compareeq
(
findme
, 
p
))

219 
found
 = 
p
;

220 return(
p
);

225 
	}
}

228 void 
	gBasList
::
	$insert
(
ListNode
 *
node
)

230 
ListNode
 *
cur
, *
tmp
;

232 if (!
head
 || 
	`comparelt
(
node
, head))

233 
	`addtohead
(
node
);

236 for (
cur
 = 
head
->
next
; cur; cur = cur->next)

237 if (
	`comparelt
(
node
, 
cur
))

239 
node
->
next
 = 
cur
;

240 
node
->
prev
 = 
cur
->prev;

241 
cur
->
prev
 = 
node
;

242 
node
->
prev
->
next
 = node;

243 
nodecount
++;

246 if (!
cur
)

247 
	`addtotail
(
node
);

249 
	}
}

	@util/string.cc

25 #include 
	~"xstring.h
"

27 
	gString
::
	$String
(const char *
str
)

29 
rep
 = 
new
 char[
	`strlen
(
str
) + 1];

30 
	`strcpy
(
rep
, 
str
);

31 
	}
}

33 
	gString
::
	$String
(const 
String
 &
other
)

35 
rep
 = 
new
 char[
	`strlen
(
other
.rep) + 1];

36 
	`strcpy
(
rep
, 
other
.rep);

37 
	}
}

39 
	gString
 &String::
operator
=(const 
String
 &
other
)

41 if (
this
 != &
other
)

43 
delete
 [] 
rep
;

44 
	grep
 = 
new
 char[
strlen
(
other
.
rep
) + 1];

45 
strcpy
(
rep
, 
other
.rep);

47 return(*
	gthis
);

50 void 
	gString
::
	$setstring
(const char *
str
)

52 
delete
 [] 
rep
;

53 
rep
 = 
new
 char[
	`strlen
(
str
) + 1 ];

54 
	`strcpy
(
rep
, 
str
);

55 
	}
}

	@/usr/include/ctype.h

8 #ifndef 
_CTYPE_H


9 #define 
	#_CTYPE_H


	)
11 #pragma 
ident
 "@(#)ctype.h 1.19 95/01/28 SMI"

13 #include 
	~<sys/feature_tests.h
>

15 #ifdef 
__cplusplus


19 #define 
	#_U
 01

	)
20 #define 
	#_L
 02

	)
21 #define 
	#_N
 04

	)
22 #define 
	#_S
 010

	)
23 #define 
	#_P
 020

	)
24 #define 
	#_C
 040

	)
25 #define 
	#_B
 0100

	)
26 #define 
	#_X
 0200

	)
28 #if 
defined
(
__STDC__
)

30 extern int 
isalnum
(int);

31 extern int 
isalpha
(int);

32 extern int 
iscntrl
(int);

33 extern int 
isdigit
(int);

34 extern int 
isgraph
(int);

35 extern int 
islower
(int);

36 extern int 
isprint
(int);

37 extern int 
ispunct
(int);

38 extern int 
isspace
(int);

39 extern int 
isupper
(int);

40 extern int 
isxdigit
(int);

41 extern int 
tolower
(int);

42 extern int 
toupper
(int);

44 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 == 0 && \

45 !
defined
(
_POSIX_C_SOURCE
)) || defined(
_XOPEN_SOURCE
))

47 extern int 
isascii
(int);

48 extern int 
toascii
(int);

49 extern int 
_tolower
(int);

50 extern int 
_toupper
(int);

54 extern unsigned char 
__ctype
[];

64 #if !#lint(
on
) && !
defined
(
__lint
)

66 #define 
	#isalpha
(
c
) ((
__ctype
 + 1)[c] & (
_U
 | 
_L
))

	)
67 #define 
	#isupper
(
c
) ((
__ctype
 + 1)[c] & 
_U
)

	)
68 #define 
	#islower
(
c
) ((
__ctype
 + 1)[c] & 
_L
)

	)
69 #define 
	#isdigit
(
c
) ((
__ctype
 + 1)[c] & 
_N
)

	)
70 #define 
	#isxdigit
(
c
) ((
__ctype
 + 1)[c] & 
_X
)

	)
71 #define 
	#isalnum
(
c
) ((
__ctype
 + 1)[c] & (
_U
 | 
_L
 | 
_N
))

	)
72 #define 
	#isspace
(
c
) ((
__ctype
 + 1)[c] & 
_S
)

	)
73 #define 
	#ispunct
(
c
) ((
__ctype
 + 1)[c] & 
_P
)

	)
74 #define 
	#isprint
(
c
) ((
__ctype
 + 1)[c] & (
_P
 | 
_U
 | 
_L
 | 
_N
 | 
_B
))

	)
75 #define 
	#isgraph
(
c
) ((
__ctype
 + 1)[c] & (
_P
 | 
_U
 | 
_L
 | 
_N
))

	)
76 #define 
	#iscntrl
(
c
) ((
__ctype
 + 1)[c] & 
_C
)

	)
78 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 == 0 && \

79 !
defined
(
_POSIX_C_SOURCE
)) || defined(
_XOPEN_SOURCE
))

81 #define 
	#isascii
(
c
) (!((c) & ~0177))

	)
82 #define 
	#_toupper
(
c
) ((
__ctype
 + 258)[c])

	)
83 #define 
	#_tolower
(
c
) ((
__ctype
 + 258)[c])

	)
84 #define 
	#toascii
(
c
) ((c) & 0177)

	)
92 extern unsigned char 
_ctype
[];

94 #if !
defined
(
lint
) && !defined(
__lint
)

96 #define 
	#isalpha
(
c
) ((
_ctype
 + 1)[c] & (
_U
 | 
_L
))

	)
97 #define 
	#isupper
(
c
) ((
_ctype
 + 1)[c] & 
_U
)

	)
98 #define 
	#islower
(
c
) ((
_ctype
 + 1)[c] & 
_L
)

	)
99 #define 
	#isdigit
(
c
) ((
_ctype
 + 1)[c] & 
_N
)

	)
100 #define 
	#isxdigit
(
c
) ((
_ctype
 + 1)[c] & 
_X
)

	)
101 #define 
	#isalnum
(
c
) ((
_ctype
 + 1)[c] & (
_U
 | 
_L
 | 
_N
))

	)
102 #define 
	#isspace
(
c
) ((
_ctype
 + 1)[c] & 
_S
)

	)
103 #define 
	#ispunct
(
c
) ((
_ctype
 + 1)[c] & 
_P
)

	)
104 #define 
	#isprint
(
c
) ((
_ctype
 + 1)[c] & (
_P
 | 
_U
 | 
_L
 | 
_N
 | 
_B
))

	)
105 #define 
	#isgraph
(
c
) ((
_ctype
 + 1)[c] & (
_P
 | 
_U
 | 
_L
 | 
_N
))

	)
106 #define 
	#iscntrl
(
c
) ((
_ctype
 + 1)[c] & 
_C
)

	)
107 #define 
	#isascii
(
c
) (!((c) & ~0177))

	)
108 #define 
	#_toupper
(
c
) ((
_ctype
 + 258)[c])

	)
109 #define 
	#_tolower
(
c
) ((
_ctype
 + 258)[c])

	)
110 #define 
	#toascii
(
c
) ((c) & 0177)

	)
116 #ifdef 
__cplusplus


	@/usr/include/stdarg.h

13 #ifndef 
_STDARG_H


14 #define 
	#_STDARG_H


	)
16 #pragma 
ident
 "@(#)stdarg.h 1.38 96/01/26 SMI"

18 #if 
defined
(
__STDC__
)

20 #include 
	~<sys/va_list.h
>

22 #ifdef 
__cplusplus


32 #ifndef 
_VA_LIST


33 #define 
	#_VA_LIST


	)
34 typedef 
__va_list
 
	tva_list
;

54 #if (
defined
(
__BUILTIN_VA_ARG_INCR
) || defined(
sparc
) || defined(
__sparc
) || \

55 
defined
(
i386
) || defined(
__i386
)) && !(defined(
lint
) || 
	$defined
(
__lint
))

57 #if 
	`defined
(
__ppc
)

64 extern void 
	`__builtin_va_info
(
va_list
);

65 extern void *
	`__va_arg
(
va_list
, ...);

66 #define 
	#va_start
(
list
, 
name
) 
	`__builtin_va_info
(list)

	)
67 #define 
	#va_arg
(
list
, 
mode
) ((mode *)
	`__va_arg
(list, (mode *) 0))[0]

	)
75 #define 
	#va_start
(
list
, 
name
) (void) (list = (
va_list
) &
__builtin_va_alist
)

	)
76 #define 
	#va_arg
(
list
, 
mode
) ((mode *)
	`__builtin_va_arg_incr
((mode *)list))[0]

	)
82 #if 
	`defined
(
__ppc
)

91 #define 
	#va_start
(
list
, 
name
) (list[0].
__reg_save_area
 = (char *)&name)

	)
92 #define 
	#va_arg
(
list
, 
mode
) ((mode *)&(list))[0]

	)
102 #if 
__STDC__
 != 0

103 #define 
	#va_start
(
list
, 
name
) (void) (list = (void *)((char *)&name + \

104 ((sizeof (
name
) + (sizeof (int) - 1)) & ~(sizeof (int) - 1))))

	)
106 #define 
	#va_start
(
list
, 
name
) (void) (list = (void *)((char *)&...))

	)
108 #define 
	#va_arg
(
list
, 
mode
) \

109 ((
mode
 *)(
list
 = (void *)((char *)list + sizeof (mode))))[-1]

	)
115 extern void 
	`va_end
(
va_list
);

116 #define 
	#va_end
(
list
) (void)0

	)
122 #if 
	`defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

123 !
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
))

125 #if 
	`defined
(
__ppc
)

126 #define 
	#va_copy
(
to
, 
from
) ((to)[0] = (from)[0])

	)
128 #define 
	#va_copy
(
to
, 
from
) ((to) = (from))

	)
133 #ifdef 
__cplusplus


134 
	}
}

139 #include 
	~<varargs.h
>

	@/usr/include/stdio.h

12 #ifndef 
_STDIO_H


13 #define 
	#_STDIO_H


	)
15 #pragma 
ident
 "@(#)stdio.h 1.39 95/12/04 SMI"

17 #include 
	~<sys/feature_tests.h
>

18 #include 
	~<sys/va_list.h
>

20 #ifdef 
__cplusplus


24 #ifndef 
_SIZE_T


25 #define 
	#_SIZE_T


	)
26 typedef unsigned int 
	tsize_t
;

29 typedef long 
	tfpos_t
;

31 #ifndef 
NULL


32 #define 
	#NULL
 0

	)
35 #define 
	#BUFSIZ
 1024

	)
42 #if 
defined
(
_XOPEN_SOURCE
) && (
_XOPEN_VERSION
 - 0 == 4) && !defined(
_VA_LIST
)

43 #define 
	#_VA_LIST


	)
44 typedef 
__va_list
 
	tva_list
;

47 #ifdef 
__STDC__


61 #if #machine(
i386
) || 
defined
(
__i386
)

62 #define 
	#_NFILE
 60

	)
63 #elif #machine(
ppc
) || 
defined
(
__ppc
)

64 #define 
	#_NFILE
 20

	)
66 #define 
	#_NFILE
 20

	)
69 #if 
defined
(
i386
) || defined(
__i386
)

70 #define 
	#_NFILE
 60

	)
71 #elif 
defined
(
__ppc
)

72 #define 
	#_NFILE
 20

	)
74 #define 
	#_NFILE
 20

	)
78 #define 
	#_SBFSIZ
 8

	)
80 #define 
	#_IOFBF
 0000

	)
81 #define 
	#_IOLBF
 0100

	)
82 #define 
	#_IONBF
 0004

	)
83 #define 
	#_IOEOF
 0020

	)
84 #define 
	#_IOERR
 0040

	)
86 #define 
	#_IOREAD
 0001

	)
87 #define 
	#_IOWRT
 0002

	)
88 #define 
	#_IORW
 0200

	)
89 #define 
	#_IOMYBUF
 0010

	)
91 #ifndef 
EOF


92 #define 
	#EOF
 (-1)

	)
95 #define 
	#FOPEN_MAX
 
_NFILE


	)
96 #define 
	#FILENAME_MAX
 1024

	)
98 #define 
	#SEEK_SET
 0

	)
99 #define 
	#SEEK_CUR
 1

	)
100 #define 
	#SEEK_END
 2

	)
101 #define 
	#TMP_MAX
 17576

	)
103 #if 
defined
(
__EXTENSIONS__
) || 
__STDC__
 - 0 == 0 || \

104 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

106 #define 
	#L_ctermid
 9

	)
107 #define 
	#L_cuserid
 9

	)
110 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0 && \

111 !
defined
(
_POSIX_C_SOURCE
))) || defined(
_XOPEN_SOURCE
)

113 #define 
	#P_tmpdir
 "/var/tmp/"

	)
116 #define 
	#L_tmpnam
 25

	)
118 #if 
defined
(
__STDC__
)

119 #define 
	#stdin
 (&
__iob
[0])

	)
120 #define 
	#stdout
 (&
__iob
[1])

	)
121 #define 
	#stderr
 (&
__iob
[2])

	)
123 #define 
	#stdin
 (&
_iob
[0])

	)
124 #define 
	#stdout
 (&
_iob
[1])

	)
125 #define 
	#stderr
 (&
_iob
[2])

	)
129 
	s
{

130 #ifdef 
_STDIO_REVERSE


131 unsigned char *
	g_ptr
;

132 int 
	g_cnt
;

134 int 
	g_cnt
;

135 unsigned char *
	g_ptr
;

137 unsigned char *
	g_base
;

138 unsigned char 
	g_flag
;

139 unsigned char 
	g_file
;

140 } 
	tFILE
;

142 #if 
defined
(
__STDC__
)

143 extern 
FILE
 
__iob
[
_NFILE
];

145 extern 
FILE
 
_iob
[
_NFILE
];

147 extern 
FILE
 *
_lastbuf
;

148 extern unsigned char *
_bufendtab
[];

149 #ifndef 
_STDIO_ALLOCATE


150 extern unsigned char 
_sibuf
[], 
_sobuf
[];

153 #if 
defined
(
__STDC__
)

155 extern int 
remove
(const char *);

156 extern int 
rename
(const char *, const char *);

157 extern 
FILE
 *
tmpfile
(void);

158 extern char *
tmpnam
(char *);

159 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
)

160 extern char *
tmpnam_r
(char *);

162 extern int 
fclose
(
FILE
 *);

163 extern int 
fflush
(
FILE
 *);

164 extern 
FILE
 *
fopen
(const char *, const char *);

165 extern 
FILE
 *
freopen
(const char *, const char *, FILE *);

166 extern void 
setbuf
(
FILE
 *, char *);

167 extern int 
setvbuf
(
FILE
 *, char *, int, 
size_t
);

169 extern int 
fprintf
(
FILE
 *, const char *, ...);

171 extern int 
fscanf
(
FILE
 *, const char *, ...);

173 extern int 
printf
(const char *, ...);

175 extern int 
scanf
(const char *, ...);

177 extern int 
sprintf
(char *, const char *, ...);

179 extern int 
sscanf
(const char *, const char *, ...);

180 extern int 
vfprintf
(
FILE
 *, const char *, 
__va_list
);

181 extern int 
vprintf
(const char *, 
__va_list
);

182 extern int 
vsprintf
(char *, const char *, 
__va_list
);

183 extern int 
fgetc
(
FILE
 *);

184 extern char *
fgets
(char *, int, 
FILE
 *);

185 extern int 
fputc
(int, 
FILE
 *);

186 extern int 
fputs
(const char *, 
FILE
 *);

187 extern int 
getc
(
FILE
 *);

188 extern int 
getchar
(void);

189 extern char *
gets
(char *);

190 extern int 
putc
(int, 
FILE
 *);

191 extern int 
putchar
(int);

192 extern int 
puts
(const char *);

193 extern int 
ungetc
(int, 
FILE
 *);

194 extern 
size_t
 
fread
(void *, size_t, size_t, 
FILE
 *);

195 extern 
size_t
 
fwrite
(const void *, size_t, size_t, 
FILE
 *);

196 extern int 
fgetpos
(
FILE
 *, 
fpos_t
 *);

197 extern int 
fseek
(
FILE
 *, long, int);

198 extern int 
fsetpos
(
FILE
 *, const 
fpos_t
 *);

199 extern long 
ftell
(
FILE
 *);

200 extern void 
rewind
(
FILE
 *);

201 extern void 
clearerr
(
FILE
 *);

202 extern int 
feof
(
FILE
 *);

203 extern int 
ferror
(
FILE
 *);

204 extern void 
perror
(const char *);

206 extern int 
__filbuf
(
FILE
 *);

207 extern int 
__flsbuf
(int, 
FILE
 *);

212 #if 
defined
(
__EXTENSIONS__
) || 
__STDC__
 == 0 || \

213 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

215 extern 
FILE
 *
fdopen
(int, const char *);

216 extern char *
ctermid
(char *);

217 extern int 
fileno
(
FILE
 *);

224 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

225 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

226 extern void 
flockfile
(
FILE
 *);

227 extern int 
ftrylockfile
(
FILE
 *);

228 extern void 
funlockfile
(
FILE
 *);

229 extern int 
getc_unlocked
(
FILE
 *);

230 extern int 
getchar_unlocked
(void);

231 extern int 
putc_unlocked
(int, 
FILE
 *);

232 extern int 
putchar_unlocked
(int);

239 #if 
defined
(
__EXTENSIONS__
) || 
__STDC__
 == 0 || defined(
_XOPEN_SOURCE
)

241 extern 
FILE
 *
popen
(const char *, const char *);

242 extern char *
cuserid
(char *);

243 extern char *
tempnam
(const char *, const char *);

244 extern int 
getopt
(int, char *const *, const char *);

245 #if !
defined
(
_XOPEN_SOURCE
)

246 extern int 
getsubopt
(char **, char *const *, char **);

248 extern char *
optarg
;

249 extern int 
optind
, 
opterr
, 
optopt
;

250 extern int 
getw
(
FILE
 *);

251 extern int 
putw
(int, 
FILE
 *);

252 extern int 
pclose
(
FILE
 *);

258 #define 
	#_bufend
(
p
) ((
	`fileno
(p) < 
_NFILE
) ? 
_bufendtab
[(p)->
_file
] : \

259 (unsigned char *)
	`_realbufend
(
p
))

	)
260 #define 
	#_bufsiz
(
p
) (
	`_bufend
(p) - (p)->
_base
)

	)
262 extern int 
remove
();

263 extern int 
rename
();

264 extern 
FILE
 *
tmpfile
();

265 extern char *
tmpnam
();

266 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
)

267 extern char *
tmpnam_r
();

269 extern int 
fclose
();

270 extern int 
fflush
();

271 extern 
FILE
 *
fopen
();

272 extern 
FILE
 *
freopen
();

273 extern void 
setbuf
();

274 extern int 
setvbuf
();

275 extern int 
fprintf
();

276 extern int 
fscanf
();

277 extern int 
printf
();

278 extern int 
scanf
();

279 extern int 
sprintf
();

280 extern int 
sscanf
();

281 extern int 
vfprintf
();

282 extern int 
vprintf
();

283 extern int 
vsprintf
();

284 extern int 
fgetc
();

285 extern char *
fgets
();

286 extern int 
fputc
();

287 extern int 
fputs
();

288 extern int 
getc
();

289 extern int 
getchar
();

290 extern char *
gets
();

291 extern int 
putc
();

292 extern int 
putchar
();

293 extern int 
puts
();

294 extern int 
ungetc
();

295 extern 
size_t
 
fread
();

296 extern 
size_t
 
fwrite
();

297 extern int 
fgetpos
();

298 extern int 
fseek
();

299 extern int 
fsetpos
();

300 extern long 
ftell
();

301 extern void 
rewind
();

302 extern void 
clearerr
();

303 extern int 
feof
();

304 extern int 
ferror
();

305 extern void 
perror
();

307 extern int 
_filbuf
();

308 extern int 
_flsbuf
();

310 extern 
FILE
 *
fdopen
();

311 extern char *
ctermid
();

312 extern int 
fileno
();

314 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

315 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

316 extern void 
flockfile
();

317 extern int 
ftrylockfile
();

318 extern void 
funlockfile
();

319 extern int 
getc_unlocked
();

320 extern int 
getchar_unlocked
();

321 extern int 
putc_unlocked
();

322 extern int 
putchar_unlocked
();

325 extern 
FILE
 *
popen
();

326 extern char *
cuserid
();

327 extern char *
tempnam
();

328 extern int 
getopt
();

329 #if !
defined
(
_XOPEN_SOURCE
)

330 extern int 
getsubopt
();

332 extern char *
optarg
;

333 extern int 
optind
, 
opterr
, 
optopt
;

334 extern int 
getw
();

335 extern int 
putw
();

336 extern int 
pclose
();

348 #if !
defined
(
lint
) && !defined(
__lint
)

350 #ifndef 
_REENTRANT


351 #ifdef 
__STDC__


352 #define 
	#getc
(
p
) (--(p)->
_cnt
 < 0 ? 
	`__filbuf
(p) : (int)*(p)->
_ptr
++)

	)
353 #define 
	#putc
(
x
, 
p
) (--(p)->
_cnt
 < 0 ? 
	`__flsbuf
((unsigned char) (x), (p)) \

354 : (int)(*(
p
)->
_ptr
++ = (
x
)))

	)
356 #define 
	#getc
(
p
) (--(p)->
_cnt
 < 0 ? 
	`_filbuf
(p) : (int) *(p)->
_ptr
++)

	)
357 #define 
	#putc
(
x
, 
p
) (--(p)->
_cnt
 < 0 ? \

358 
	`_flsbuf
((unsigned char) (
x
), (
p
)) : \

359 (int) (*(
p
)->
_ptr
++ = (unsigned char) (
x
)))

	)
361 #define 
	#getchar
() 
	`getc
(
stdin
)

	)
362 #define 
	#putchar
(
x
) 
	`putc
((x), 
stdout
)

	)
363 #define 
	#clearerr
(
p
) ((void)((p)->
_flag
 &= ~(
_IOERR
 | 
_IOEOF
)))

	)
364 #define 
	#feof
(
p
) ((p)->
_flag
 & 
_IOEOF
)

	)
365 #define 
	#ferror
(
p
) ((p)->
_flag
 & 
_IOERR
)

	)
368 #if 
defined
(
__EXTENSIONS__
) || (
__STDC__
 -0 == 0) || \

369 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

370 #define 
	#fileno
(
p
) ((p)->
_file
)

	)
373 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

374 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

375 #ifdef 
__STDC__


376 #define 
	#getc_unlocked
(
p
) (--(p)->
_cnt
 < 0 \

377 ? 
	`__filbuf
(
p
) \

378 : (int)*(
p
)->
_ptr
++)

	)
379 #define 
	#putc_unlocked
(
x
, 
p
) (--(p)->
_cnt
 < 0 \

380 ? 
	`__flsbuf
((unsigned char) (
x
), (
p
)) \

381 : (int)(*(
p
)->
_ptr
++ = (
x
)))

	)
383 #define 
	#getc_unlocked
(
p
) (--(p)->
_cnt
 < 0 \

384 ? 
	`_filbuf
(
p
) \

385 : (int)*(
p
)->
_ptr
++)

	)
386 #define 
	#putc_unlocked
(
x
, 
p
) (--(p)->
_cnt
 < 0 \

387 ? 
	`_flsbuf
((unsigned char) (
x
), (
p
)) \

388 : (int)(*(
p
)->
_ptr
++ = (
x
)))

	)
390 #define 
	#getchar_unlocked
() 
	`getc_unlocked
(
stdin
)

	)
391 #define 
	#putchar_unlocked
(
x
) 
	`putc_unlocked
((x), 
stdout
)

	)
396 #ifdef 
__cplusplus


	@/usr/include/stdlib.h

8 #ifndef 
_STDLIB_H


9 #define 
	#_STDLIB_H


	)
11 #pragma 
ident
 "@(#)stdlib.h 1.27 95/08/28 SMI"

13 #include 
	~<sys/feature_tests.h
>

15 #if 
defined
(
__EXTENSIONS__
) || \

16 (
defined
(
_XOPEN_SOURCE
) && (
	g_XOPEN_VERSION
 - 0 == 4))

17 #include 
	~<sys/wait.h
>

20 #ifdef 
__cplusplus


24 typedef struct 
	s
{

25 int 
quot
;

26 int 
rem
;

27 } 
	tdiv_t
;

29 typedef struct 
	s
{

30 long 
quot
;

31 long 
rem
;

32 } 
	tldiv_t
;

34 #if 
__STDC__
 - 0 == 0 && !
defined
(
_NO_LONGLONG
)

35 typedef struct 
	s
{

36 long long 
quot
;

37 long long 
rem
;

38 } 
	tlldiv_t
;

41 #ifndef 
_SIZE_T


42 #define 
	#_SIZE_T


	)
43 typedef unsigned int 
	tsize_t
;

46 #ifndef 
_UID_T


47 #define 
	#_UID_T


	)
48 typedef long 
	tuid_t
;

51 #ifndef 
NULL


52 #define 
	#NULL
 0

	)
55 #define 
	#EXIT_FAILURE
 1

	)
56 #define 
	#EXIT_SUCCESS
 0

	)
57 #define 
	#RAND_MAX
 32767

	)
59 #ifndef 
_WCHAR_T


60 #define 
	#_WCHAR_T


	)
61 typedef long 
	twchar_t
;

64 #if 
defined
(
__STDC__
)

66 extern unsigned char 
__ctype
[];

68 #define 
	#MB_CUR_MAX
 
__ctype
[520]

	)
70 extern double 
atof
(const char *);

71 extern int 
atoi
(const char *);

72 extern long int 
atol
(const char *);

73 extern double 
strtod
(const char *, char **);

74 extern long int 
strtol
(const char *, char **, int);

75 extern unsigned long int 
strtoul
(const char *, char **, int);

77 extern int 
rand
(void);

78 extern void 
srand
(unsigned int);

79 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

80 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

81 extern int 
rand_r
(unsigned int *);

84 extern void *
calloc
(
size_t
, size_t);

85 extern void 
free
(void *);

86 extern void *
malloc
(
size_t
);

87 extern void *
realloc
(void *, 
size_t
);

89 extern void 
abort
(void);

90 extern int 
atexit
(void (*)(void));

91 extern void 
exit
(int);

92 extern char *
getenv
(const char *);

93 extern int 
system
(const char *);

95 extern void *
bsearch
(const void *, const void *, 
size_t
, size_t,

97 extern void 
qsort
(void *, 
size_t
, size_t,

100 extern int 
abs
(int);

101 extern 
div_t
 
div
(int, int);

102 extern long int 
labs
(long);

103 extern 
ldiv_t
 
ldiv
(long, long);

105 extern int 
mbtowc
(
wchar_t
 *, const char *, 
size_t
);

106 extern int 
mblen
(const char *, 
size_t
);

107 extern int 
wctomb
(char *, 
wchar_t
);

109 extern 
size_t
 
mbstowcs
(
wchar_t
 *, const char *, size_t);

110 extern 
size_t
 
wcstombs
(char *, const 
wchar_t
 *, size_t);

112 #if 
defined
(
__EXTENSIONS__
) || \

113 (
	g__STDC__
 == 0 && !
defined
(
_POSIX_C_SOURCE
)) || \

114 (
defined
(
_XOPEN_SOURCE
) && (
_XOPEN_VERSION
 - 0 == 4))

116 extern double 
drand48
(void);

117 extern double 
erand48
(unsigned short *);

118 extern long 
jrand48
(unsigned short *);

119 extern void 
lcong48
(unsigned short *);

120 extern long 
lrand48
(void);

121 extern long 
mrand48
(void);

122 extern long 
nrand48
(unsigned short *);

123 extern unsigned short *
seed48
(unsigned short *);

124 extern void 
srand48
(long);

125 extern int 
putenv
(const char *);

126 extern void 
setkey
(const char *);

130 #if (
defined
(
__EXTENSIONS__
) || \

131 (
	g__STDC__
 == 0 && !
defined
(
_POSIX_C_SOURCE
))) && \

132 (
_XOPEN_VERSION
 - 0 < 4)

133 extern void 
swab
(const char *, char *, int);

136 #if 
defined
(
__EXTENSIONS__
) || \

137 (
	g__STDC__
 == 0 && !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
))

139 extern long 
a64l
(const char *);

140 extern int 
dup2
(int, int);

141 extern char *
ecvt
(double, int, int *, int *);

142 extern char *
fcvt
(double, int, int *, int *);

143 extern char *
qecvt
(long double, int, int *, int *);

144 extern char *
qfcvt
(long double, int, int *, int *);

145 extern char *
qgcvt
(long double, int, char *);

146 extern char *
getcwd
(char *, 
size_t
);

147 extern char *
getlogin
(void);

148 extern int 
getopt
(int, char *const *, const char *);

149 extern int 
getsubopt
(char **, char *const *, char **);

150 extern char *
optarg
;

151 extern int 
optind
, 
opterr
, 
optopt
;

152 extern char *
getpass
(const char *);

153 extern int 
getpw
(
uid_t
, char *);

154 extern char *
gcvt
(double, int, char *);

155 extern int 
isatty
(int);

156 extern char *
l64a
(long);

157 extern void *
memalign
(
size_t
, size_t);

158 extern char *
mktemp
(char *);

159 extern char *
realpath
(char *, char *);

160 extern char *
ttyname
(int);

161 extern int 
ttyslot
(void);

162 extern void *
valloc
(
size_t
);

163 extern char *
ptsname
(int);

164 extern int 
grantpt
(int);

165 extern int 
unlockpt
(int);

167 #if 
__STDC__
 - 0 == 0 && !
defined
(
_NO_LONGLONG
)

168 extern long long 
atoll
(const char *);

169 extern long long 
llabs
(long long);

170 extern 
lldiv_t
 
lldiv
(long long, long long);

171 extern char *
lltostr
(long long, char *);

172 extern long long 
strtoll
(const char *, char **, int);

173 extern unsigned long long 
strtoull
(const char *, char **, int);

174 extern char *
ulltostr
(unsigned long long, char *);

181 extern unsigned char 
_ctype
[];

183 #define 
	#MB_CUR_MAX
 
_ctype
[520]

	)
185 extern double 
atof
();

186 extern int 
atoi
();

187 extern long int 
atol
();

188 extern double 
strtod
();

189 extern long int 
strtol
();

190 extern unsigned long 
strtoul
();

192 extern int 
rand
();

193 extern void 
srand
();

194 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

195 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

196 extern int 
rand_r
();

199 extern void *
calloc
();

200 extern void 
free
();

201 extern void *
malloc
();

202 extern void *
realloc
();

204 extern void 
abort
();

205 extern int 
atexit
();

206 extern void 
exit
();

207 extern char *
getenv
();

208 extern int 
system
();

210 extern void *
bsearch
();

211 extern void 
qsort
();

213 extern int 
abs
();

214 extern 
div_t
 
div
();

215 extern long int 
labs
();

216 extern 
ldiv_t
 
ldiv
();

218 extern int 
mbtowc
();

219 extern int 
mblen
();

220 extern int 
wctomb
();

222 extern 
size_t
 
mbstowcs
();

223 extern 
size_t
 
wcstombs
();

225 extern long 
a64l
();

226 extern int 
dup2
();

227 extern char *
ecvt
();

228 extern char *
fcvt
();

229 extern char *
qecvt
();

230 extern char *
qfcvt
();

231 extern char *
qgcvt
();

232 extern char *
getcwd
();

233 extern char *
getlogin
();

234 extern int 
getopt
();

235 extern int 
getsubopt
();

236 extern char *
optarg
;

237 extern int 
optind
, 
opterr
, 
optopt
;

238 extern char *
getpass
();

239 extern int 
getpw
();

240 extern char *
gcvt
();

241 extern int 
isatty
();

242 extern char *
l64a
();

243 extern void *
memalign
();

244 extern char *
mktemp
();

245 extern int 
putenv
();

246 extern char *
realpath
();

247 extern void 
setkey
();

248 extern void 
swab
();

249 extern char *
ttyname
();

250 extern int 
ttyslot
();

251 extern void *
valloc
();

252 extern char *
ptsname
();

253 extern int 
grantpt
();

254 extern int 
unlockpt
();

256 extern double 
drand48
();

257 extern double 
erand48
();

258 extern long 
jrand48
();

259 extern void 
lcong48
();

260 extern long 
lrand48
();

261 extern long 
mrand48
();

262 extern long 
nrand48
();

263 extern unsigned short *
seed48
();

264 extern void 
srand48
();

266 #if !
defined
(
_NO_LONGLONG
)

267 extern long long 
atoll
();

268 extern long long 
llabs
();

269 extern 
lldiv_t
 
lldiv
();

270 extern char *
lltostr
();

271 extern long long 
strtoll
();

272 extern unsigned long long 
strtoull
();

273 extern char *
ulltostr
();

278 #ifdef 
__cplusplus


	@/usr/include/string.h

8 #ifndef 
_STRING_H


9 #define 
	#_STRING_H


	)
11 #pragma 
ident
 "@(#)string.h 1.17 95/08/28 SMI"

13 #include 
	~<sys/feature_tests.h
>

15 #ifdef 
__cplusplus


19 #ifndef 
_SIZE_T


20 #define 
	#_SIZE_T


	)
21 typedef unsigned int 
	tsize_t
;

24 #ifndef 
NULL


25 #define 
	#NULL
 0

	)
28 #if 
defined
(
__STDC__
)

30 extern void *
memcpy
(void *, const void *, 
size_t
);

31 extern void *
memmove
(void *, const void *, 
size_t
);

32 extern char *
strcpy
(char *, const char *);

33 extern char *
strncpy
(char *, const char *, 
size_t
);

35 extern char *
strcat
(char *, const char *);

36 extern char *
strncat
(char *, const char *, 
size_t
);

38 extern int 
memcmp
(const void *, const void *, 
size_t
);

39 extern int 
strcmp
(const char *, const char *);

40 extern int 
strcoll
(const char *, const char *);

41 extern int 
strncmp
(const char *, const char *, 
size_t
);

42 extern 
size_t
 
strxfrm
(char *, const char *, size_t);

44 extern void *
memchr
(const void *, int, 
size_t
);

45 extern char *
strchr
(const char *, int);

46 extern 
size_t
 
strcspn
(const char *, const char *);

47 extern char *
strpbrk
(const char *, const char *);

48 extern char *
strrchr
(const char *, int);

49 extern 
size_t
 
strspn
(const char *, const char *);

50 extern char *
strstr
(const char *, const char *);

51 extern char *
strtok
(char *, const char *);

52 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

53 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

54 extern char *
strtok_r
(char *, const char *, char **);

56 extern void *
memset
(void *, int, 
size_t
);

57 extern char *
strerror
(int);

58 extern 
size_t
 
strlen
(const char *);

60 #if 
defined
(
__EXTENSIONS__
) || 
__STDC__
 == 0 || \

61 
defined
(
_POSIX_C_SOURCE
) || 
	$defined
(
_XOPEN_SOURCE
)

63 extern void *
	`memccpy
(void *, const void *, int, 
size_t
);

67 #if 
	`defined
(
__EXTENSIONS__
) || (
__STDC__
 == 0 && \

68 !
	`defined
(
_POSIX_C_SOURCE
) && !
	$defined
(
_XOPEN_SOURCE
))

70 extern char *
	`strdup
(const char *);

71 extern char *
	`strsignal
(int);

72 extern int 
	`ffs
(const int);

73 extern int 
	`strcasecmp
(const char *, const char *);

74 extern int 
	`strncasecmp
(const char *, const char *, 
size_t
);

81 *
	`strcpy
(),

82 *
	`strncpy
(),

83 *
	`strcat
(),

84 *
	`strncat
(),

85 *
	`strchr
(),

86 *
	`strrchr
(),

87 *
	`strpbrk
(),

88 *
	`strtok
(),

89 #if 
	`defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

90 (
_POSIX_C_SOURCE
 - 0 >= 199506L)

91 *
	`strtok_r
(),

93 *
	`strstr
();

95 
	`strcmp
(),

96 
	`strncmp
();

97 extern 
size_t


98 
	`strlen
(),

99 
	`strspn
(),

100 
	`strcspn
();

102 *
	`memccpy
(),

103 *
	`memchr
(),

104 *
	`memcpy
(),

105 *
	`memmove
(),

106 *
	`memset
();

107 extern int 
	`memcmp
();

109 #if !
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

111 *
	`strdup
(),

112 *
	`strsignal
();

114 
	`ffs
(),

115 
	`strcasecmp
(),

116 
	`strncasecmp
();

121 #ifdef 
__cplusplus


122 
	}
}

	@/usr/include/sys/feature_tests.h

8 #ifndef 
_SYS_FEATURE_TESTS_H


9 #define 
	#_SYS_FEATURE_TESTS_H


	)
11 #pragma 
ident
 "@(#)feature_tests.h 1.7 94/12/06 SMI"

13 #ifdef 
__cplusplus


25 #if 
defined
(
_POSIX_SOURCE
) && !defined(
_POSIX_C_SOURCE
)

26 #define 
	#_POSIX_C_SOURCE
 1

	)
29 #ifdef 
__cplusplus


	@/usr/include/sys/va_list.h

6 #ifndef 
_SYS_VA_LIST_H


7 #define 
	#_SYS_VA_LIST_H


	)
9 #pragma 
ident
 "@(#)va_list.h 1.6 96/01/26 SMI"

21 #ifdef 
__cplusplus


25 #if 
defined
(
__ppc
)

27 typedef struct 
	s__va_list_tag
 {

28 char 
__gpr
;

31 char 
__fpr
;

34 char *
__input_arg_area
;

37 char *
__reg_save_area
;

39 } 
	t__va_list
[1];

43 #ifdef 
__STDC__


44 typedef void *
	t__va_list
;

46 typedef char *
	t__va_list
;

51 #ifdef 
__cplusplus


	@/usr/include/sys/wait.h

8 #ifndef 
_SYS_WAIT_H


9 #define 
	#_SYS_WAIT_H


	)
11 #pragma 
ident
 "@(#)wait.h 1.15 94/11/05 SMI"

13 #include 
	~<sys/feature_tests.h
>

15 #include 
	~<sys/types.h
>

17 #if !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

18 #include 
	~<sys/siginfo.h
>

19 #include 
	~<sys/procset.h
>

22 #ifdef 
__cplusplus


30 #define 
	#WUNTRACED
 0004

	)
31 #define 
	#WNOHANG
 0100

	)
33 #if !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

35 #define 
	#WEXITED
 0001

	)
36 #define 
	#WTRAPPED
 0002

	)
37 #define 
	#WSTOPPED
 
WUNTRACED


	)
38 #define 
	#WCONTINUED
 0010

	)
39 #define 
	#WNOWAIT
 0200

	)
41 #define 
	#WOPTMASK
 (
WEXITED
|
WTRAPPED
|
WSTOPPED
|
WCONTINUED
|
WNOHANG
|
WNOWAIT
)

	)
49 #if !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

51 #define 
	#WSTOPFLG
 0177

	)
52 #define 
	#WCONTFLG
 0177777

	)
53 #define 
	#WCOREFLG
 0200

	)
54 #define 
	#WSIGMASK
 0177

	)
56 #define 
	#WLOBYTE
(
stat
) ((int)((stat)&0377))

	)
57 #define 
	#WHIBYTE
(
stat
) ((int)(((stat)>>8)&0377))

	)
58 #define 
	#WWORD
(
stat
) ((int)((stat))&0177777)

	)
60 #define 
	#WIFCONTINUED
(
stat
) (
	`WWORD
(stat) == 
WCONTFLG
)

	)
61 #define 
	#WCOREDUMP
(
stat
) ((stat)&
WCOREFLG
)

	)
65 #define 
	#WIFEXITED
(
stat
) ((int)((stat)&0xFF) == 0)

	)
66 #define 
	#WIFSIGNALED
(
stat
) ((int)((stat)&0xFF) > 0 && \

67 (int)((
stat
)&0xFF00) == 0)

	)
68 #define 
	#WIFSTOPPED
(
stat
) ((int)((stat)&0xFF) == 0177 && \

69 (int)((
stat
)&0xFF00) != 0)

	)
70 #define 
	#WEXITSTATUS
(
stat
) ((int)(((stat)>>8)&0xFF))

	)
71 #define 
	#WTERMSIG
(
stat
) ((int)((stat)&0x7F))

	)
72 #define 
	#WSTOPSIG
(
stat
) ((int)(((stat)>>8)&0xFF))

	)
76 #if !
defined
(
_KERNEL
)

77 #if 
defined
(
__STDC__
)

79 extern 
pid_t
 
wait
(int *);

80 extern 
pid_t
 
waitpid
(pid_t, int *, int);

81 #if !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

82 extern int 
waitid
(
idtype_t
, 
id_t
, 
siginfo_t
 *, int);

87 extern 
pid_t
 
wait
();

88 extern 
pid_t
 
waitpid
();

89 #if !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

90 extern int 
waitid
();

96 #ifdef 
__cplusplus


	@/usr/include/varargs.h

13 #ifndef 
_VARARGS_H


14 #define 
	#_VARARGS_H


	)
16 #pragma 
ident
 "@(#)varargs.h 1.37 96/01/30 SMI"

18 #include 
	~<sys/va_list.h
>

20 #ifdef 
__cplusplus


31 #ifndef 
_VA_LIST


32 #define 
	#_VA_LIST


	)
33 typedef 
__va_list
 
	tva_list
;

54 #if (
defined
(
__BUILTIN_VA_ARG_INCR
) || defined(
sparc
) || defined(
__sparc
) || \

55 
defined
(
i386
) || 
	$defined
(
__i386
))

56 #define 
	#va_alist
 
__builtin_va_alist


	)
58 #define 
	#va_dcl
 int 
va_alist
;

	)
60 #if (
	`defined
(
__BUILTIN_VA_ARG_INCR
) || defined(
sparc
) || defined(
__sparc
) || \

61 
	`defined
(
i386
) || defined(
__i386
)) && !(defined(
lint
) || 
	$defined
(
__lint
))

63 #if 
	`defined
(
__ppc
)

70 extern void 
	`__builtin_va_info
(
va_list
);

71 extern void *
	`__va_arg
(
va_list
, ...);

72 #define 
	#va_start
(
list
) 
	`__builtin_va_info
(list)

	)
73 #define 
	#va_arg
(
list
, 
mode
) ((mode *)
	`__va_arg
(list, (mode *) 0))[0]

	)
81 #define 
	#va_start
(
list
) list = (char *) &
va_alist


	)
82 #define 
	#va_arg
(
list
, 
mode
) ((mode *)
	`__builtin_va_arg_incr
((mode *)list))[0]

	)
88 #if 
	`defined
(
__ppc
)

96 #define 
	#va_start
(
list
) (list[0].
__reg_save_area
 = (char *)&
va_alist
)

	)
97 #define 
	#va_arg
(
list
, 
mode
) ((mode *)&(list))[0]

	)
106 #define 
	#va_start
(
list
) list = (char *) &
va_alist


	)
107 #define 
	#va_arg
(
list
, 
mode
) \

108 ((
mode
 *)(
list
 = (void *)((char *)list + sizeof (mode))))[-1]

	)
114 #define 
	#va_end
(
list
)

	)
120 #if 
	`defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

121 !
	`defined
(
_POSIX_C_SOURCE
) && !
	$defined
(
_XOPEN_SOURCE
))

123 #if 
	`defined
(
__ppc
)

124 #define 
	#va_copy
(
to
, 
from
) ((to)[0] = (from)[0])

	)
126 #define 
	#va_copy
(
to
, 
from
) ((to) = (from))

	)
131 #ifdef 
__cplusplus


132 
	}
}

	@/usr/include/sys/procset.h

8 #ifndef 
_SYS_PROCSET_H


9 #define 
	#_SYS_PROCSET_H


	)
11 #pragma 
ident
 "@(#)procset.h 1.15 93/05/05 SMI"

13 #ifdef 
__cplusplus


23 #define 
	#P_INITPID
 1

	)
24 #define 
	#P_INITUID
 0

	)
25 #define 
	#P_INITPGID
 0

	)
33 typedef enum 
	eidtype
 {

34 
P_PID
,

35 
P_PPID
,

36 
P_PGID
,

38 
P_SID
,

39 
P_CID
,

40 
P_UID
,

41 
P_GID
,

42 
P_ALL
,

43 
P_LWPID


44 } 
	tidtype_t
;

52 typedef enum 
	eidop
 {

53 
POP_DIFF
,

56 
POP_AND
,

59 
POP_OR
,

62 
POP_XOR


65 } 
	tidop_t
;

73 typedef struct 
	sprocset
 {

74 
idop_t
 
p_op
;

79 
idtype_t
 
p_lidtype
;

82 
id_t
 
p_lid
;

84 
idtype_t
 
p_ridtype
;

87 
id_t
 
p_rid
;

88 } 
	tprocset_t
;

95 #define 
	#setprocset
(
psp
, 
op
, 
ltype
, 
lid
, 
rtype
, 
rid
) \

96 (
psp
)->
p_op
 = (
op
); \

97 (
psp
)->
p_lidtype
 = (
ltype
); \

98 (
psp
)->
p_lid
 = (
lid
); \

99 (
psp
)->
p_ridtype
 = (
rtype
); \

100 (
psp
)->
p_rid
 = (
rid
);

	)
102 #ifdef 
_KERNEL


107 #if 
defined
(
__STDC__
)

108 #include 
	~<sys/proc.h
>

109 extern int 
dotoprocs
(
procset_t
 *
psp
, int (*
funcp
)(), char *
arg
);

110 extern int 
dotolwp
(
procset_t
 *
psp
, int (*
funcp
)(), char *
arg
);

111 extern int 
procinset
(
proc_t
 *
pp
, 
procset_t
 *
psp
);

112 extern int 
sigsendproc
(
proc_t
 *, 
sigsend_t
 *);

113 extern int 
sigsendset
(
procset_t
 *, 
sigsend_t
 *);

114 extern 
boolean_t
 
cur_inset_only
(
procset_t
 *
psp
);

118 extern int 
dotoprocs
();

119 extern int 
dotolwp
();

120 extern int 
procinset
();

121 extern int 
sigsendproc
();

122 extern int 
sigsendset
();

123 extern 
boolean_t
 
cur_inset_only
();

129 #ifdef 
__cplusplus


	@/usr/include/sys/siginfo.h

11 #ifndef 
_SYS_SIGINFO_H


12 #define 
	#_SYS_SIGINFO_H


	)
14 #pragma 
ident
 "@(#)siginfo.h 1.36 95/08/24 SMI"

16 #include 
	~<sys/feature_tests.h
>

18 #ifdef 
__cplusplus


22 #if !
defined
(
_POSIX_C_SOURCE
) || (_POSIX_C_SOURCE > 2) || \

23 
	$defined
(
__EXTENSIONS__
)

24 union 
	usigval
 {

25 int 
sival_int
;

26 void *
sival_ptr
;

29 struct 
	ssigevent
 {

30 int 
sigev_notify
;

31 union 
	u
{

32 int 
_sigev_signo
;

33 void (*
_sigev_notify_function
)(union 
sigval
);

34 } 
_sigev_un
;

35 union 
sigval
 
sigev_value
;

36 int 
_sigev_pad1
;

37 void *
_sigev_notify_attributes
;

38 int 
_sigev_pad2
;

40 #define 
	#sigev_signo
 
_sigev_un
.
_sigev_signo


	)
43 #define 
	#SIGEV_NONE
 1

	)
44 #define 
	#SIGEV_SIGNAL
 2

	)
45 #define 
	#SIGEV_THREAD
 3

	)
52 #define 
	#SI_FROMUSER
(
sip
) ((sip)->
si_code
 <= 0)

	)
53 #define 
	#SI_FROMKERNEL
(
sip
) ((sip)->
si_code
 > 0)

	)
55 #define 
	#SI_NOINFO
 32767

	)
56 #define 
	#SI_USER
 0

	)
57 #define 
	#SI_LWP
 (-1)

	)
58 #define 
	#SI_QUEUE
 (-2)

	)
59 #define 
	#SI_TIMER
 (-3)

	)
60 #define 
	#SI_ASYNCIO
 (-4)

	)
61 #define 
	#SI_MESGQ
 (-5)

	)
64 #if !
	`defined
(
_POSIX_C_SOURCE
) || defined(
__EXTENSIONS__
)

71 #include 
	~<sys/machsig.h
>

77 #define 
	#TRAP_BRKPT
 1

	)
78 #define 
	#TRAP_TRACE
 2

	)
79 #define 
	#NSIGTRAP
 2

	)
85 #define 
	#CLD_EXITED
 1

	)
86 #define 
	#CLD_KILLED
 2

	)
87 #define 
	#CLD_DUMPED
 3

	)
88 #define 
	#CLD_TRAPPED
 4

	)
89 #define 
	#CLD_STOPPED
 5

	)
90 #define 
	#CLD_CONTINUED
 6

	)
91 #define 
	#NSIGCLD
 6

	)
97 #define 
	#POLL_IN
 1

	)
98 #define 
	#POLL_OUT
 2

	)
99 #define 
	#POLL_MSG
 3

	)
100 #define 
	#POLL_ERR
 4

	)
101 #define 
	#POLL_PRI
 5

	)
102 #define 
	#POLL_HUP
 6

	)
103 #define 
	#NSIGPOLL
 6

	)
109 #define 
	#PROF_SIG
 1

	)
110 #define 
	#NSIGPROF
 1

	)
114 #if !
	`defined
(
_POSIX_C_SOURCE
) || (_POSIX_C_SOURCE > 2) || \

115 
	$defined
(
__EXTENSIONS__
)

118 #define 
	#SI_MAXSZ
 128

	)
119 #define 
	#SI_PAD
 ((
SI_MAXSZ
 / sizeof (int)) - 3)

	)
124 #include 
	~<sys/time.h
>

127 #if !
	`defined
(
	t_POSIX_C_SOURCE
)

129 
	tsiginfo


133 int 
si_signo
;

134 int 
si_code
;

135 int 
si_errno
;

137 union 
	u
{

139 int 
_pad
[
SI_PAD
];

141 struct 
	s
{

142 
pid_t
 
_pid
;

143 union 
	u
{

144 struct 
	s
{

145 
uid_t
 
_uid
;

146 union 
sigval
 
_value
;

147 } 
_kill
;

148 struct 
	s
{

149 
clock_t
 
_utime
;

150 int 
_status
;

151 
clock_t
 
_stime
;

152 } 
_cld
;

153 } 
_pdata
;

154 } 
_proc
;

156 struct 
	s
{

157 
caddr_t
 
_addr
;

158 int 
_trapno
;

159 } 
_fault
;

161 struct 
	s
{

163 int 
_fd
;

164 long 
_band
;

165 } 
_file
;

167 struct 
	s
{

168 
caddr_t
 
_faddr
;

169 
timestruc_t
 
_tstamp
;

170 short 
_syscall
;

171 char 
_nsysarg
;

172 char 
_fault
;

173 long 
_sysarg
[8];

174 long 
_mstate
[17];

175 } 
_prof
;

177 } 
_data
;

179 
	}
} 
	tsiginfo_t
;

186 #if !
defined
(
_POSIX_C_SOURCE
)

188 typedef struct 
	sk_siginfo
 {

190 int 
	msi_signo
;

191 int 
	msi_code
;

192 int 
	msi_errno
;

194 union 
	u
{

195 struct 
	s
{

196 
pid_t
 
	m_pid
;

197 union 
	u
{

198 struct 
	s
{

199 
uid_t
 
	m_uid
;

200 union 
sigval
 
	m_value
;

201 } 
	m_kill
;

202 struct 
	s
{

203 
clock_t
 
	m_utime
;

204 int 
	m_status
;

205 
clock_t
 
	m_stime
;

206 } 
	m_cld
;

207 } 
	m_pdata
;

208 } 
	m_proc
;

210 struct 
	s
{

211 
caddr_t
 
	m_addr
;

212 int 
	m_trapno
;

213 } 
	m_fault
;

215 struct 
	s
{

217 int 
	m_fd
;

218 long 
	m_band
;

219 } 
	m_file
;

221 struct 
	s
{

222 
caddr_t
 
	m_faddr
;

223 
timestruc_t
 
	m_tstamp
;

224 short 
	m_syscall
;

225 char 
	m_nsysarg
;

226 char 
	m_fault
;

230 } 
	m_prof
;

232 } 
	m_data
;

234 } 
	tk_siginfo_t
;

236 typedef struct 
	ssigqueue
 {

237 struct 
sigqueue
 *
	msq_next
;

238 
k_siginfo_t
 
	msq_info
;

239 void (*
	msq_func
)(struct 
	msigqueue
 *);

240 void *
	msq_backptr
;

242 } 
	tsigqueue_t
;

245 #define 
	#SI_CANQUEUE
(
c
) ((c) <= 
SI_QUEUE
)

	)
249 #define 
	#si_pid
 
_data
.
_proc
.
_pid


	)
250 #define 
	#si_status
 
_data
.
_proc
.
_pdata
.
_cld
.
_status


	)
251 #define 
	#si_stime
 
_data
.
_proc
.
_pdata
.
_cld
.
_stime


	)
252 #define 
	#si_utime
 
_data
.
_proc
.
_pdata
.
_cld
.
_utime


	)
253 #define 
	#si_uid
 
_data
.
_proc
.
_pdata
.
_kill
.
_uid


	)
254 #define 
	#si_value
 
_data
.
_proc
.
_pdata
.
_kill
.
_value


	)
255 #define 
	#si_addr
 
_data
.
_fault
.
_addr


	)
256 #define 
	#si_trapno
 
_data
.
_fault
.
_trapno


	)
257 #define 
	#si_fd
 
_data
.
_file
.
_fd


	)
258 #define 
	#si_band
 
_data
.
_file
.
_band


	)
260 #define 
	#si_tstamp
 
_data
.
_prof
.
_tstamp


	)
261 #define 
	#si_syscall
 
_data
.
_prof
.
_syscall


	)
262 #define 
	#si_nsysarg
 
_data
.
_prof
.
_nsysarg


	)
263 #define 
	#si_sysarg
 
_data
.
_prof
.
_sysarg


	)
264 #define 
	#si_fault
 
_data
.
_prof
.
_fault


	)
265 #define 
	#si_faddr
 
_data
.
_prof
.
_faddr


	)
266 #define 
	#si_mstate
 
_data
.
_prof
.
_mstate


	)
270 #ifdef 
__cplusplus


	@/usr/include/sys/types.h

8 #ifndef 
_SYS_TYPES_H


9 #define 
	#_SYS_TYPES_H


	)
11 #pragma 
ident
 "@(#)types.h 1.38 95/11/14 SMI"

13 #include 
	~<sys/feature_tests.h
>

14 #include 
	~<sys/isa_defs.h
>

19 #include 
	~<sys/machtypes.h
>

21 #ifdef 
__cplusplus


27 typedef unsigned char 
	tuchar_t
;

28 typedef unsigned short 
	tushort_t
;

29 typedef unsigned int 
	tuint_t
;

30 typedef unsigned long 
	tulong_t
;

32 typedef char * 
	tcaddr_t
;

33 typedef long 
	tdaddr_t
;

34 typedef long 
	toff_t
;

35 typedef short 
	tcnt_t
;

37 typedef 
ulong_t
 
	tpaddr_t
;

38 typedef 
uchar_t
 
	tuse_t
;

39 typedef short 
	tsysid_t
;

40 typedef short 
	tindex_t
;

42 #if 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

43 typedef enum 
	e
{ 
_B_FALSE
, 
_B_TRUE
 } 
	tboolean_t
;

45 typedef enum 
	e
{ 
B_FALSE
, 
B_TRUE
 } 
	tboolean_t
;

53 #if 
__STDC__
 - 0 == 0 && !
defined
(
_NO_LONGLONG
)

54 typedef long long 
	tlonglong_t
;

55 typedef unsigned long long 
	tu_longlong_t
;

58 typedef union 
	u
{

59 double 
_d
;

60 long 
_l
[2];

61 } 
	tlonglong_t
;

62 typedef union 
	u
{

63 double 
_d
;

64 unsigned long 
_l
[2];

65 } 
	tu_longlong_t
;

68 #ifdef 
_LARGEFILE64_SOURCE


69 typedef 
longlong_t
 
	toff64_t
;

71 typedef 
longlong_t
 
	toffset_t
;

72 typedef 
longlong_t
 
	tdiskaddr_t
;

80 #ifdef 
_LONG_LONG_LTOH


81 typedef union 
	u
{

82 
offset_t
 
_f
;

83 struct 
	s
{

84 
off_t
 
_l
;

85 long 
_u
;

86 } 
_p
;

87 } 
	tlloff_t
;

90 #ifdef 
_LONG_LONG_HTOL


91 typedef union 
	u
{

92 
offset_t
 
_f
;

93 struct 
	s
{

94 long 
_u
;

95 
off_t
 
_l
;

96 } 
_p
;

97 } 
	tlloff_t
;

100 #ifdef 
_LONG_LONG_LTOH


101 typedef union 
	u
{

102 
diskaddr_t
 
_f
;

103 struct 
	s
{

104 
daddr_t
 
_l
;

105 long 
_u
;

106 } 
_p
;

107 } 
	tlldaddr_t
;

110 #ifdef 
_LONG_LONG_HTOL


111 typedef union 
	u
{

112 
diskaddr_t
 
_f
;

113 struct 
	s
{

114 long 
_u
;

115 
daddr_t
 
_l
;

116 } 
_p
;

117 } 
	tlldaddr_t
;

120 typedef 
ulong_t
 
	tk_fltset_t
;

130 typedef long 
	tid_t
;

139 typedef 
ulong_t
 
	tmajor_t
;

140 typedef 
ulong_t
 
	tminor_t
;

145 typedef short 
	tpri_t
;

158 typedef 
ushort_t
 
	to_mode_t
;

159 typedef short 
	to_dev_t
;

160 typedef 
ushort_t
 
	to_uid_t
;

161 typedef 
o_uid_t
 
	to_gid_t
;

162 typedef short 
	to_nlink_t
;

163 typedef short 
	to_pid_t
;

164 typedef 
ushort_t
 
	to_ino_t
;

169 typedef int 
	tkey_t
;

170 typedef 
ulong_t
 
	tmode_t
;

172 #ifndef 
_UID_T


173 #define 
	#_UID_T


	)
174 typedef long 
	tuid_t
;

177 typedef 
uid_t
 
	tgid_t
;

178 typedef 
ulong_t
 
	tnlink_t
;

179 typedef 
ulong_t
 
	tdev_t
;

180 typedef 
ulong_t
 
	tino_t
;

181 typedef long 
	tpid_t
;

183 #ifndef 
_SIZE_T


184 #define 
	#_SIZE_T


	)
185 typedef 
uint_t
 
	tsize_t
;

188 #ifndef 
_SSIZE_T


189 #define 
	#_SSIZE_T


	)
190 typedef int 
	tssize_t
;

194 #ifndef 
_TIME_T


195 #define 
	#_TIME_T


	)
196 typedef long 
	ttime_t
;

199 #ifndef 
_CLOCK_T


200 #define 
	#_CLOCK_T


	)
201 typedef long 
	tclock_t
;

204 #ifndef 
_CLOCKID_T


205 #define 
	#_CLOCKID_T


	)
206 typedef int 
	tclockid_t
;

209 #ifndef 
_TIMER_T


210 #define 
	#_TIMER_T


	)
211 typedef int 
	ttimer_t
;

214 #if 
defined
(
__EXTENSIONS__
) || defined(
_KERNEL
) || \

215 (!
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
))

217 typedef unsigned char 
	tunchar
;

218 typedef unsigned short 
	tushort
;

219 typedef unsigned int 
	tuint
;

220 typedef unsigned long 
	tulong
;

222 #if 
defined
(
_KERNEL
)

224 #define 
	#SHRT_MIN
 -32768

	)
225 #define 
	#SHRT_MAX
 32767

	)
226 #define 
	#USHRT_MAX
 ((
u_short
)65535)

	)
227 #define 
	#INT_MIN
 (-2147483647-1)

	)
228 #define 
	#INT_MAX
 2147483647

	)
229 #define 
	#UINT_MAX
 ((
u_int
)4294967295)

	)
230 #define 
	#LONG_MIN
 (-2147483647-1)

	)
231 #define 
	#LONG_MAX
 2147483647

	)
232 #define 
	#ULONG_MAX
 ((
u_long
)4294967295)

	)
237 #define 
	#P_MYPID
 ((
pid_t
)0)

	)
245 #define 
	#P_MYID
 (-1)

	)
246 #define 
	#NOPID
 (
pid_t
)(-1)

	)
248 #ifndef 
NODEV


249 #define 
	#NODEV
 (
dev_t
)(-1)

	)
257 typedef long 
	thostid_t
;

265 #define 
	#P_MYHOSTID
 ((
hostid_t
)-1)

	)
267 typedef unsigned char 
	tu_char
;

268 typedef unsigned short 
	tu_short
;

269 typedef unsigned int 
	tu_int
;

270 typedef unsigned long 
	tu_long
;

271 typedef struct 
	s_quad
 { long 
val
[2]; } 
	tquad
;

278 #include 
	~<sys/select.h
>

296 #define 
	#_VOID
 void

	)
298 #ifdef 
__cplusplus


	@/usr/include/sys/isa_defs.h

5 #ifndef 
_SYS_ISA_DEFS_H


6 #define 
	#_SYS_ISA_DEFS_H


	)
8 #pragma 
ident
 "@(#)isa_defs.h 1.7 94/10/26 SMI"

119 #ifdef 
__cplusplus


131 #if 
defined
(
__i386
) || defined(
i386
)

136 #if !
defined
(
__i386
)

137 #define 
	#__i386


	)
143 #define 
	#_LITTLE_ENDIAN


	)
144 #define 
	#_STACK_GROWS_DOWNWARD


	)
145 #define 
	#_LONG_LONG_LTOH


	)
146 #define 
	#_BIT_FIELDS_LTOH


	)
147 #define 
	#_IEEE_754


	)
148 #define 
	#_CHAR_IS_SIGNED


	)
149 #define 
	#_CHAR_ALIGNMENT
 1

	)
150 #define 
	#_SHORT_ALIGNMENT
 2

	)
151 #define 
	#_INT_ALIGNMENT
 4

	)
152 #define 
	#_LONG_ALIGNMENT
 4

	)
153 #define 
	#_LONG_LONG_ALIGNMENT
 4

	)
154 #define 
	#_DOUBLE_ALIGNMENT
 4

	)
155 #define 
	#_LONG_DOUBLE_ALIGNMENT
 4

	)
156 #define 
	#_POINTER_ALIGNMENT
 4

	)
157 #define 
	#_MAX_ALIGNMENT
 4

	)
158 #define 
	#_ALIGNMENT_REQUIRED
 0

	)
163 #define 
	#_SUNOS_VTOC_16


	)
164 #define 
	#_DMA_USES_PHYSADDR


	)
165 #define 
	#_FIRMWARE_NEEDS_FDISK


	)
175 #elif 
defined
(
__ppc
)

180 #define 
	#_LITTLE_ENDIAN


	)
181 #define 
	#_STACK_GROWS_DOWNWARD


	)
182 #define 
	#_LONG_LONG_LTOH


	)
183 #define 
	#_BIT_FIELDS_LTOH


	)
184 #define 
	#_IEEE_754


	)
185 #define 
	#_CHAR_IS_UNSIGNED


	)
186 #define 
	#_CHAR_ALIGNMENT
 1

	)
187 #define 
	#_SHORT_ALIGNMENT
 2

	)
188 #define 
	#_INT_ALIGNMENT
 4

	)
189 #define 
	#_LONG_ALIGNMENT
 4

	)
190 #define 
	#_LONG_LONG_ALIGNMENT
 8

	)
191 #define 
	#_DOUBLE_ALIGNMENT
 8

	)
192 #define 
	#_LONG_DOUBLE_ALIGNMENT
 16

	)
193 #define 
	#_POINTER_ALIGNMENT
 4

	)
194 #define 
	#_MAX_ALIGNMENT
 16

	)
195 #define 
	#_ALIGNMENT_REQUIRED
 1

	)
200 #define 
	#_SUNOS_VTOC_16


	)
201 #define 
	#_DMA_USES_PHYSADDR


	)
202 #define 
	#_FIRMWARE_NEEDS_FDISK


	)
211 #elif 
defined
(
__sparc
) || defined(
sparc
)

216 #if !
defined
(
__sparc
)

217 #define 
	#__sparc


	)
223 #define 
	#_BIG_ENDIAN


	)
224 #define 
	#_STACK_GROWS_DOWNWARD


	)
225 #define 
	#_LONG_LONG_HTOL


	)
226 #define 
	#_BIT_FIELDS_HTOL


	)
227 #define 
	#_IEEE_754


	)
228 #define 
	#_CHAR_IS_SIGNED


	)
229 #define 
	#_CHAR_ALIGNMENT
 1

	)
230 #define 
	#_SHORT_ALIGNMENT
 2

	)
231 #define 
	#_INT_ALIGNMENT
 4

	)
232 #define 
	#_LONG_ALIGNMENT
 4

	)
233 #define 
	#_LONG_LONG_ALIGNMENT
 8

	)
234 #define 
	#_DOUBLE_ALIGNMENT
 8

	)
235 #define 
	#_LONG_DOUBLE_ALIGNMENT
 8

	)
236 #define 
	#_POINTER_ALIGNMENT
 4

	)
237 #define 
	#_MAX_ALIGNMENT
 8

	)
238 #define 
	#_ALIGNMENT_REQUIRED
 1

	)
243 #define 
	#_SUNOS_VTOC_8


	)
244 #define 
	#_DMA_USES_VIRTADDR


	)
245 #define 
	#_NO_FDISK_PRESENT


	)
252 #error 
ISA
 
not
 
supported


255 #ifdef 
__cplusplus


	@/usr/include/sys/machsig.h

8 #ifndef 
_SYS_MACHSIG_H


9 #define 
	#_SYS_MACHSIG_H


	)
11 #pragma 
ident
 "@(#)machsig.h 1.10 94/11/05 SMI"

14 #include 
	~<sys/feature_tests.h
>

16 #ifdef 
__cplusplus


32 #if !
defined
(
_POSIX_C_SOURCE
)

38 #define 
	#ILL_ILLOPC
 1

	)
39 #define 
	#ILL_ILLOPN
 2

	)
40 #define 
	#ILL_ILLADR
 3

	)
41 #define 
	#ILL_ILLTRP
 4

	)
42 #define 
	#ILL_PRVOPC
 5

	)
43 #define 
	#ILL_PRVREG
 6

	)
44 #define 
	#ILL_COPROC
 7

	)
45 #define 
	#ILL_BADSTK
 8

	)
46 #define 
	#NSIGILL
 8

	)
52 #define 
	#EMT_TAGOVF
 1

	)
53 #define 
	#NSIGEMT
 1

	)
59 #define 
	#FPE_INTDIV
 1

	)
60 #define 
	#FPE_INTOVF
 2

	)
61 #define 
	#FPE_FLTDIV
 3

	)
62 #define 
	#FPE_FLTOVF
 4

	)
63 #define 
	#FPE_FLTUND
 5

	)
64 #define 
	#FPE_FLTRES
 6

	)
65 #define 
	#FPE_FLTINV
 7

	)
66 #define 
	#FPE_FLTSUB
 8

	)
67 #define 
	#NSIGFPE
 8

	)
73 #define 
	#SEGV_MAPERR
 1

	)
74 #define 
	#SEGV_ACCERR
 2

	)
75 #define 
	#NSIGSEGV
 2

	)
81 #define 
	#BUS_ADRALN
 1

	)
82 #define 
	#BUS_ADRERR
 2

	)
83 #define 
	#BUS_OBJERR
 3

	)
84 #define 
	#NSIGBUS
 3

	)
88 #ifdef 
__cplusplus


	@/usr/include/sys/machtypes.h

8 #ifndef 
_SYS_MACHTYPES_H


9 #define 
	#_SYS_MACHTYPES_H


	)
11 #pragma 
ident
 "@(#)machtypes.h 1.9 94/11/05 SMI"

13 #include 
	~<sys/feature_tests.h
>

15 #ifdef 
__cplusplus


25 #if (!
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

26 
	$defined
(
__EXTENSIONS__
)

28 typedef struct 
	s_physadr_t
 { int 
r
[1]; } *
	tphysadr_t
;

30 typedef struct 
	s_label_t
 { int 
val
[2]; } 
	tlabel_t
;

34 typedef unsigned char 
	tlock_t
;

36 #ifdef 
__cplusplus


37 
	}
}

	@/usr/include/sys/proc.h

8 #ifndef 
_SYS_PROC_H


9 #define 
	#_SYS_PROC_H


	)
11 #pragma 
ident
 "@(#)proc.h 1.90 97/09/22 SMI"

13 #include 
	~<sys/time.h
>

15 #include 
	~<sys/thread.h
>

16 #include 
	~<sys/cred.h
>

17 #include 
	~<sys/user.h
>

18 #include 
	~<sys/timer.h
>

19 #if 
defined
(
i386
) || defined(
__i386
)

20 #include 
	~<sys/segment.h
>

23 #ifdef 
__cplusplus


33 typedef struct 
	sproc
 {

37 struct 
vnode
 *
p_exec
;

38 struct 
as
 *
p_as
;

39 struct 
plock
 *
p_lockp
;

40 int 
p_pad
;

41 
kmutex_t
 
p_crlock
;

42 struct 
cred
 *
p_cred
;

46 int 
p_swapcnt
;

47 char 
p_stat
;

48 char 
p_wcode
;

49 int 
p_wdata
;

50 
pid_t
 
p_ppid
;

51 struct 
proc
 *
p_link
;

52 struct 
proc
 *
p_parent
;

53 struct 
proc
 *
p_child
;

54 struct 
proc
 *
p_sibling
;

55 struct 
proc
 *
p_psibling
;

56 struct 
proc
 *
p_sibling_ns
;

57 struct 
proc
 *
p_child_ns
;

58 struct 
proc
 *
p_next
;

59 struct 
proc
 *
p_prev
;

60 struct 
proc
 *
p_nextofkin
;

61 struct 
proc
 *
p_orphan
;

62 struct 
proc
 *
p_nextorph
;

63 struct 
proc
 *
p_pglink
;

64 struct 
proc
 *
p_ppglink
;

65 struct 
sess
 *
p_sessp
;

66 struct 
pid
 *
p_pidp
;

67 struct 
pid
 *
p_pgidp
;

71 
kcondvar_t
 
p_cv
;

72 
kcondvar_t
 
p_flag_cv
;

73 
kcondvar_t
 
p_lwpexit
;

74 
kcondvar_t
 
p_holdlwps
;

76 
kcondvar_t
 
p_flock
;

77 
u_short
 
p_prwant
;

78 
u_int
 
p_flag
;

80 
clock_t
 
p_utime
;

81 
clock_t
 
p_stime
;

82 
clock_t
 
p_cutime
;

83 
clock_t
 
p_cstime
;

84 
caddr_t
 *
p_segacct
;

85 
caddr_t
 
p_brkbase
;

86 
u_int
 
p_brksize
;

90 
k_sigset_t
 
p_sig
;

91 
k_sigset_t
 
p_ignore
;

92 
k_sigset_t
 
p_siginfo
;

93 struct 
sigqueue
 *
p_sigqueue
;

94 struct 
sigqhdr
 *
p_sigqhdr
;

95 
u_char
 
p_stopsig
;

101 char 
p_fixalignment
;

106 int 
p_lwptotal
;

107 int 
p_lwpcnt
;

108 int 
p_lwprcnt
;

109 int 
p_lwpblocked
;

111 int 
p_zombcnt
;

112 
kthread_t
 *
p_tlist
;

113 
kthread_t
 *
p_zomblist
;

117 
k_sigset_t
 
p_sigmask
;

118 
k_fltset_t
 
p_fltmask
;

119 struct 
vnode
 *
p_trace
;

120 struct 
vnode
 *
p_plist
;

122 struct 
proc
 *
p_rlink
;

123 
kcondvar_t
 
p_srwchan_cv
;

124 
u_int
 
p_stksize
;

128 
hrtime_t
 
p_mstart
;

129 
hrtime_t
 
p_mterm
;

130 
hrtime_t
 
p_mlreal
;

131 
hrtime_t
 
p_acct
[
NMSTATES
];

132 struct 
lrusage
 
p_ru
;

133 struct 
itimerval
 
p_rprof_timer
;

134 int 
p_rprof_timerid
;

135 
u_int
 
p_defunct
;

140 
kmutex_t
 
p_pflock
;

145 struct 
user
 
p_user
;

150 
kthread_t
 *
p_server_threads
;

151 struct 
door_node
 *
p_unref_list
;

152 
kcondvar_t
 
p_server_cv
;

153 char 
p_unref_thread
;

158 
u_char
 
p_tnf_flags
;

163 
caddr_t
 
p_audit_data
;

164 
kthread_t
 *
p_aslwptp
;

165 #if 
defined
(
i386
) || defined(
__i386
)

169 
kmutex_t
 
p_ldtlock
;

170 struct 
seg_desc
 *
p_ldt
;

171 struct 
seg_desc
 
p_ldt_desc
;

172 int 
p_ldtlimit
;

174 
u_int
 
p_swrss
;

175 struct 
aio
 *
p_aio
;

176 struct 
timerstr
 *
p_itimer
;

177 
k_sigset_t
 
p_notifsigs
;

178 
kcondvar_t
 
p_notifcv
;

179 int 
p_alarmid
;

180 struct 
lwpchan_data
 *
p_lcp
;

181 } 
	tproc_t
;

183 #define 
	#PROC_T


	)
187 extern 
proc_t
 *
practive
;

191 extern 
proc_t
 *
proc_sched
;

192 extern 
proc_t
 *
proc_init
;

193 extern 
proc_t
 *
proc_pageout
;

194 extern 
proc_t
 *
proc_fsflush
;

203 struct 
	supcount
 {

204 struct 
upcount
 *
	gup_next
;

205 
uid_t
 
	gup_uid
;

206 
u_long
 
	gup_count
;

211 struct 
	spid
 {

212 unsigned int 
	gpid_prinactive
 :1;

213 unsigned int 
	gpid_pgorphaned
 :1;

214 unsigned int 
	gpid_padding
 :6;

215 unsigned int 
	gpid_prslot
 :24;

216 
pid_t
 
	gpid_id
;

217 struct 
proc
 *
	gpid_pglink
;

218 struct 
pid
 *
	gpid_link
;

219 
u_int
 
	gpid_ref
;

222 extern 
proc_t
 
p0
;

223 extern struct 
pid
 
pid0
;

225 #define 
	#p_pgrp
 
p_pgidp
->
pid_id


	)
226 #define 
	#p_pid
 
p_pidp
->
pid_id


	)
227 #define 
	#p_slot
 
p_pidp
->
pid_prslot


	)
228 #define 
	#p_detached
 
p_pgidp
->
pid_pgorphaned


	)
230 #define 
	#PID_HOLD
(
pidp
) 
	`ASSERT
(
	`MUTEX_HELD
(&
pidlock
)); \

231 ++(
pidp
)->
pid_ref
;

	)
232 #define 
	#PID_RELE
(
pidp
) 
	`ASSERT
(
	`MUTEX_HELD
(&
pidlock
)); \

233 (
pidp
)->
pid_ref
 > 1 ? \

234 --(
pidp
)->
pid_ref
 : 
	`pid_rele
(pidp);

	)
240 struct 
	splock
 {

241 
kmutex_t
 
	gpl_lock
;

243 #define 
	#p_lock
 
p_lockp
->
pl_lock


	)
247 #define 
	#SSLEEP
 1

	)
248 #define 
	#SRUN
 2

	)
249 #define 
	#SZOMB
 3

	)
250 #define 
	#SSTOP
 4

	)
251 #define 
	#SIDL
 5

	)
252 #define 
	#SONPROC
 6

	)
258 #define 
	#SSYS
 0x00000001

	)
259 #define 
	#STRC
 0x00000002

	)
260 #define 
	#SNWAKE
 0x00000004

	)
261 #define 
	#SLOAD
 0x00000008

	)
262 #define 
	#SLOCK
 0x00000010

	)
263 #define 
	#SPREXEC
 0x00000020

	)
264 #define 
	#SPROCTR
 0x00000040

	)
265 #define 
	#SPRFORK
 0x00000080

	)
266 #define 
	#SKILLED
 0x00000100

	)
267 #define 
	#SULOAD
 0x00000200

	)
268 #define 
	#SRUNLCL
 0x00000400

	)
269 #define 
	#SBPTADJ
 0x00000800

	)
270 #define 
	#SKILLCL
 0x00001000

	)
271 #define 
	#SOWEUPC
 0x00002000

	)
272 #define 
	#SEXECED
 0x00004000

	)
273 #define 
	#SPASYNC
 0x00008000

	)
274 #define 
	#SJCTL
 0x00010000

	)
275 #define 
	#SNOWAIT
 0x00020000

	)
276 #define 
	#SVFORK
 0x00040000

	)
277 #define 
	#SVFDONE
 0x00080000

	)
278 #define 
	#EXITLWPS
 0x00100000

	)
279 #define 
	#HOLDLWPS
 0x00200000

	)
280 #define 
	#SWAITSIG
 0x00400000

	)
281 #define 
	#HOLDLWP2
 0x00800000

	)
282 #define 
	#COREDUMP
 0x01000000

	)
283 #define 
	#SMSACCT
 0x02000000

	)
284 #define 
	#ASLWP
 0x04000000

	)
286 #define 
	#SPRLOCK
 0x08000000

	)
287 #define 
	#NOCD
 0x10000000

	)
290 #define 
	#PTOU
(
p
) (&(p)->
p_user
)

	)
292 #define 
	#tracing
(
p
, 
sig
) (
	`sigismember
(&(p)->
p_sigmask
, sig))

	)
296 #define 
	#ISSIG
(
t
, 
why
) 
	`ISSIG_FAST
(t, 
	`ttolwp
(t), 
	`ttoproc
(t), why)

	)
306 #define 
	#ISSIG_FAST
(
t
, 
lwp
, 
p
, 
why
) \

307 (
	`ISSIG_PENDING
(
t
, 
lwp
, 
p
) && 
	`issig
(
why
))

	)
309 #define 
	#ISSIG_PENDING
(
t
, 
lwp
, 
p
) \

310 ((
lwp
)->
lwp_cursig
 | \

311 (
p
)->
p_sig
.
__sigbits
[0] | \

312 (
p
)->
p_sig
.
__sigbits
[1] | \

313 (
t
)->
t_sig
.
__sigbits
[0] | \

314 (
t
)->
t_sig
.
__sigbits
[1] | \

315 (
p
)->
p_stopsig
 | \

316 ((
t
)->
t_proc_flag
 & (
TP_PRSTOP
|
TP_HOLDLWP
|
TP_CHKPT
)) | \

317 ((
p
)->
p_flag
 & (
EXITLWPS
|
SKILLED
|
HOLDLWP2
)))

	)
319 #define 
	#ISSTOP
(
sig
) (
u
.
u_signal
[sig-1] == 
SIG_DFL
 && \

320 
	`sigismember
(&
stopdefault
, 
sig
))

	)
322 #define 
	#ISHOLD
(
p
) ((p)->
p_flag
 & 
HOLDLWPS
)

	)
326 #define 
	#FORREAL
 0

	)
327 #define 
	#JUSTLOOKING
 1

	)
329 #ifdef 
_KERNEL


333 extern 
caddr_t
 
findvaddr
(
proc_t
 *);

334 extern 
paddr_t
 
vtop
(
caddr_t
, 
proc_t
 *);

335 extern void 
pexit
(void);

336 extern int 
newproc
(void (*)(), 
id_t
, int);

337 extern void 
vfwait
(
pid_t
);

338 extern void 
freeproc
(
proc_t
 *);

339 extern void 
setrun
(
kthread_t
 *);

340 extern void 
setrun_locked
(
kthread_t
 *);

341 extern void 
exit
(int, int);

342 extern void 
relvm
(
proc_t
 *);

343 extern void 
add_ns
(
proc_t
 *, proc_t *);

344 extern void 
delete_ns
(
proc_t
 *, proc_t *);

345 extern void 
upcount_inc
(
uid_t
);

346 extern void 
upcount_dec
(
uid_t
);

347 extern int 
upcount_get
(
uid_t
);

348 #if 
defined
(
i386
) || defined(
__i386
)

349 extern int 
ldt_dup
(
proc_t
 *, proc_t *);

352 extern void 
sigcld
(
proc_t
 *);

353 extern int 
fsig
(
k_sigset_t
 *, 
kthread_t
 *);

354 extern void 
psig
(void);

355 extern void 
stop
(
kthread_t
 *, int, int);

356 extern int 
stop_on_fault
(
u_int
, 
k_siginfo_t
 *);

357 extern int 
issig
(int);

358 extern int 
jobstopped
(
proc_t
 *);

359 extern void 
psignal
(
proc_t
 *, int);

360 extern void 
tsignal
(
kthread_t
 *, int);

361 extern void 
sigtoproc
(
proc_t
 *, 
kthread_t
 *, int, int);

362 extern void 
trapsig
(
k_siginfo_t
 *, int);

363 extern int 
eat_signal
(
kthread_t
 *
t
, int 
sig
);

365 extern void 
pid_setmin
(void);

366 extern 
pid_t
 
pid_assign
(
proc_t
 *);

367 extern int 
pid_rele
(struct 
pid
 *);

368 extern void 
pid_exit
(
proc_t
 *);

369 extern void 
proc_entry_free
(struct 
pid
 *);

370 extern 
proc_t
 *
prfind
(
pid_t
);

371 extern 
proc_t
 *
pgfind
(
pid_t
);

372 extern void 
pid_init
(void);

373 extern 
proc_t
 *
pid_entry
(int);

374 extern int 
pid_slot
(
proc_t
 *);

375 extern void 
signal
(
pid_t
, int);

376 extern void 
prsignal
(struct 
pid
 *, int);

378 extern void 
pgsignal
(struct 
pid
 *, int);

379 extern void 
pgjoin
(
proc_t
 *, struct 
pid
 *);

380 extern void 
pgcreate
(
proc_t
 *);

381 extern void 
pgexit
(
proc_t
 *);

382 extern void 
pgdetach
(
proc_t
 *);

383 extern int 
pgmembers
(
pid_t
);

385 extern void 
init_mstate
(
kthread_t
 *, int);

386 extern int 
new_mstate
(
kthread_t
 *, int);

387 extern void 
restore_mstate
(
kthread_t
 *);

388 extern void 
term_mstate
(
kthread_t
 *);

389 extern void 
estimate_msacct
(
kthread_t
 *, 
hrtime_t
);

390 extern void 
disable_msacct
(
proc_t
 *);

392 extern 
u_short
 
cpu_decay
(u_short, 
clock_t
);

393 extern 
u_short
 
cpu_grow
(u_short, 
clock_t
);

395 extern void 
set_proc_pre_sys
(
proc_t
 *
p
);

396 extern void 
set_proc_post_sys
(
proc_t
 *
p
);

397 extern void 
set_proc_sys
(
proc_t
 *
p
);

398 extern void 
set_proc_ast
(
proc_t
 *
p
);

399 extern void 
set_all_proc_sys
(void);

403 extern 
kthread_t
 *
thread_create
(

404 
caddr_t
 
stk
,

405 int 
stksize
,

406 void (*
proc
)(),

407 
caddr_t
 
arg
,

408 int 
len
,

409 
proc_t
 *
pp
,

410 int 
state
,

411 int 
pri
);

412 extern void 
thread_exit
(void);

413 extern void 
thread_destroy
(
kthread_t
 *);

414 extern void 
thread_free
(
kthread_t
 *);

415 extern int 
reaper
(void);

416 extern void 
savectx
(
kthread_t
 *);

417 extern void 
restorectx
(
kthread_t
 *);

418 extern void 
forkctx
(
kthread_t
 *, kthread_t *);

419 extern void 
freectx
(
kthread_t
 *);

420 extern 
kthread_t
 *
thread_unpin
(void);

421 extern void 
release_interrupt
(void);

422 extern int 
thread_create_intr
(struct 
cpu
 *);

423 extern void 
thread_init
(void);

424 extern int 
thread_load
(
kthread_t
 *, void (*)(), 
caddr_t
, int);

426 extern void 
tsd_create
(
u_int
 *, void (*)(void *));

427 extern void 
tsd_destroy
(
u_int
 *);

428 extern void *
tsd_getcreate
(
u_int
 *, void (*)(void *), void *(*)(void));

429 extern void *
tsd_get
(
u_int
);

430 extern int 
tsd_set
(
u_int
, void *);

431 extern void 
tsd_exit
(void);

435 extern 
klwp_t
 *
lwp_create
(

436 void (*
proc
)(),

437 
caddr_t
 
arg
,

438 int 
len
,

439 
proc_t
 *
p
,

440 int 
state
,

441 int 
pri
,

442 
k_sigset_t
 
smask
,

443 int 
cid
);

444 extern void 
lwp_exit
(void);

445 extern int 
lwp_suspend
(
kthread_t
 *);

446 extern void 
lwp_continue
(
kthread_t
 *);

447 extern void 
holdlwp
(void);

448 extern void 
stoplwp
(void);

449 extern int 
holdlwps
(
proc_t
 *, int);

450 extern void 
pokelwps
(
proc_t
 *);

451 extern void 
continuelwps
(
proc_t
 *);

452 extern void 
exitlwps
(
proc_t
 *, int);

453 extern 
klwp_t
 *
forklwp
(klwp_t *, 
proc_t
 *);

454 extern int 
sigisheld
(
proc_t
 *, int);

455 extern int 
sigwaiting_check
(
kmutex_t
 *);

456 extern void 
sigwaiting_decr
(void);

457 extern void 
lwp_load
(
klwp_t
 *, 
ucontext_t
 *);

458 extern void 
lwp_setrval
(
klwp_t
 *, int, int);

459 extern void 
lwp_forkregs
(
klwp_t
 *, klwp_t *);

460 extern void 
lwp_freeregs
(
klwp_t
 *);

461 extern 
caddr_t
 
lwp_stk_init
(
klwp_t
 *, caddr_t);

467 extern void 
sigqfree
(
proc_t
 *);

468 extern int 
sigdeq
(
proc_t
 *, 
kthread_t
 *, int, 
sigqueue_t
 **);

469 extern void 
sigdelq
(
proc_t
 *, 
kthread_t
 *, int);

470 extern void 
sigaddq
(
proc_t
 *, 
kthread_t
 *, 
k_siginfo_t
 *, int);

471 extern void 
sigaddqa
(
proc_t
 *, 
kthread_t
 *, 
sigqueue_t
 *);

472 extern void 
sigdupq
(
proc_t
 *, proc_t *);

473 extern 
sigqueue_t
 *
sigappend
(
k_sigset_t
 *, sigqueue_t *,

474 
k_sigset_t
 *, 
sigqueue_t
 *);

475 extern 
sigqueue_t
 *
sigprepend
(
k_sigset_t
 *, sigqueue_t *,

476 
k_sigset_t
 *, 
sigqueue_t
 *);

477 extern void 
winfo
(
proc_t
 *, 
k_siginfo_t
 *, int);

478 extern int 
sendsig
(int, 
k_siginfo_t
 *, void (*)());

482 #ifdef 
__cplusplus


	@/usr/include/sys/select.h

8 #ifndef 
_SYS_SELECT_H


9 #define 
	#_SYS_SELECT_H


	)
11 #pragma 
ident
 "@(#)select.h 1.10 92/07/14 SMI"

13 #ifndef 
_KERNEL


14 #include 
	~<sys/time.h
>

17 #ifdef 
__cplusplus


27 #ifndef 
FD_SETSIZE


28 #define 
	#FD_SETSIZE
 1024

	)
31 #ifndef 
NBBY


32 #define 
	#NBBY
 8

	)
35 typedef long 
	tfd_mask
;

36 #define 
	#NFDBITS
 (sizeof (
fd_mask
) * 
NBBY
)

	)
37 #ifndef 
howmany


38 #define 
	#howmany
(
x
, 
y
) (((x)+((y)-1))/(y))

	)
41 typedef struct 
	sfd_set
 {

42 
fd_mask
 
fds_bits
[
howmany
(
FD_SETSIZE
, 
NFDBITS
)];

43 } 
	tfd_set
;

45 #define 
	#FD_SET
(
n
, 
p
) ((p)->
fds_bits
[(n)/
NFDBITS
] |= \

46 ((unsigned)1 << ((
n
) % 
NFDBITS
)))

	)
48 #define 
	#FD_CLR
(
n
, 
p
) ((p)->
fds_bits
[(n)/
NFDBITS
] &= \

49 ~((unsigned)1 << ((
n
) % 
NFDBITS
)))

	)
51 #define 
	#FD_ISSET
(
n
, 
p
) ((p)->
fds_bits
[(n)/
NFDBITS
] & \

52 ((unsigned)1 << ((
n
) % 
NFDBITS
)))

	)
54 #ifdef 
_KERNEL


55 #define 
	#FD_ZERO
(
p
) 
	`bzero
((char *)(p), sizeof (*(p)))

	)
57 #define 
	#FD_ZERO
(
p
) 
	`memset
((char *)(p), 0, sizeof (*(p)))

	)
60 #ifndef 
_KERNEL


61 #ifdef 
__STDC__


62 extern int 
select
(int, 
fd_set
 *, fd_set *, fd_set *, struct 
timeval
 *);

64 extern int 
select
();

68 #ifdef 
__cplusplus


	@/usr/include/sys/time.h

19 #ifndef 
_SYS_TIME_H


20 #define 
	#_SYS_TIME_H


	)
22 #pragma 
ident
 "@(#)time.h 2.47 95/08/24 SMI"

24 #include 
	~<sys/feature_tests.h
>

31 #ifdef 
__cplusplus


35 #if (!
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

36 
	$defined
(
__EXTENSIONS__
)

37 #ifndef 
_ASM


39 struct 
	stimeval
 {

40 long 
tv_sec
;

41 long 
tv_usec
;

44 struct 
	stimezone
 {

45 int 
tz_minuteswest
;

46 int 
tz_dsttime
;

52 #ifdef 
__cplusplus


53 
	}
}

60 #ifndef 
_ASM


61 #include 
	~<sys/types.h
>

64 #ifdef 
__cplusplus


68 #if (!
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

69 
	$defined
(
__EXTENSIONS__
)

71 #define 
	#DST_NONE
 0

	)
72 #define 
	#DST_USA
 1

	)
73 #define 
	#DST_AUST
 2

	)
74 #define 
	#DST_WET
 3

	)
75 #define 
	#DST_MET
 4

	)
76 #define 
	#DST_EET
 5

	)
77 #define 
	#DST_CAN
 6

	)
78 #define 
	#DST_GB
 7

	)
79 #define 
	#DST_RUM
 8

	)
80 #define 
	#DST_TUR
 9

	)
81 #define 
	#DST_AUSTALT
 10

	)
88 #define 
	#timerisset
(
tvp
) ((tvp)->
tv_sec
 || (tvp)->
tv_usec
)

	)
89 #define 
	#timercmp
(
tvp
, 
uvp
, 
cmp
) \

91 ((
tvp
)->
tv_sec
 
	`cmp
 (
uvp
)->tv_sec || \

92 ((
tvp
)->
tv_sec
 == (
uvp
)->tv_sec && \

94 (
tvp
)->
tv_usec
 
	`cmp
 (
uvp
)->tv_usec))

	)
96 #define 
	#timerclear
(
tvp
) (tvp)->
tv_sec
 = (tvp)->
tv_usec
 = 0

	)
102 #define 
	#ITIMER_REAL
 0

	)
103 #define 
	#ITIMER_VIRTUAL
 1

	)
104 #define 
	#ITIMER_PROF
 2

	)
105 #define 
	#ITIMER_REALPROF
 3

	)
107 #ifndef 
_ASM


108 struct 
	sitimerval
 {

109 struct 
timeval
 
it_interval
;

110 struct 
timeval
 
it_value
;

118 #define 
	#SEC
 1

	)
119 #define 
	#MILLISEC
 1000

	)
120 #define 
	#MICROSEC
 1000000

	)
121 #define 
	#NANOSEC
 1000000000

	)
125 #if !
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
) || \

126 (
_POSIX_C_SOURCE
 > 2) || 
	$defined
(
__EXTENSIONS__
)

128 #define 
	#__CLOCK_REALTIME0
 0

	)
129 #define 
	#CLOCK_VIRTUAL
 1

	)
130 #define 
	#CLOCK_PROF
 2

	)
131 #define 
	#__CLOCK_REALTIME3
 3

	)
137 #if (
_POSIX_C_SOURCE
 >= 199506L) || 
	`defined
(
_POSIX_PER_PROCESS_TIMER_SOURCE
)

138 #define 
	#CLOCK_REALTIME
 
__CLOCK_REALTIME3


	)
140 #define 
	#CLOCK_REALTIME
 
__CLOCK_REALTIME0


	)
143 #define 
	#TIMER_RELTIME
 0x0

	)
144 #define 
	#TIMER_ABSTIME
 0x1

	)
148 #ifndef 
_ASM


155 #if (!
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

156 (
_POSIX_C_SOURCE
 > 2) || 
	`defined
(
__EXTENSIONS__
)

157 typedef struct 
	stimespec
 {

158 
time_t
 
tv_sec
;

159 long 
tv_nsec
;

160 } 
	ttimespec_t
;

162 typedef struct 
timespec
 
	ttimestruc_t
;

166 typedef struct 
	s_timespec
 {

167 
time_t
 
_tv_sec
;

168 long 
_tv_nsec
;

169 } 
	ttimespec_t
;

171 typedef struct 
_timespec
 
	ttimestruc_t
;

179 #if (!
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

180 
	`defined
(
__EXTENSIONS__
)

181 #define 
	#timestruc
 
timespec


	)
187 #if (!
	`defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

188 (
_POSIX_C_SOURCE
 > 2) || 
	`defined
(
__EXTENSIONS__
)

189 typedef struct 
	sitimerspec
 {

190 struct 
timespec
 
it_interval
;

191 struct 
timespec
 
it_value
;

192 } 
	titimerspec_t
;

198 typedef 
longlong_t
 
	thrtime_t
;

200 #ifdef 
_KERNEL


202 #include 
	~<sys/mutex.h
>

204 extern int 
usec_per_tick
;

205 extern int 
nsec_per_tick
;

207 typedef struct 
	stodinfo
 {

208 int 
tod_sec
;

209 int 
tod_min
;

210 int 
tod_hour
;

211 int 
tod_dow
;

212 int 
tod_day
;

213 int 
tod_month
;

214 int 
tod_year
;

215 } 
	ttodinfo_t
;

217 extern 
timestruc_t
 
hrestime
;

218 extern 
longlong_t
 
timedelta
;

219 extern int 
tod_needsync
;

220 extern 
kmutex_t
 
tod_lock
;

222 extern 
timestruc_t
 
	`tod_get
(void);

223 extern void 
	`tod_set
(
timestruc_t
);

224 extern 
todinfo_t
 
	`utc_to_tod
(
time_t
);

225 extern 
time_t
 
	`tod_to_utc
(
todinfo_t
);

226 extern 
hrtime_t
 
	`gethrtime
(void);

227 extern void 
	`gethrestime
(
timespec_t
 *);

228 extern void 
	`hrt2ts
(
hrtime_t
, 
timestruc_t
 *);

229 extern 
hrtime_t
 
	`ts2hrt
(
timestruc_t
 *);

230 extern int 
	`itimerfix
(struct 
timeval
 *);

231 extern int 
	`itimerdecr
(struct 
itimerval
 *, int);

232 extern void 
	`timevaladd
(struct 
timeval
 *, struct timeval *);

233 extern void 
	`timevalsub
(struct 
timeval
 *, struct timeval *);

234 extern void 
	`timevalfix
(struct 
timeval
 *);

238 #if (!
	`defined
(
_KERNEL
) && !defined(
_POSIX_C_SOURCE
) && \

239 !
	`defined
(
_XOPEN_SOURCE
)) || defined(
__EXTENSIONS__
)

240 #if 
	`defined
(
__STDC__
)

241 int 
	`adjtime
(struct 
timeval
 *, struct timeval *);

242 int 
	`getitimer
(int, struct 
itimerval
 *);

243 int 
	`setitimer
(int, const struct 
itimerval
 *, struct itimerval *);

259 #if 
	`defined
(
_SVID_GETTOD
)

260 int 
	`gettimeofday
(struct 
timeval
 *);

261 int 
	`settimeofday
(struct 
timeval
 *);

263 int 
	`gettimeofday
(struct 
timeval
 *, void *);

264 int 
	`settimeofday
(struct 
timeval
 *, void *);

267 
hrtime_t
 
	`gethrtime
(void);

268 
hrtime_t
 
	`gethrvtime
(void);

270 int 
	`adjtime
();

271 int 
	`getitimer
();

272 int 
	`setitimer
();

273 int 
	`gettimeofday
();

274 int 
	`settimeofday
();

276 
hrtime_t
 
	`gethrtime
();

277 
hrtime_t
 
	`gethrvtime
();

279 #if !
	`defined
(
_XOPEN_SOURCE
)

280 #include 
	~<time.h
>

286 #ifdef 
__cplusplus


287 
	}
}

	@/usr/include/sys/cred.h

31 #ifndef 
_SYS_CRED_H


32 #define 
	#_SYS_CRED_H


	)
34 #pragma 
ident
 "@(#)cred.h 1.18 94/12/04 SMI"

36 #ifdef 
_KERNEL


37 #include 
	~<sys/t_lock.h
>

40 #ifdef 
__cplusplus


50 typedef struct 
	scred
 {

51 
ulong_t
 
cr_ref
;

52 
uid_t
 
cr_uid
;

53 
gid_t
 
cr_gid
;

54 
uid_t
 
cr_ruid
;

55 
gid_t
 
cr_rgid
;

56 
uid_t
 
cr_suid
;

57 
gid_t
 
cr_sgid
;

58 
ulong_t
 
cr_ngroups
;

59 
gid_t
 
cr_groups
[1];

60 } 
	tcred_t
;

62 #ifdef 
_KERNEL


64 #define 
	#crhold
(
cr
) 
	`mutex_enter
(&
cr_lock
), (cr)->
cr_ref
++, \

65 
	`mutex_exit
(&
cr_lock
)

	)
67 #define 
	#CRED
() 
curthread
->
t_cred


	)
69 struct 
proc
;

71 extern int 
ngroups_max
;

72 extern 
kmutex_t
 
cr_lock
;

76 extern struct 
cred
 *
kcred
;

78 extern void 
cred_init
(void);

79 extern void 
crfree
(
cred_t
 *);

80 extern 
cred_t
 *
crget
(void);

81 extern 
cred_t
 *
crcopy
(cred_t *);

82 extern 
cred_t
 *
crdup
(cred_t *);

83 extern 
cred_t
 *
crgetcred
(void);

84 extern void 
crset
(struct 
proc
 *, 
cred_t
 *);

85 extern int 
suser
(
cred_t
 *);

86 extern int 
groupmember
(
gid_t
, 
cred_t
 *);

87 extern int 
hasprocperm
(
cred_t
 *, cred_t *);

88 extern int 
crcmp
(
cred_t
 *, cred_t *);

92 #ifdef 
__cplusplus


	@/usr/include/sys/mutex.h

5 #ifndef 
_SYS_MUTEX_H


6 #define 
	#_SYS_MUTEX_H


	)
8 #pragma 
ident
 "@(#)mutex.h 1.14 94/07/29 SMI"

10 #ifndef 
_ASM


11 #include 
	~<sys/types.h
>

12 #include 
	~<sys/dki_lkinfo.h
>

15 #ifdef 
__cplusplus


19 #ifndef 
_ASM


45 typedef enum 
	e
{

46 
MUTEX_ADAPTIVE
 = 0,

47 
MUTEX_SPIN
,

48 
MUTEX_ADAPTIVE_STAT
,

49 
MUTEX_SPIN_STAT
,

50 
MUTEX_DRIVER_NOSTAT
 = 4,

51 
MUTEX_DRIVER_STAT
 = 5,

52 
MUTEX_ADAPTIVE_DEF


53 } 
	tkmutex_type_t
;

55 #if 
defined
(
_LOCKTEST
) || defined(
_MPSTATS
)

56 #define 
	#MUTEX_DEFAULT
 
MUTEX_ADAPTIVE_STAT


	)
57 #define 
	#MUTEX_DRIVER
 
MUTEX_DRIVER_STAT


	)
58 #define 
	#MUTEX_SPIN_DEFAULT
 
MUTEX_SPIN_STAT


	)
60 #define 
	#MUTEX_DEFAULT
 
MUTEX_ADAPTIVE_DEF


	)
61 #define 
	#MUTEX_DRIVER
 
MUTEX_DRIVER_NOSTAT


	)
62 #define 
	#MUTEX_SPIN_DEFAULT
 
MUTEX_SPIN


	)
71 #define 
	#DEFAULT_WT
 
NULL


	)
74 typedef struct 
	smutex
 {

75 void *
	m_opaque
[2];

76 } 
	tkmutex_t
;

79 #if 
defined
(
_KERNEL
) && defined(
__STDC__
)

81 #define 
	#MUTEX_HELD
(
x
) (
	`mutex_owned
(x))

	)
82 #define 
	#MUTEX_NOT_HELD
(
x
) (!
	`mutex_owned
(x) || 
panicstr
)

	)
84 extern void 
lock_mutex_flush
(void);

90 extern void 
mutex_init
(
kmutex_t
 *, char *, 
kmutex_type_t
, void *);

91 extern void 
mutex_destroy
(
kmutex_t
 *);

92 extern void 
mutex_enter
(
kmutex_t
 *);

93 extern int 
mutex_tryenter
(
kmutex_t
 *);

94 extern void 
mutex_exit
(
kmutex_t
 *);

95 extern 
lkstat_t
 *
mutex_stats
(
kmutex_t
 *);

96 extern int 
mutex_owned
(
kmutex_t
 *);

97 extern struct 
_kthread
 *
mutex_owner
(
kmutex_t
 *);

104 #ifdef 
__cplusplus


	@/usr/include/sys/thread.h

5 #ifndef 
_SYS_THREAD_H


6 #define 
	#_SYS_THREAD_H


	)
8 #pragma 
ident
 "@(#)thread.h 1.66 95/11/29 SMI"

10 #include 
	~<sys/types.h
>

11 #include 
	~<sys/t_lock.h
>

12 #include 
	~<sys/class.h
>

13 #include 
	~<sys/klwp.h
>

14 #include 
	~<sys/pirec.h
>

15 #include 
	~<sys/sleepq.h
>

16 #include 
	~<sys/turnstile.h
>

18 #ifdef 
__cplusplus


31 #define 
	#TS_FREE
 0x00

	)
32 #define 
	#TS_SLEEP
 0x01

	)
33 #define 
	#TS_RUN
 0x02

	)
34 #define 
	#TS_ONPROC
 0x04

	)
35 #define 
	#TS_ZOMB
 0x08

	)
36 #define 
	#TS_STOPPED
 0x10

	)
38 typedef struct 
	sctxop
 {

39 void (*
save_op
)();

40 void (*
restore_op
)();

41 void (*
fork_op
)();

42 void (*
free_op
)();

43 int 
arg
;

44 struct 
ctxop
 *
next
;

45 } 
	tctxop_t
;

47 typedef struct 
_kthread
 * 
	tkthread_id_t
;

49 typedef struct 
	s_kthread
 {

50 struct 
_kthread
 *
t_link
;

52 
caddr_t
 
t_stk
;

53 void (*
t_startpc
)();

54 struct 
cpu
 *
t_bound_cpu
;

55 short 
t_affinitycnt
;

56 short 
t_bind_cpu
;

57 
u_short
 
t_flag
;

58 
u_short
 
t_proc_flag
;

59 
u_char
 
t_schedflag
;

60 volatile char 
t_pre_sys
;

61 short 
t_preempt
;

62 
u_int
 
t_state
;

63 
pri_t
 
t_pri
;

64 
pri_t
 
t_epri
;

65 
label_t
 
t_pcb
;

67 long 
t_wchan0
;

68 
caddr_t
 
t_wchan
;

69 struct 
_sobj_ops
 *
t_sobj_ops
;

70 
id_t
 
t_cid
;

71 struct 
thread_ops
 *
t_clfuncs
;

72 void *
t_cldata
;

73 
ctxop_t
 *
t_ctx
;

74 
u_int
 
t_lofault
;

75 
label_t
 *
t_onfault
;

76 
label_t
 *
t_nofault
;

77 
caddr_t
 
t_swap
;

78 
lock_t
 
t_lock
;

79 
kcondvar_t
 
t_delay_cv
;

80 struct 
cpu
 *
t_cpu
;

81 struct 
_kthread
 *
t_intr
;

82 
u_int
 
t_did
;

83 
caddr_t
 
t_tnf_tpdp
;

88 
u_int
 
t_tid
;

89 int 
t_alarmid
;

90 struct 
itimerval
 
t_realitimer
;

91 int 
t_itimerid
;

92 struct 
sigqueue
 *
t_sigqueue
;

93 
k_sigset_t
 
t_sig
;

94 
k_sigset_t
 
t_hold
;

95 struct 
_kthread
 *
t_forw
;

96 struct 
_kthread
 *
t_back
;

97 
klwp_t
 *
t_lwp
;

98 struct 
proc
 *
t_procp
;

99 
caddr_t
 
t_audit_data
;

100 struct 
_kthread
 *
t_next
;

101 struct 
_kthread
 *
t_prev
;

102 struct 
vnode
 *
t_trace
;

103 
u_short
 
t_whystop
;

104 
u_short
 
t_whatstop
;

105 short 
t_sysnum
;

107 struct 
pollstate
 *
t_pollstate
;

108 struct 
cred
 *
t_cred
;

109 
clock_t
 
t_lbolt
;

110 
u_short
 
t_pctcpu
;

118 
disp_lock_t
 *
t_lockp
;

119 short 
t_oldspl
;

120 struct 
_disp
 *
t_disp_queue
;

121 
clock_t
 
t_disp_time
;

122 
u_int
 
t_kpri_req
;

139 union 
	u
{

140 struct 
	s
{

141 volatile char 
_t_astflag
;

142 volatile char 
_t_sig_check
;

143 volatile char 
_t_post_sys
;

144 volatile char 
_t_trapret
;

145 } 
_ts
;

146 volatile int 
_t_post_sys_ast
;

147 } 
_tu
;

148 #define 
	#t_astflag
 
_tu
.
_ts
.
_t_astflag


	)
149 #define 
	#t_sig_check
 
_tu
.
_ts
.
_t_sig_check


	)
150 #define 
	#t_post_sys
 
_tu
.
_ts
.
_t_post_sys


	)
151 #define 
	#t_trapret
 
_tu
.
_ts
.
_t_trapret


	)
152 #define 
	#t_post_sys_ast
 
_tu
.
_t_post_sys_ast


	)
158 
hrtime_t
 
t_waitrq
;

159 int 
t_mstate
;

160 struct 
	srprof
 {

161 int 
rp_anystate
;

162 
u_long
 
rp_state
[
NMSTATES
];

163 } *
t_rprof
;

171 
pirec_t
 *
t_prioinv
;

178 
turnstile_t
 *
t_ts
;

184 
u_int
 
t_mmuctx
;

191 struct 
	stsd_thread
 {

192 struct 
tsd_thread
 *
ts_next
;

193 struct 
tsd_thread
 *
ts_prev
;

194 
u_int
 
ts_nkeys
;

195 void **
ts_value
;

196 } *
t_tsd
;

198 #ifdef 
__DOS_EMUL


203 
caddr_t
 
t_v86data
;

205 
clock_t
 
t_stime
;

206 struct 
door_data
 *
t_door
;

207 
kmutex_t
 *
t_plockp
;

208 } 
	tkthread_t
;

221 #define 
	#T_INTR_THREAD
 0x0001

	)
222 #define 
	#T_WAKEABLE
 0x0002

	)
223 #define 
	#T_TOMASK
 0x0004

	)
224 #define 
	#T_TALLOCSTK
 0x0008

	)
225 #define 
	#T_LWPZOMB
 0x0010

	)
226 #define 
	#T_WOULDBLOCK
 0x0020

	)
227 #define 
	#T_DONTBLOCK
 0x0040

	)
228 #define 
	#T_DONTPEND
 0x0080

	)
229 #define 
	#T_SYS_PROF
 0x0100

	)
230 #define 
	#T_WAITCVSEM
 0x0200

	)
237 #define 
	#TP_WAITFOR
 0x01

	)
238 #define 
	#TP_HOLDLWP
 0x02

	)
239 #define 
	#TP_TWAIT
 0x04

	)
240 #define 
	#TP_LWPEXIT
 0x08

	)
241 #define 
	#TP_PRSTOP
 0x10

	)
242 #define 
	#TP_CHKPT
 0x20

	)
243 #define 
	#TP_EXITLWP
 0x40

	)
244 #define 
	#TP_PRVSTOP
 0x80

	)
245 #define 
	#TP_MSACCT
 0x100

	)
246 #define 
	#TP_STOPPING
 0x200

	)
252 #define 
	#TS_LOAD
 0x01

	)
253 #define 
	#TS_CSTART
 0x02

	)
254 #define 
	#TS_XSTART
 0x04

	)
255 #define 
	#TS_PSTART
 0x08

	)
256 #define 
	#TS_DONT_SWAP
 0x10

	)
257 #define 
	#TS_RESUME
 0x20

	)
258 #define 
	#TS_SWAPENQ
 0x40

	)
259 #define 
	#TS_ON_SWAPQ
 0x80

	)
260 #define 
	#TS_ALLSTART
 (
TS_CSTART
 | 
TS_XSTART
 | 
TS_PSTART
 | 
TS_RESUME
)

	)
265 #define 
	#aston
(
t
) ((t)->
t_astflag
 = 1)

	)
266 #define 
	#astoff
(
t
) ((t)->
t_astflag
 = 0)

	)
269 #define 
	#ISTOPPED
(
t
) ((t)->
t_state
 == 
TS_STOPPED
 && \

270 !((
t
)->
t_schedflag
 & 
TS_PSTART
))

	)
273 #define 
	#CPR_ISTOPPED
(
t
) ((t)->
t_state
 == 
TS_STOPPED
 && \

274 !((
t
)->
t_schedflag
 & 
TS_RESUME
))

	)
280 #define 
	#VSTOPPED
(
t
) ((t)->
t_proc_flag
 & 
TP_PRVSTOP
)

	)
283 #define 
	#CPR_VSTOPPED
(
t
) \

284 ((
t
)->
t_state
 == 
TS_SLEEP
 && \

285 (
t
)->
t_wchan0
 && \

286 ((
t
)->
t_flag
 & 
T_WAKEABLE
) && \

287 ((
t
)->
t_proc_flag
 & 
TP_CHKPT
))

	)
290 #define 
	#SUSPENDED
(
t
) ((t)->
t_state
 == 
TS_STOPPED
 && \

291 !((
t
)->
t_schedflag
 & 
TS_CSTART
))

	)
294 #define 
	#INHERITED
(
t
) ((t)->
t_epri
 != 0)

	)
297 #define 
	#DISP_PRIO
(
t
) (
	`INHERITED
(t) ? (t)->
t_epri
 : (t)->
t_pri
)

	)
300 #define 
	#ASSIGNED_PRIO
(
t
) ((t)->
t_pri
)

	)
306 #define 
	#SWAP_OK
(
t
) (!
	`LOCK_HELD
(&(t)->
t_lock
))

	)
329 #define 
	#proctot
(
x
) ((x)->
p_tlist
)

	)
330 #define 
	#proctolwp
(
x
) ((x)->
p_tlist
->
t_lwp
)

	)
331 #define 
	#ttolwp
(
x
) ((x)->
t_lwp
)

	)
332 #define 
	#ttoproc
(
x
) ((x)->
t_procp
)

	)
333 #define 
	#lwptot
(
x
) ((x)->
lwp_thread
)

	)
334 #define 
	#lwptoproc
(
x
) ((x)->
lwp_procp
)

	)
336 #define 
	#t_pc
 
t_pcb
.
val
[0]

	)
337 #define 
	#t_sp
 
t_pcb
.
val
[1]

	)
339 #define 
	#LWPCHAN
(
t
) ((
quad
 *)(&((t)->
t_wchan0
)))

	)
341 extern 
kthread_id_t
 
threadp
();

342 #define 
	#curthread
 (
	`threadp
())

	)
343 #define 
	#curproc
 (
	`ttoproc
(
curthread
))

	)
345 extern struct 
_kthread
 
t0
;

346 extern 
kmutex_t
 
pidlock
;

352 extern 
kmutex_t
 
thread_free_lock
;

354 extern 
kthread_t
 *
idtot
();

361 void 
thread_transition
(
kthread_id_t
);

362 void 
thread_lock
(
kthread_id_t
);

363 void 
thread_lock_high
(
kthread_id_t
);

364 void 
thread_onproc
(
kthread_id_t
, struct 
cpu
 *);

366 #define 
	#thread_unlock
(
t
) 
	`disp_lock_exit
((t)->
t_lockp
)

	)
367 #define 
	#thread_unlock_high
(
t
) 
	`disp_lock_exit_high
((t)->
t_lockp
)

	)
368 #define 
	#thread_unlock_nopreempt
(
t
) 
	`disp_lock_exit_nopreempt
((t)->
t_lockp
)

	)
370 #define 
	#THREAD_LOCK_HELD
(
t
) (
	`DISP_LOCK_HELD
((t)->
t_lockp
))

	)
372 extern 
disp_lock_t
 
transition_lock
;

373 extern 
disp_lock_t
 
stop_lock
;

375 
caddr_t
 
thread_stk_init
(caddr_t);

383 #define 
	#THREAD_KPRI_REQUEST
() (
curthread
->
t_kpri_req
++)

	)
384 #define 
	#THREAD_KPRI_RELEASE
() (
curthread
->
t_kpri_req
--)

	)
385 #define 
	#THREAD_KPRI_RELEASE_N
(
n
) (
curthread
->
t_kpri_req
 -= (n))

	)
390 #define 
	#THREAD_SET_STATE
(
tp
, 
state
, 
lp
) \

391 ((
tp
)->
t_state
 = 
state
, (tp)->
t_lockp
 = 
lp
)

	)
397 #define 
	#THREAD_TRANSITION
(
tp
) 
	`thread_transition
(tp);

	)
402 #define 
	#THREAD_TRANSITION_NOLOCK
(
tp
) ((tp)->
t_lockp
 = &
transition_lock
)

	)
408 #define 
	#THREAD_RUN
(
tp
, 
lp
) 
	`THREAD_SET_STATE
(tp, 
TS_RUN
, lp)

	)
414 #define 
	#THREAD_SWAP
(
tp
, 
lp
) 
	`THREAD_SET_STATE
(tp, 
TS_RUN
, lp)

	)
422 #define 
	#THREAD_STOP
(
tp
) \

423 { 
disp_lock_t
 *
lp
 = (
tp
)->
t_lockp
; \

424 
	`THREAD_SET_STATE
(
tp
, 
TS_STOPPED
, &
stop_lock
); \

425 
	`disp_lock_exit
(
lp
); \

426 }

	)
432 #define 
	#THREAD_ZOMB
(
tp
) 
	`THREAD_SET_STATE
(tp, 
TS_ZOMB
, 
NULL
)

	)
439 #define 
	#THREAD_ONPROC
(
tp
, 
cpu
) \

440 
	`THREAD_SET_STATE
(
tp
, 
TS_ONPROC
, &(
cpu
)->
cpu_thread_lock
)

	)
446 #define 
	#THREAD_SLEEP
(
tp
, 
lp
) { \

447 
disp_lock_t
 *
tlp
; \

448 
tlp
 = (
tp
)->
t_lockp
; \

449 
	`THREAD_SET_STATE
(
tp
, 
TS_SLEEP
, 
lp
); \

450 
	`disp_lock_exit_high
(
tlp
); \

451 }

	)
453 #ifdef 
__cplusplus


	@/usr/include/sys/timer.h

5 #ifndef 
_SYS_TIMER_H


6 #define 
	#_SYS_TIMER_H


	)
8 #pragma 
ident
 "@(#)timer.h 1.12 94/12/06 SMI"

10 #include 
	~<sys/types.h
>

11 #include 
	~<sys/proc.h
>

12 #include 
	~<sys/thread.h
>

14 #ifdef 
__cplusplus


18 #ifdef 
_KERNEL


20 #define 
	#_TIMER_MAX
 32

	)
22 #define 
	#timerspecisset
(
tvp
) ((tvp)->
tv_sec
 || (tvp)->
tv_nsec
)

	)
23 #define 
	#timerspeccmp
(
tvp
, 
uvp
) (((tvp)->
tv_sec
 - (uvp)->tv_sec) ? \

24 ((
tvp
)->
tv_sec
 - (
uvp
)->tv_sec):((tvp)->
tv_nsec
 - (uvp)->tv_nsec))

	)
25 #define 
	#timerspecclear
(
tvp
) ((tvp)->
tv_sec
 = (tvp)->
tv_nsec
 = 0)

	)
31 typedef struct 
	stimerstr
 {

32 int 
trs_flags
;

33 
clockid_t
 
trs_clock_id
;

34 
itimerspec_t
 
trs_itimer
;

35 struct 
sigqueue
 *
trs_sigqp
;

36 int 
trs_callout_id
;

37 int 
trs_overrun1
;

38 int 
trs_overrun2
;

39 union 
	u
{

40 
klwp_t
 *
trs_unlwp
;

41 struct 
proc
 *
trs_unproc
;

42 } 
trs_un
;

43 } 
	ttimerstr_t
;

45 #define 
	#TRS_INUSE
 0x1

	)
46 #define 
	#TRS_PERLWP
 0x2

	)
47 #define 
	#TRS_SIGNAL
 0x4

	)
48 #define 
	#TRS_PENDING
 0x8

	)
50 #define 
	#trs_lwp
 
trs_un
.
trs_unlwp


	)
51 #define 
	#trs_proc
 
trs_un
.
trs_unproc


	)
53 #ifdef 
__STDC__


54 extern void 
timer_func
(
sigqueue_t
 *);

55 extern void 
timer_exit
(void);

56 extern void 
timer_lwpexit
(void);

57 extern int 
hzto
(struct 
timeval
 *);

58 extern int 
timespectohz
(
timespec_t
 *, timespec_t);

59 extern int 
itimerspecfix
(
timespec_t
 *);

60 extern void 
timespecadd
(
timespec_t
 *, timespec_t *);

61 extern void 
timespecsub
(
timespec_t
 *, timespec_t *);

62 extern void 
timespecfix
(
timespec_t
 *);

64 extern void 
timer_func
();

65 extern void 
timer_exit
();

66 extern void 
timer_lwpexit
();

67 extern int 
hzto
();

68 extern int 
timespectohz
();

69 extern int 
itimerspecfix
();

70 extern void 
timespecadd
();

71 extern void 
timespecsub
();

72 extern void 
timespecfix
();

77 #ifdef 
__cplusplus


	@/usr/include/sys/user.h

8 #ifndef 
_SYS_USER_H


9 #define 
	#_SYS_USER_H


	)
11 #pragma 
ident
 "@(#)user.h 1.35 96/01/29 SMI"

13 #include 
	~<sys/types.h
>

14 #include 
	~<sys/signal.h
>

16 #ifdef 
__cplusplus


24 struct 
	sexdata
 {

25 struct 
vnode
 *
vp
;

26 
size_t
 
ux_tsize
;

27 
size_t
 
ux_dsize
;

28 
size_t
 
ux_bsize
;

29 
size_t
 
ux_lsize
;

30 long 
ux_nshlibs
;

31 short 
ux_mach
;

32 short 
ux_mag
;

33 
off_t
 
ux_toffset
;

34 
off_t
 
ux_doffset
;

35 
off_t
 
ux_loffset
;

36 
caddr_t
 
ux_txtorg
;

37 
caddr_t
 
ux_datorg
;

38 
caddr_t
 
ux_entloc
;

41 #ifdef 
__cplusplus


45 #if 
defined
(
_KERNEL
) || defined(
_KMEMUSER
)

47 #include 
	~<sys/param.h
>

48 #include 
	~<sys/pcb.h
>

49 #include 
	~<sys/siginfo.h
>

50 #include 
	~<sys/resource.h
>

51 #include 
	~<sys/time.h
>

52 #include 
	~<sys/auxv.h
>

53 #include 
	~<sys/errno.h
>

54 #include 
	~<sys/t_lock.h
>

56 #ifdef 
__cplusplus


71 #define 
	#NFPCHUNK
 24

	)
73 struct 
	suf_entry
 {

74 struct 
file
 *
uf_ofile
;

75 short 
uf_pofile
;

76 short 
uf_refcnt
;

78 typedef struct 
uf_entry
 
	tuf_entry_t
;

80 #define 
	#PSARGSZ
 80

	)
82 #define 
	#PSCOMSIZ
 14

	)
84 #define 
	#SYSMASKLEN
 7

	)
86 #define 
	#MAXCOMLEN
 16

	)
88 typedef struct 
	s
{

89 long 
word
[
SYSMASKLEN
];

90 } 
	tk_sysset_t
;

92 typedef struct 
	suser
 {

96 int 
u_execid
;

97 long 
u_execsz
;

98 
uint
 
u_tsize
;

99 
uint
 
u_dsize
;

100 
time_t
 
u_start
;

101 
clock_t
 
u_ticks
;

102 
kcondvar_t
 
u_cv
;

106 struct 
exdata
 
u_exdata
;

107 
auxv_t
 
u_auxv
[
NUM_AUX_VECTORS
];

108 char 
u_psargs
[
PSARGSZ
];

109 char 
u_comm
[
MAXCOMLEN
 + 1];

113 int 
u_argc
;

114 char **
u_argv
;

115 char **
u_envp
;

119 struct 
vnode
 *
u_cdir
;

120 struct 
vnode
 *
u_rdir
;

121 struct 
vnode
 *
u_ttyvp
;

122 
mode_t
 
u_cmask
;

123 long 
u_mem
;

124 char 
u_systrap
;

131 
o_pid_t
 *
u_ttyp
;

132 
o_dev_t
 
u_ttyd
;

138 
k_sysset_t
 
u_entrymask
;

139 
k_sysset_t
 
u_exitmask
;

140 
k_sigset_t
 
u_signodefer
;

141 
k_sigset_t
 
u_sigonstack
;

142 
k_sigset_t
 
u_sigresethand
;

143 
k_sigset_t
 
u_sigrestart
;

144 
k_sigset_t
 
u_sigmask
[
MAXSIG
];

145 void (*
u_signal
[
MAXSIG
])();

150 short 
u_nshmseg
;

151 char 
u_acflag
;

159 struct 
rlimit
 
u_rlimit
[
RLIM_NLIMITS
];

161 
kmutex_t
 
u_flock
;

162 int 
u_nofiles
;

163 struct 
uf_entry
 *
u_flist
;

164 #if 
defined
(
i386
) || defined(
__i386
)

165 void (*
u_sigreturn
)();

167 char **
u_auxvp
;

168 } 
	tuser_t
;

170 #include 
	~<sys/proc.h
>

172 #ifdef 
_KERNEL


173 #ifdef 
sun


174 #define 
	#u
 (
curproc
->
p_user
)

	)
177 #ifdef 
_KERNEL


178 #if 
defined
(
__STDC__
)

179 extern void 
addupc
(void(*)(), struct 
prof
 *, int);

181 extern void 
addupc
();

185 #ifdef 
__cplusplus


206 #include 
	~<sys/regset.h
>

208 #ifdef 
__cplusplus


212 #define 
	#PSARGSZ
 80

	)
214 typedef struct 
	suser
 {

215 
gregset_t
 
u_reg
;

216 
greg_t
 * 
u_ar0
;

217 char 
u_psargs
[
PSARGSZ
];

218 void (*
u_signal
[
MAXSIG
])();

219 int 
u_code
;

220 
caddr_t
 
u_addr
;

221 } 
	tuser_t
;

223 #ifdef 
__cplusplus


	@/usr/include/time.h

11 #ifndef 
_TIME_H


12 #define 
	#_TIME_H


	)
14 #pragma 
ident
 "@(#)time.h 1.23 95/08/28 SMI"

16 #include 
	~<sys/feature_tests.h
>

18 #ifdef 
__cplusplus


22 #ifndef 
NULL


23 #define 
	#NULL
 0

	)
26 #ifndef 
_SIZE_T


27 #define 
	#_SIZE_T


	)
28 typedef unsigned 
	tsize_t
;

30 #ifndef 
_CLOCK_T


31 #define 
	#_CLOCK_T


	)
32 typedef long 
	tclock_t
;

34 #ifndef 
_TIME_T


35 #define 
	#_TIME_T


	)
36 typedef long 
	ttime_t
;

38 #ifndef 
_CLOCKID_T


39 #define 
	#_CLOCKID_T


	)
40 typedef int 
	tclockid_t
;

42 #ifndef 
_TIMER_T


43 #define 
	#_TIMER_T


	)
44 typedef int 
	ttimer_t
;

47 #define 
	#CLOCKS_PER_SEC
 1000000

	)
49 struct 
	stm
 {

50 int 
	gtm_sec
;

51 int 
	gtm_min
;

52 int 
	gtm_hour
;

53 int 
	gtm_mday
;

54 int 
	gtm_mon
;

55 int 
	gtm_year
;

56 int 
	gtm_wday
;

57 int 
	gtm_yday
;

58 int 
	gtm_isdst
;

61 #if 
defined
(
__STDC__
)

63 extern 
clock_t
 
clock
(void);

64 extern double 
difftime
(
time_t
, time_t);

65 extern 
time_t
 
mktime
(struct 
tm
 *);

66 extern 
time_t
 
time
(time_t *);

67 extern char *
asctime
(const struct 
tm
 *);

68 extern char *
ctime
(const 
time_t
 *);

69 extern struct 
tm
 *
gmtime
(const 
time_t
 *);

70 extern struct 
tm
 *
localtime
(const 
time_t
 *);

71 extern 
size_t
 
strftime
(char *, size_t, const char *, const struct 
tm
 *);

73 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

74 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

75 extern struct 
tm
 *
gmtime_r
(const 
time_t
 *, struct tm *);

76 extern struct 
tm
 *
localtime_r
(const 
time_t
 *, struct tm *);

79 #if (
__STDC__
 == 0 && !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

80 (
defined
(
_XOPEN_SOURCE
) && 
	g_XOPEN_VERSION
 - 0 == 4) || \

81 
defined
(
__EXTENSIONS__
)

82 extern char *
strptime
(const char *, const char *, struct 
tm
 *);

85 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

86 !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

87 (
	g_POSIX_C_SOURCE
 > 2)

89 #include 
	~<sys/time.h
>

90 #include 
	~<sys/siginfo.h
>

91 extern int 
clock_getres
(
clockid_t
, struct 
timespec
 *);

92 extern int 
clock_gettime
(
clockid_t
, struct 
timespec
 *);

93 extern int 
clock_settime
(
clockid_t
, const struct 
timespec
 *);

95 extern int 
timer_create
(
clockid_t
, struct 
sigevent
 *, 
timer_t
 *);

96 extern int 
timer_delete
(
timer_t
);

97 extern int 
timer_getoverrun
(
timer_t
);

98 extern int 
timer_gettime
(
timer_t
, struct 
itimerspec
 *);

99 extern int 
timer_settime
(
timer_t
, int, const struct 
itimerspec
 *,

100 struct 
itimerspec
 *);

101 extern int 
nanosleep
(const struct 
timespec
 *, struct timespec *);

105 #if 
defined
(
__EXTENSIONS__
) || 
__STDC__
 == 0 || \

106 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

107 extern void 
tzset
(void);

109 extern char *
tzname
[2];

111 #ifndef 
CLK_TCK


112 extern long 
_sysconf
(int);

113 #define 
	#CLK_TCK
 
	`_sysconf
(3)

	)
117 #if 
defined
(
__EXTENSIONS__
) || (
__STDC__
 == 0 && \

118 !
defined
(
_POSIX_C_SOURCE
)) || defined(
_XOPEN_SOURCE
)

119 extern long 
timezone
;

120 extern int 
daylight
;

125 #if 
__STDC__
 == 0 && !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)

126 extern int 
cftime
(char *, char *, const 
time_t
 *);

127 extern int 
ascftime
(char *, const char *, const struct 
tm
 *);

128 extern long 
altzone
;

129 extern struct 
tm
 *
getdate
(const char *);

131 #ifdef 
_REENTRANT


132 #undef 
getdate_err


133 #define 
	#getdate_err
 *(int *)
	`_getdate_err_addr
()

	)
134 extern int *
_getdate_err_addr
(void);

136 extern int 
getdate_err
;

142 extern long 
clock
();

143 extern double 
difftime
();

144 extern 
time_t
 
mktime
();

145 extern 
time_t
 
time
();

146 extern 
size_t
 
strftime
();

147 extern struct 
tm
 *
gmtime
(), *
localtime
();

148 extern char *
ctime
(), *
asctime
(), *
strptime
();

149 extern int 
cftime
(), 
ascftime
();

150 extern void 
tzset
();

152 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

153 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L)

154 extern struct 
tm
 *
gmtime_r
();

155 extern struct 
tm
 *
localtime_r
();

158 extern long 
timezone
, 
altzone
;

159 extern int 
daylight
;

160 extern char *
tzname
[2];

162 extern struct 
tm
 *
getdate
();

163 #ifdef 
_REENTRANT


164 #undef 
getdate_err


165 #define 
	#getdate_err
 *(int *)
	`_getdate_err_addr
()

	)
166 extern int *
_getdate_err_addr
();

168 extern int 
getdate_err
;

176 #if 
defined
(
__EXTENSIONS__
) || defined(
_REENTRANT
) || \

177 (
	g_POSIX_C_SOURCE
 - 0 >= 199506L) || 
defined
(
_POSIX_PTHREAD_SEMANTICS
)

179 #if 
defined
(
__STDC__
)

181 #if (
_POSIX_C_SOURCE
 - 0 >= 199506L) || 
defined
(
_POSIX_PTHREAD_SEMANTICS
)

183 #ifdef 
__PRAGMA_REDEFINE_EXTNAME


184 extern char *
asctime_r
(const struct 
tm
 *, char *);

185 extern char *
ctime_r
(const 
time_t
 *, char *);

186 #pragma 
redefine_extname
 
ctime_r
 
__posix_ctime_r


187 #pragma 
redefine_extname
 
asctime_r
 
__posix_asctime_r


191 
asctime_r
(const struct 
tm
 *
__tm
, char *
__buf
)

193 extern char *
__posix_asctime_r
(const struct 
tm
 *, char *);

194 return (
__posix_asctime_r
(
__tm
, 
__buf
));

197 
ctime_r
(const 
time_t
 *
__time
, char *
__buf
)

199 extern char *
__posix_ctime_r
(const 
time_t
 *, char *);

200 return (
__posix_ctime_r
(
__time
, 
__buf
));

206 extern char *
asctime_r
(const struct 
tm
 *, char *, int);

207 extern char *
ctime_r
(const 
time_t
 *, char *, int);

213 #if (
_POSIX_C_SOURCE
 - 0 >= 199506L) || 
defined
(
_POSIX_PTHREAD_SEMANTICS
)

215 #ifdef 
__PRAGMA_REDEFINE_EXTNAME


216 extern char *
asctime_r
();

217 extern char *
ctime_r
();

218 #pragma 
redefine_extname
 
asctime_r
 
__posix_asctime_r


219 #pragma 
redefine_extname
 
ctime_r
 
__posix_ctime_r


223 
asctime_r
(
__tm
, 
__buf
)

224 struct 
tm
 *
	g__tm
;

225 char *
	g__buf
;

227 extern char *
__posix_asctime_r
();

228 return (
__posix_asctime_r
(
__tm
, 
__buf
));

231 
ctime_r
(
__time
, 
__buf
)

232 
time_t
 *
	g__time
;

233 char *
	g__buf
;

235 extern char *
__posix_ctime_r
();

236 return (
__posix_ctime_r
(
__time
, 
__buf
));

242 extern char *
asctime_r
();

243 extern char *
ctime_r
();

251 #ifdef 
__cplusplus


	@/usr/include/sys/auxv.h

8 #ifndef 
_SYS_AUXV_H


9 #define 
	#_SYS_AUXV_H


	)
11 #pragma 
ident
 "@(#)auxv.h 1.17 96/01/29 SMI"

13 #ifdef 
__cplusplus


17 #if !
defined
(
_ASM
)

19 
	s
{

20 int 
a_type
;

21 union 
	u
{

22 long 
a_val
;

23 #ifdef 
__STDC__


24 void *
a_ptr
;

26 char *
a_ptr
;

28 void (*
a_fcn
)();

29 } 
a_un
;

30 } 
	tauxv_t
;

33 #define 
	#AT_NULL
 0

	)
34 #define 
	#AT_IGNORE
 1

	)
35 #define 
	#AT_EXECFD
 2

	)
36 #define 
	#AT_PHDR
 3

	)
37 #define 
	#AT_PHENT
 4

	)
38 #define 
	#AT_PHNUM
 5

	)
39 #define 
	#AT_PAGESZ
 6

	)
40 #define 
	#AT_BASE
 7

	)
41 #define 
	#AT_FLAGS
 8

	)
42 #define 
	#AT_ENTRY
 9

	)
43 #define 
	#AT_DCACHEBSIZE
 10

	)
44 #define 
	#AT_ICACHEBSIZE
 11

	)
45 #define 
	#AT_UCACHEBSIZE
 12

	)
47 #define 
	#AT_SUN_UID
 2000

	)
48 #define 
	#AT_SUN_RUID
 2001

	)
49 #define 
	#AT_SUN_GID
 2002

	)
50 #define 
	#AT_SUN_RGID
 2003

	)
55 #define 
	#AT_SUN_LDELF
 2004

	)
56 #define 
	#AT_SUN_LDSHDR
 2005

	)
57 #define 
	#AT_SUN_LDNAME
 2006

	)
58 #define 
	#AT_SUN_LPAGESZ
 2007

	)
64 #define 
	#AT_SUN_PLATFORM
 2008

	)
69 #define 
	#AT_SUN_HWCAP
 2009

	)
71 #if 
defined
(
_KERNEL
)

72 extern int 
auxv_hwcap
;

73 extern int 
kauxv_hwcap
;

80 #define 
	#AT_SUN_IFLUSH
 2010

	)
87 #ifndef 
__ppc


88 #define 
	#NUM_GEN_VECTORS
 8

	)
90 #define 
	#NUM_GEN_VECTORS
 12

	)
93 #define 
	#NUM_SUN_VECTORS
 10

	)
95 #define 
	#NUM_AUX_VECTORS
 (
NUM_GEN_VECTORS
 + 
NUM_SUN_VECTORS
)

	)
97 #ifdef 
__cplusplus


	@/usr/include/sys/class.h

8 #ifndef 
_SYS_CLASS_H


9 #define 
	#_SYS_CLASS_H


	)
11 #pragma 
ident
 "@(#)class.h 1.29 97/05/28 SMI"

13 #include 
	~<sys/t_lock.h
>

15 #ifdef 
__cplusplus


29 typedef struct 
	ssclass
 {

30 char *
cl_name
;

31 void (*
cl_init
)();

32 struct 
classfuncs
 *
cl_funcs
;

33 
krwlock_t
 *
cl_lock
;

34 int 
cl_count
;

35 
size_t
 
cl_size
;

36 } 
	tsclass_t
;

38 #define 
	#STATIC_SCHED
 (
krwlock_t
 *)0xffffffff

	)
39 #define 
	#LOADABLE_SCHED
(
s
) ((s)->
cl_lock
 != 
STATIC_SCHED
)

	)
40 #define 
	#SCHED_INSTALLED
(
s
) ((s)->
cl_funcs
 != 
NULL
)

	)
41 #define 
	#ALLOCATED_SCHED
(
s
) ((s)->
cl_lock
 != 
NULL
)

	)
43 #ifdef 
_KERNEL


44 extern int 
nclass
;

45 extern char *
initclass
;

46 extern char *
defaultclass
;

47 extern char *
extraclass
;

48 extern struct 
sclass
 sclass[];

56 typedef struct 
	sclassfuncs
 {

57 struct 
	sclass_ops
 {

58 int (*
	gcl_admin
)();

59 int (*
	gcl_getclinfo
)();

60 int (*
	gcl_parmsin
)();

61 int (*
	gcl_parmsout
)();

62 } 
	gsclass
;

63 struct 
	sthread_ops
 {

64 int (*
	gcl_enterclass
)();

65 void (*
	gcl_exitclass
)();

66 int (*
	gcl_fork
)();

67 void (*
	gcl_forkret
)();

68 void (*
	gcl_parmsget
)();

69 int (*
	gcl_parmsset
)();

70 void (*
	gcl_stop
)();

71 
pri_t
 (*
cl_swapin
)();

72 
pri_t
 (*
cl_swapout
)();

73 void (*
	gcl_trapret
)();

74 void (*
	gcl_preempt
)();

75 void (*
	gcl_setrun
)();

76 void (*
	gcl_sleep
)();

77 void (*
	gcl_tick
)();

78 void (*
	gcl_wakeup
)();

79 int (*
	gcl_donice
)();

80 
pri_t
 (*
cl_globpri
)();

81 void (*
	gcl_set_process_group
)(
pid_t
 
	gsid
, \

82 
pid_t
 
	gbg_pgid
, pid_t 
	gfg_pgid
);

83 } 
	gthread
;

84 } 
	tclassfuncs_t
;

86 #define 
	#CL_ADMIN
(
clp
, 
uaddr
, 
reqpcredp
) \

87 (*(
clp
)->
cl_funcs
->
sclass
.
cl_admin
)(
uaddr
, 
reqpcredp
)

	)
89 #define 
	#CL_ENTERCLASS
(
t
, 
cid
, 
clparmsp
, 
credp
, 
bufp
) \

90 (
sclass
[
cid
].
cl_funcs
->
thread
.
cl_enterclass
) (
t
, cid, 
clparmsp
, \

91 
credp
, 
bufp
)

	)
93 #define 
	#CL_EXITCLASS
(
cid
, 
clprocp
)\

94 (
sclass
[
cid
].
cl_funcs
->
thread
.
cl_exitclass
) (
clprocp
)

	)
96 #define 
	#CL_FORK
(
tp
, 
ctp
, 
bufp
) \

97 (*(
tp
)->
t_clfuncs
->
cl_fork
) (tp, 
ctp
, 
bufp
)

	)
99 #define 
	#CL_FORKRET
(
t
, 
ct
) (*(t)->
t_clfuncs
->
cl_forkret
)(t, ct)

	)
101 #define 
	#CL_GETCLINFO
(
clp
, 
clinfop
) \

102 (*(
clp
)->
cl_funcs
->
sclass
.
cl_getclinfo
)(
clinfop
)

	)
104 #define 
	#CL_PARMSGET
(
t
, 
clparmsp
) \

105 (*(
t
)->
t_clfuncs
->
cl_parmsget
)(t->
t_cldata
, 
clparmsp
)

	)
107 #define 
	#CL_PARMSIN
(
clp
, 
clparmsp
, 
curpcid
, 
curpcredp
, 
tpcid
, 
tpcredp
, 
tpclpp
) \

108 (
clp
)->
cl_funcs
->
sclass
.
	`cl_parmsin
(
clparmsp
, 
curpcid
, 
curpcredp
, \

109 
tpcid
, 
tpcredp
, 
tpclpp
)

	)
111 #define 
	#CL_PARMSOUT
(
clp
, 
clparmsp
, 
curpcid
, 
curpcredp
, 
tpcid
, 
tpcredp
, 
tpclpp
) \

112 (
clp
)->
cl_funcs
->
sclass
.
	`cl_parmsout
(
clparmsp
, 
curpcid
, 
curpcredp
, \

113 
tpcid
, 
tpcredp
, 
tpclpp
)

	)
115 #define 
	#CL_PARMSSET
(
t
, 
clparmsp
, 
cid
, 
curpcredp
) \

116 (*(
t
)->
t_clfuncs
->
cl_parmsset
)(
clparmsp
, t->
t_cldata
, 
cid
, 
curpcredp
)

	)
118 #define 
	#CL_PREEMPT
(
tp
) (*(tp)->
t_clfuncs
->
cl_preempt
)(tp)

	)
120 #define 
	#CL_SETRUN
(
tp
) (*(tp)->
t_clfuncs
->
cl_setrun
)(tp)

	)
122 #define 
	#CL_SLEEP
(
tp
, 
disp
) \

123 (*(
tp
)->
t_clfuncs
->
cl_sleep
)(tp, 
disp
)

	)
125 #define 
	#CL_STOP
(
t
, 
why
, 
what
) \

126 (*(
t
)->
t_clfuncs
->
cl_stop
)(t, 
why
, 
what
)

	)
128 #define 
	#CL_SWAPIN
(
t
, 
flags
) \

129 (*(
t
)->
t_clfuncs
->
cl_swapin
)(t, 
flags
)

	)
131 #define 
	#CL_SWAPOUT
(
t
, 
flags
) \

132 (*(
t
)->
t_clfuncs
->
cl_swapout
)(t, 
flags
)

	)
134 #define 
	#CL_TICK
(
t
) (*(t)->
t_clfuncs
->
cl_tick
)(t)

	)
136 #define 
	#CL_TRAPRET
(
t
) (*(t)->
t_clfuncs
->
cl_trapret
)(t)

	)
138 #define 
	#CL_WAKEUP
(
t
) (*(t)->
t_clfuncs
->
cl_wakeup
)(t)

	)
140 #define 
	#CL_DONICE
(
t
, 
cr
, 
inc
, 
ret
) (*(t)->
t_clfuncs
->
cl_donice
)(t, cr, inc, ret)

	)
142 #define 
	#CL_GLOBPRI
(
t
) (*(t)->
t_clfuncs
->
cl_globpri
)(t->
t_cldata
)

	)
144 #define 
	#CL_SET_PROCESS_GROUP
(
t
, 
s
, 
b
, 
f
) \

145 (*(
t
)->
t_clfuncs
->
cl_set_process_group
)(
s
, 
b
, 
f
)

	)
147 #ifdef 
__cplusplus


	@/usr/include/sys/dki_lkinfo.h

5 #ifndef 
_SYS_DKI_LKINFO_H


6 #define 
	#_SYS_DKI_LKINFO_H


	)
8 #pragma 
ident
 "@(#)dki_lkinfo.h 1.8 93/05/03 SMI"

10 #include 
	~<sys/types.h
>

11 #include 
	~<sys/dl.h
>

13 #ifdef 
__cplusplus


21 typedef struct 
	slkinfo
 {

22 char *
lk_name
;

23 int 
lk_flags
;

24 long 
lk_pad
[2];

25 } 
	tlkinfo_t
;

27 typedef struct 
	s_lkstat_t
 {

28 
lkinfo_t
 *
ls_infop
;

29 
ulong_t
 
ls_wrcnt
;

30 
ulong_t
 
ls_rdcnt
;

31 
ulong_t
 
ls_solordcnt
;

32 
ulong_t
 
ls_fail
;

34 union 
	u
{

35 
dl_t
 
lsu_time
;

36 struct 
_lkstat_t
 *
lsu_next
;

37 } 
un
;

38 #define 
	#ls_stime
 
un
.
lsu_time


	)
39 
dl_t
 
ls_wtime
;

40 
dl_t
 
ls_htime
;

41 } 
	tlkstat_t
;

43 typedef struct 
	slkstat_sum
 {

44 
lkstat_t
 *
sp
;

45 struct 
lkstat_sum
 *
next
;

46 } 
	tlkstat_sum_t
;

51 #define 
	#NOSTATS
 1

	)
54 #define 
	#LSB_NLKDS
 91

	)
56 typedef struct 
	slksblk
 {

57 struct 
lksblk
 *
lsb_prev
, *
lsb_next
;

58 int 
lsb_nfree
;

59 
lkstat_t
 *
lsb_free
;

60 
lkstat_t
 
lsb_bufs
[
LSB_NLKDS
];

61 } 
	tlksblk_t
;

63 #ifdef 
__STDC__


64 extern 
lkstat_t
 *
lkstat_alloc
(
lkinfo_t
 *, int);

65 extern void 
lkstat_free
(
lkstat_t
 *, int);

66 extern void 
lkstat_sum_on_destroy
(
lkstat_t
 *);

67 extern void * 
startup_alloc
(
size_t
, void **);

68 extern void 
startup_free
(void *, 
size_t
, void **);

71 #ifdef 
__cplusplus


	@/usr/include/sys/errno.h

8 #ifndef 
_SYS_ERRNO_H


9 #define 
	#_SYS_ERRNO_H


	)
11 #pragma 
ident
 "@(#)errno.h 1.15 95/01/22 SMI"

34 #ifdef 
__cplusplus


42 #define 
	#EPERM
 1

	)
43 #define 
	#ENOENT
 2

	)
44 #define 
	#ESRCH
 3

	)
45 #define 
	#EINTR
 4

	)
46 #define 
	#EIO
 5

	)
47 #define 
	#ENXIO
 6

	)
48 #define 
	#E2BIG
 7

	)
49 #define 
	#ENOEXEC
 8

	)
50 #define 
	#EBADF
 9

	)
51 #define 
	#ECHILD
 10

	)
52 #define 
	#EAGAIN
 11

	)
53 #define 
	#ENOMEM
 12

	)
54 #define 
	#EACCES
 13

	)
55 #define 
	#EFAULT
 14

	)
56 #define 
	#ENOTBLK
 15

	)
57 #define 
	#EBUSY
 16

	)
58 #define 
	#EEXIST
 17

	)
59 #define 
	#EXDEV
 18

	)
60 #define 
	#ENODEV
 19

	)
61 #define 
	#ENOTDIR
 20

	)
62 #define 
	#EISDIR
 21

	)
63 #define 
	#EINVAL
 22

	)
64 #define 
	#ENFILE
 23

	)
65 #define 
	#EMFILE
 24

	)
66 #define 
	#ENOTTY
 25

	)
67 #define 
	#ETXTBSY
 26

	)
68 #define 
	#EFBIG
 27

	)
69 #define 
	#ENOSPC
 28

	)
70 #define 
	#ESPIPE
 29

	)
71 #define 
	#EROFS
 30

	)
72 #define 
	#EMLINK
 31

	)
73 #define 
	#EPIPE
 32

	)
74 #define 
	#EDOM
 33

	)
75 #define 
	#ERANGE
 34

	)
76 #define 
	#ENOMSG
 35

	)
77 #define 
	#EIDRM
 36

	)
78 #define 
	#ECHRNG
 37

	)
79 #define 
	#EL2NSYNC
 38

	)
80 #define 
	#EL3HLT
 39

	)
81 #define 
	#EL3RST
 40

	)
82 #define 
	#ELNRNG
 41

	)
83 #define 
	#EUNATCH
 42

	)
84 #define 
	#ENOCSI
 43

	)
85 #define 
	#EL2HLT
 44

	)
86 #define 
	#EDEADLK
 45

	)
87 #define 
	#ENOLCK
 46

	)
88 #define 
	#ECANCELED
 47

	)
89 #define 
	#ENOTSUP
 48

	)
92 #define 
	#EDQUOT
 49

	)
95 #define 
	#EBADE
 50

	)
96 #define 
	#EBADR
 51

	)
97 #define 
	#EXFULL
 52

	)
98 #define 
	#ENOANO
 53

	)
99 #define 
	#EBADRQC
 54

	)
100 #define 
	#EBADSLT
 55

	)
101 #define 
	#EDEADLOCK
 56

	)
103 #define 
	#EBFONT
 57

	)
106 #define 
	#ENOSTR
 60

	)
107 #define 
	#ENODATA
 61

	)
108 #define 
	#ETIME
 62

	)
109 #define 
	#ENOSR
 63

	)
111 #define 
	#ENONET
 64

	)
112 #define 
	#ENOPKG
 65

	)
113 #define 
	#EREMOTE
 66

	)
114 #define 
	#ENOLINK
 67

	)
115 #define 
	#EADV
 68

	)
116 #define 
	#ESRMNT
 69

	)
118 #define 
	#ECOMM
 70

	)
119 #define 
	#EPROTO
 71

	)
120 #define 
	#EMULTIHOP
 74

	)
121 #define 
	#EBADMSG
 77

	)
122 #define 
	#ENAMETOOLONG
 78

	)
123 #define 
	#EOVERFLOW
 79

	)
124 #define 
	#ENOTUNIQ
 80

	)
125 #define 
	#EBADFD
 81

	)
126 #define 
	#EREMCHG
 82

	)
129 #define 
	#ELIBACC
 83

	)
130 #define 
	#ELIBBAD
 84

	)
131 #define 
	#ELIBSCN
 85

	)
132 #define 
	#ELIBMAX
 86

	)
133 #define 
	#ELIBEXEC
 87

	)
134 #define 
	#EILSEQ
 88

	)
135 #define 
	#ENOSYS
 89

	)
136 #define 
	#ELOOP
 90

	)
137 #define 
	#ERESTART
 91

	)
138 #define 
	#ESTRPIPE
 92

	)
139 #define 
	#ENOTEMPTY
 93

	)
140 #define 
	#EUSERS
 94

	)
144 #define 
	#ENOTSOCK
 95

	)
145 #define 
	#EDESTADDRREQ
 96

	)
146 #define 
	#EMSGSIZE
 97

	)
147 #define 
	#EPROTOTYPE
 98

	)
148 #define 
	#ENOPROTOOPT
 99

	)
149 #define 
	#EPROTONOSUPPORT
 120

	)
150 #define 
	#ESOCKTNOSUPPORT
 121

	)
151 #define 
	#EOPNOTSUPP
 122

	)
152 #define 
	#EPFNOSUPPORT
 123

	)
153 #define 
	#EAFNOSUPPORT
 124

	)
155 #define 
	#EADDRINUSE
 125

	)
156 #define 
	#EADDRNOTAVAIL
 126

	)
158 #define 
	#ENETDOWN
 127

	)
159 #define 
	#ENETUNREACH
 128

	)
160 #define 
	#ENETRESET
 129

	)
162 #define 
	#ECONNABORTED
 130

	)
163 #define 
	#ECONNRESET
 131

	)
164 #define 
	#ENOBUFS
 132

	)
165 #define 
	#EISCONN
 133

	)
166 #define 
	#ENOTCONN
 134

	)
168 #define 
	#ESHUTDOWN
 143

	)
169 #define 
	#ETOOMANYREFS
 144

	)
170 #define 
	#ETIMEDOUT
 145

	)
171 #define 
	#ECONNREFUSED
 146

	)
172 #define 
	#EHOSTDOWN
 147

	)
173 #define 
	#EHOSTUNREACH
 148

	)
174 #define 
	#EWOULDBLOCK
 
EAGAIN


	)
175 #define 
	#EALREADY
 149

	)
176 #define 
	#EINPROGRESS
 150

	)
179 #define 
	#ESTALE
 151

	)
181 #ifdef 
__cplusplus


	@/usr/include/sys/klwp.h

5 #ifndef 
_SYS_KLWP_H


6 #define 
	#_SYS_KLWP_H


	)
8 #pragma 
ident
 "@(#)klwp.h 1.21 95/02/17 SMI"

10 #include 
	~<sys/types.h
>

11 #include 
	~<sys/condvar.h
>

12 #include 
	~<sys/thread.h
>

13 #include 
	~<sys/signal.h
>

14 #include 
	~<sys/siginfo.h
>

15 #include 
	~<sys/pcb.h
>

16 #include 
	~<sys/time.h
>

17 #include 
	~<sys/msacct.h
>

18 #include 
	~<sys/ucontext.h
>

19 #include 
	~<sys/lwp.h
>

21 #if (
defined
(
_KERNEL
) || defined(
_KMEMUSER
)) && defined(
_MACHDEP
)

22 #include 
	~<sys/machparam.h
>

25 #ifdef 
__cplusplus


34 #define 
	#MAXSYSARGS
 8

	)
37 #define 
	#NORMALRETURN
 0

	)
38 #define 
	#JUSTRETURN
 1

	)
39 #define 
	#RESTARTSYS
 2

	)
44 struct 
	slrusage
 {

45 
u_long
 
minflt
;

46 
u_long
 
majflt
;

47 
u_long
 
nswap
;

48 
u_long
 
inblock
;

49 
u_long
 
oublock
;

50 
u_long
 
msgsnd
;

51 
u_long
 
msgrcv
;

52 
u_long
 
nsignals
;

53 
u_long
 
nvcsw
;

54 
u_long
 
nivcsw
;

55 
u_long
 
sysc
;

56 
u_long
 
ioch
;

59 typedef struct 
_klwp
 *
	tklwp_id_t
;

61 typedef struct 
	s_klwp
 {

65 struct 
pcb
 
lwp_pcb
;

66 struct 
ucontext
 *
lwp_oldcontext
;

71 int *
lwp_ap
;

72 int 
lwp_errno
;

76 char 
lwp_error
;

77 char 
lwp_eosys
;

78 char 
lwp_argsaved
;

79 int 
lwp_arg
[
MAXSYSARGS
];

80 void *
lwp_regs
;

81 void *
lwp_fpu
;

82 
label_t
 
lwp_qsav
;

87 
u_char
 
lwp_cursig
;

88 
u_char
 
lwp_curflt
;

89 
u_char
 
lwp_sysabort
;

90 
u_char
 
lwp_asleep
;

91 
stack_t
 
lwp_sigaltstack
;

92 struct 
sigqueue
 *
lwp_curinfo
;

93 
k_siginfo_t
 
lwp_siginfo
;

94 
k_sigset_t
 
lwp_sigoldmask
;

100 struct 
	sprof
 {

101 short *
pr_base
;

102 unsigned 
pr_size
;

103 unsigned 
pr_off
;

104 unsigned 
pr_scale
;

105 } 
lwp_prof
;

106 
clock_t
 
lwp_scall_start
;

118 struct 
	smstate
 {

119 int 
ms_prev
;

120 
hrtime_t
 
ms_start
;

121 
hrtime_t
 
ms_term
;

122 
hrtime_t
 
ms_state_start
;

123 
hrtime_t
 
ms_acct
[
NMSTATES
];

124 } 
lwp_mstate
;

129 struct 
lrusage
 
lwp_ru
;

134 int 
lwp_lastfault
;

135 
caddr_t
 
lwp_lastfaddr
;

140 struct 
itimerval
 
lwp_timer
[3];

145 char 
lwp_oweupc
;

146 char 
lwp_state
;

147 
u_short
 
lwp_nostop
;

148 
kcondvar_t
 
lwp_cv
;

153 
clock_t
 
lwp_utime
;

154 
clock_t
 
lwp_stime
;

159 struct 
_kthread
 *
lwp_thread
;

160 struct 
proc
 *
lwp_procp
;

161 } 
	tklwp_t
;

164 #define 
	#LWP_USER
 0x01

	)
165 #define 
	#LWP_SYS
 0x02

	)
167 #define 
	#LWPNULL
 (
klwp_t
 *)0

	)
169 #if 
defined
(
_KERNEL
)

170 extern int 
lwp_default_stksize
;

171 extern int 
lwp_reapcnt
;

173 struct 
	g_kthread_t
;

174 extern struct 
_kthread
 *
lwp_deathrow
;

179 #ifdef 
__cplusplus


	@/usr/include/sys/param.h

31 #ifndef 
_SYS_PARAM_H


32 #define 
	#_SYS_PARAM_H


	)
34 #pragma 
ident
 "@(#)param.h 1.34 95/11/05 SMI"

36 #ifndef 
_ASM


37 #include 
	~<sys/types.h
>

38 #include 
	~<sys/isa_defs.h
>

42 #ifdef 
__cplusplus


50 #ifndef 
_POSIX_VDISABLE


51 #define 
	#_POSIX_VDISABLE
 0

	)
54 #ifndef 
MAX_INPUT


55 #define 
	#MAX_INPUT
 512

	)
58 #ifndef 
MAX_CANON


59 #define 
	#MAX_CANON
 256

	)
62 #define 
	#UID_NOBODY
 60001

	)
63 #define 
	#GID_NOBODY
 
UID_NOBODY


	)
65 #define 
	#UID_NOACCESS
 60002

	)
67 #define 
	#MAXPID
 30000

	)
68 #define 
	#MAXUID
 2147483647

	)
69 #define 
	#MAXLINK
 32767

	)
71 #define 
	#NMOUNT
 40

	)
73 #define 
	#CANBSIZ
 256

	)
75 #define 
	#NOFILE
 20

	)
84 #define 
	#NGROUPS_UMIN
 0

	)
85 #define 
	#NGROUPS_UMAX
 32

	)
91 #define 
	#NGROUPS_MAX_DEFAULT
 16

	)
97 #define 
	#PMASK
 0177

	)
98 #define 
	#PCATCH
 0400

	)
99 #define 
	#PNOSTOP
 01000

	)
100 #define 
	#PSWP
 0

	)
101 #define 
	#PINOD
 10

	)
102 #define 
	#PSNDD
 
PINOD


	)
103 #define 
	#PAMAP
 
PINOD


	)
104 #define 
	#PPMAP
 
PAMAP


	)
105 #define 
	#PRIBIO
 20

	)
106 #define 
	#PZERO
 25

	)
107 #define 
	#PMEM
 0

	)
108 #define 
	#NZERO
 20

	)
109 #define 
	#PPIPE
 26

	)
110 #define 
	#PVFS
 27

	)
111 #define 
	#PWAIT
 30

	)
112 #define 
	#PLOCK
 35

	)
113 #define 
	#PSLEP
 39

	)
114 #define 
	#PUSER
 60

	)
115 #define 
	#PIDLE
 127

	)
121 #define 
	#NBPW
 sizeof (int)

	)
122 #ifndef 
NULL


123 #define 
	#NULL
 0

	)
125 #define 
	#CMASK
 0

	)
126 #define 
	#CDLIMIT
 (1L<<11)

	)
127 #define 
	#NBPS
 0x20000

	)
128 #define 
	#NBPSCTR
 512

	)
129 #define 
	#UBSIZE
 512

	)
130 #define 
	#SCTRSHFT
 9

	)
132 #ifdef 
_LITTLE_ENDIAN


133 #define 
	#lobyte
(
X
) (((unsigned char *)&(X))[0])

	)
134 #define 
	#hibyte
(
X
) (((unsigned char *)&(X))[1])

	)
135 #define 
	#loword
(
X
) (((
ushort
 *)&(X))[0])

	)
136 #define 
	#hiword
(
X
) (((
ushort
 *)&(X))[1])

	)
138 #ifdef 
_BIG_ENDIAN


139 #define 
	#lobyte
(
X
) (((unsigned char *)&(X))[1])

	)
140 #define 
	#hibyte
(
X
) (((unsigned char *)&(X))[0])

	)
141 #define 
	#loword
(
X
) (((
ushort
 *)&(X))[1])

	)
142 #define 
	#hiword
(
X
) (((
ushort
 *)&(X))[0])

	)
146 #define 
	#SYSNAME
 9

	)
147 #define 
	#PREMOTE
 39

	)
159 #define 
	#MAXPATHLEN
 1024

	)
160 #define 
	#MAXSYMLINKS
 20

	)
161 #define 
	#MAXNAMELEN
 256

	)
163 #ifndef 
NADDR


164 #define 
	#NADDR
 13

	)
172 #ifndef 
PIPE_BUF


173 #define 
	#PIPE_BUF
 5120

	)
176 #ifndef 
PIPE_MAX


177 #define 
	#PIPE_MAX
 5120

	)
180 #define 
	#NBBY
 8

	)
183 #define 
	#dkblock
(
bp
) ((bp)->
b_blkno
)

	)
184 #define 
	#dkunit
(
bp
) (
	`minor
((bp)->
b_dev
) >> 3)

	)
199 #define 
	#MAXBSIZE
 8192

	)
200 #define 
	#DEV_BSIZE
 512

	)
201 #define 
	#DEV_BSHIFT
 9

	)
202 #define 
	#MAXFRAG
 8

	)
203 #define 
	#MAXOFF_T
 ((
off_t
)(((
u_long
)1 << 
NBBY
 * sizeof (off_t) - 1) - 1))

	)
204 #ifdef 
_NO_LONGLONG


205 #define 
	#MAXOFFSET_T
 
MAXOFF_T


	)
207 #define 
	#MAXOFFSET_T
 ((1LL << 
NBBY
 * sizeof (
daddr_t
) + 
DEV_BSHIFT
 - 1) - 1)

	)
210 #define 
	#btodb
(
bytes
) \

211 ((unsigned)(
bytes
) >> 
DEV_BSHIFT
)

	)
212 #define 
	#dbtob
(
db
) \

213 ((unsigned)(
db
) << 
DEV_BSHIFT
)

	)
216 #define 
	#lbtodb
(
bytes
) \

217 ((
offset_t
)(
bytes
) >> 
DEV_BSHIFT
)

	)
218 #define 
	#ldbtob
(
db
) \

219 ((
offset_t
)(
db
) << 
DEV_BSHIFT
)

	)
221 #ifndef 
_ASM


222 #ifndef 
NODEV


223 #define 
	#NODEV
 (
dev_t
)(-1)

	)
230 #define 
	#NCARGS
 0x100000

	)
236 #define 
	#FSHIFT
 8

	)
237 #define 
	#FSCALE
 (1<<
FSHIFT
)

	)
244 #if 
defined
(
_KERNEL
) && !defined(
_ASM
)

245 extern void 
drv_usecwait
(
clock_t
);

246 #define 
	#DELAY
(
n
) 
	`drv_usecwait
(n)

	)
247 #define 
	#CDELAY
(
c
, 
n
) \

249 register int 
N
 = 
n
; \

250 while (--
N
 > 0) { \

251 if (
c
) \

253 
	`drv_usecwait
(1); \

255 }

	)
258 #ifdef 
__cplusplus


267 #if (
defined
(
_KERNEL
) || defined(
_KMEMUSER
))

269 #if 
defined
(
_MACHDEP
)

270 #include 
	~<sys/machparam.h
>

273 #ifdef 
__cplusplus


277 #if !
defined
(
_MACHDEP
)

283 #if 
defined
(
_KERNEL
) && !defined(
_ASM
)

284 extern int 
hz
;

285 extern const unsigned int 
_pagesize
;

286 extern const unsigned int 
_pageshift
;

287 extern const unsigned int 
_pageoffset
;

288 extern const unsigned int 
_pagemask
;

289 extern const unsigned int 
_mmu_pagesize
;

290 extern const unsigned int 
_mmu_pageshift
;

291 extern const unsigned int 
_mmu_pageoffset
;

292 extern const unsigned int 
_mmu_pagemask
;

293 extern const unsigned int 
_kernelbase
;

294 extern const unsigned int 
_userlimit
;

295 extern const unsigned int 
_argsbase
;

296 extern const unsigned int 
_msg_bsize
;

297 extern const unsigned int 
_defaultstksz
;

298 extern const unsigned int 
_nbpg
;

299 extern const int 
_ncpu
;

300 extern const int 
_clsize
;

303 #define 
	#HZ
 
hz


	)
304 #define 
	#PAGESIZE
 
_pagesize


	)
305 #define 
	#PAGESHIFT
 
_pageshift


	)
306 #define 
	#PAGEOFFSET
 
_pageoffset


	)
307 #define 
	#PAGEMASK
 
_pagemask


	)
308 #define 
	#MMU_PAGESIZE
 
_mmu_pagesize


	)
309 #define 
	#MMU_PAGESHIFT
 
_mmu_pageshift


	)
310 #define 
	#MMU_PAGEOFFSET
 
_mmu_pageoffset


	)
311 #define 
	#MMU_PAGEMASK
 
_mmu_pagemask


	)
313 #define 
	#KERNELBASE
 
_kernelbase


	)
314 #define 
	#USERLIMIT
 
_userlimit


	)
315 #define 
	#ARGSBASE
 
_argsbase


	)
316 #define 
	#MSG_BSIZE
 
_msg_bsize


	)
317 #define 
	#DEFAULTSTKSZ
 
_defaultstksz


	)
318 #define 
	#NBPG
 
_nbpg


	)
319 #define 
	#NCPU
 
_ncpu


	)
320 #define 
	#CLSIZE
 
_clsize


	)
334 #define 
	#mmu_ptob
(
x
) ((x) << 
MMU_PAGESHIFT
)

	)
335 #define 
	#mmu_btop
(
x
) (((unsigned)(x)) >> 
MMU_PAGESHIFT
)

	)
336 #define 
	#mmu_btopr
(
x
) ((((unsigned)(x) + 
MMU_PAGEOFFSET
) >> 
MMU_PAGESHIFT
))

	)
341 #define 
	#mmu_ptod
(
x
) ((x) << (
MMU_PAGESHIFT
 - 
DEV_BSHIFT
))

	)
342 #define 
	#ptod
(
x
) ((x) << (
PAGESHIFT
 - 
DEV_BSHIFT
))

	)
347 #define 
	#ptob
(
x
) ((x) << 
PAGESHIFT
)

	)
348 #define 
	#btop
(
x
) (((unsigned)(x)) >> 
PAGESHIFT
)

	)
349 #define 
	#btopr
(
x
) ((((unsigned)(x) + 
PAGEOFFSET
) >> 
PAGESHIFT
))

	)
354 #define 
	#NDPP
 (
PAGESIZE
/
DEV_BSHIFT
)

	)
355 #define 
	#dtop
(
DD
) (((DD) + 
NDPP
 - 1) >> (
PAGESHIFT
 - 
DEV_BSHIFT
))

	)
356 #define 
	#dtopt
(
DD
) ((DD) >> (
PAGESHIFT
 - 
DEV_BSHIFT
))

	)
361 #define 
	#PAGOFF
(
x
) (((
uint
)(x)) & 
PAGEOFFSET
)

	)
362 #define 
	#NBPC
 
MMU_PAGESIZE


	)
363 #define 
	#NBPP
 
MMU_PAGESIZE


	)
364 #define 
	#BPCSHIFT
 
MMU_PAGESHIFT


	)
366 #ifdef 
__cplusplus


380 #include 
	~<sys/unistd.h
>

382 #ifdef 
__cplusplus


386 #if !
defined
(
_ASM
)

387 extern long 
_sysconf
(int);

390 #define 
	#HZ
 ((int)
	`_sysconf
(
_SC_CLK_TCK
))

	)
391 #define 
	#TICK
 (1000000000/((int)
	`_sysconf
(
_SC_CLK_TCK
)))

	)
392 #define 
	#PAGESIZE
 (
	`_sysconf
(
_SC_PAGESIZE
))

	)
393 #define 
	#PAGEOFFSET
 (
PAGESIZE
 - 1)

	)
394 #define 
	#PAGEMASK
 (~
PAGEOFFSET
)

	)
396 #ifdef 
__cplusplus


	@/usr/include/sys/pcb.h

5 #ifndef 
_SYS_PCB_H


6 #define 
	#_SYS_PCB_H


	)
8 #pragma 
ident
 "@(#)pcb.h 1.22 94/11/18 SMI"

10 #include 
	~<sys/regset.h
>

12 #ifdef 
__cplusplus


20 #ifndef 
_ASM


21 typedef struct 
	spcb
 {

22 int 
pcb_flags
;

23 struct 
rwindow
 
pcb_xregs
;

24 enum 
	e
{ 
XREGNONE
 = 0, 
XREGPRESENT
, 
XREGMODIFIED
 }

25 
pcb_xregstat
;

26 enum 
	e
{ 
STEP_NONE
 = 0, 
STEP_REQUESTED
, 
STEP_ACTIVE
, 
STEP_WASACTIVE
 }

27 
pcb_step
;

28 
caddr_t
 
pcb_tracepc
;

29 long 
pcb_instr
;

30 
caddr_t
 
pcb_trap0addr
;

31 } 
	tpcb_t
;

35 #define 
	#FIX_ALIGNMENT
 0x01

	)
36 #define 
	#INSTR_VALID
 0x02

	)
38 #ifdef 
__cplusplus


	@/usr/include/sys/pirec.h

5 #ifndef 
_SYS_PIREC_H


6 #define 
	#_SYS_PIREC_H


	)
8 #pragma 
ident
 "@(#)pirec.h 1.11 93/12/20 SMI"

10 #ifdef 
__cplusplus


32 typedef struct 
	spirec


34 struct 
pirec
 *
pi_forw
;

35 struct 
pirec
 *
pi_back
;

36 struct 
_kthread
 *
pi_benef
;

37 
uint_t
 
pi_epri_hi
;

38 } 
	tpirec_t
;

40 #ifdef 
_KERNEL


47 #define 
	#PIREC_RAISE
(
p
, 
dpri
) \

48 if ((
p
)->
pi_epri_hi
 < (
dpri
)) \

49 (
p
)->
pi_epri_hi
 = (
dpri
)

	)
52 #ifdef 
__STDC__


53 extern void 
pirec_init
(
pirec_t
 *, struct 
_kthread
 *, 
pri_t
);

54 extern void 
pirec_clear
(
pirec_t
 *);

55 extern void 
pirec_insque
(
pirec_t
 *, pirec_t *);

56 extern void 
pirec_remque
(
pirec_t
 *);

57 extern 
pri_t
 
pirec_calcpri
(
pirec_t
 *, pri_t);

59 extern void 
pirec_init
();

60 extern void 
pirec_clear
();

61 extern void 
pirec_insque
();

62 extern void 
pirec_remque
();

63 extern 
pri_t
 
pirec_calcpri
();

68 #ifdef 
__cplusplus


	@/usr/include/sys/regset.h

12 #ifndef 
_SYS_REGSET_H


13 #define 
	#_SYS_REGSET_H


	)
15 #pragma 
ident
 "@(#)regset.h 1.13 94/11/21 SMI"

17 #ifdef 
__cplusplus


25 #define 
	#REG_PSR
 (0)

	)
26 #define 
	#REG_PC
 (1)

	)
27 #define 
	#REG_nPC
 (2)

	)
28 #define 
	#REG_Y
 (3)

	)
29 #define 
	#REG_G1
 (4)

	)
30 #define 
	#REG_G2
 (5)

	)
31 #define 
	#REG_G3
 (6)

	)
32 #define 
	#REG_G4
 (7)

	)
33 #define 
	#REG_G5
 (8)

	)
34 #define 
	#REG_G6
 (9)

	)
35 #define 
	#REG_G7
 (10)

	)
36 #define 
	#REG_O0
 (11)

	)
37 #define 
	#REG_O1
 (12)

	)
38 #define 
	#REG_O2
 (13)

	)
39 #define 
	#REG_O3
 (14)

	)
40 #define 
	#REG_O4
 (15)

	)
41 #define 
	#REG_O5
 (16)

	)
42 #define 
	#REG_O6
 (17)

	)
43 #define 
	#REG_O7
 (18)

	)
46 #define 
	#REG_PS
 
REG_PSR


	)
47 #define 
	#REG_SP
 
REG_O6


	)
48 #define 
	#REG_R0
 
REG_O0


	)
49 #define 
	#REG_R1
 
REG_O1


	)
51 #ifndef 
_ASM


53 typedef int 
	tgreg_t
;

63 #define 
	#NGREG
 19

	)
65 typedef 
greg_t
 
	tgregset_t
[
NGREG
];

74 #define 
	#SPARC_MAXREGWINDOW
 31

	)
76 struct 
	srwindow
 {

77 
greg_t
 
rw_local
[8];

78 
greg_t
 
rw_in
[8];

81 #define 
	#rw_fp
 
rw_in
[6]

	)
82 #define 
	#rw_rtn
 
rw_in
[7]

	)
84 struct 
	sgwindows
 {

85 int 
wbcnt
;

86 int *
spbuf
[
SPARC_MAXREGWINDOW
];

87 struct 
rwindow
 
wbuf
[
SPARC_MAXREGWINDOW
];

90 typedef struct 
gwindows
 
	tgwindows_t
;

96 #define 
	#MAXFPQ
 16

	)
106 struct 
	sfpq
 {

107 unsigned long *
fpq_addr
;

108 unsigned long 
fpq_instr
;

111 struct 
	sfq
 {

112 union 
	u
{

113 double 
whole
;

114 struct 
fpq
 fpq;

115 } 
FQu
;

131 #define 
	#FPU_REGS_TYPE
 unsigned

	)
132 #define 
	#FPU_DREGS_TYPE
 unsigned long long

	)
133 #define 
	#V7_FPU_FSR_TYPE
 unsigned

	)
134 #define 
	#V9_FPU_FSR_TYPE
 unsigned long long

	)
135 #define 
	#V9_FPU_FPRS_TYPE
 unsigned

	)
137 #ifdef 
__sparcv9


138 #define 
	#FPU_FSR_TYPE
 
V9_FPU_FSR_TYPE


	)
140 #define 
	#FPU_FSR_TYPE
 
V7_FPU_FSR_TYPE


	)
143 struct 
	sfpu
 {

144 union 
	u
{

145 
FPU_REGS_TYPE
 
fpu_regs
[32];

146 double 
fpu_dregs
[16];

147 } 
fpu_fr
;

148 struct 
fq
 *
fpu_q
;

149 
V7_FPU_FSR_TYPE
 
fpu_fsr
;

150 unsigned char 
fpu_qcnt
;

151 unsigned char 
fpu_q_entrysize
;

152 unsigned char 
fpu_en
;

155 typedef struct 
fpu
 
	tfpregset_t
;

157 #ifdef 
__sparcv9


165 struct 
	sv9_fpu
 {

166 union 
	u
{

167 
FPU_REGS_TYPE
 
fpu_regs
[32];

168 
FPU_DREGS_TYPE
 
fpu_dregs
[32];

169 long double 
fpu_qregs
[16];

170 } 
fpu_fr
;

171 
V9_FPU_FSR_TYPE
 
fpu_fsr
;

172 
V9_FPU_FPRS_TYPE
 
fpu_fprs
;

173 struct 
fq
 *
fpu_q
;

174 unsigned char 
fpu_qcnt
;

175 unsigned char 
fpu_q_entrysize
;

176 unsigned char 
fpu_en
;

179 typedef struct 
v9_fpu
 
	tv9_fpregset_t
;

183 #ifdef 
_KERNEL


188 #ifdef 
__sparcv9


189 typedef struct 
v9_fpu
 
	tkfpu_t
;

191 typedef struct 
fpu
 
	tkfpu_t
;

205 typedef struct 
	s
{

206 unsigned int 
xrs_id
;

207 
caddr_t
 
xrs_ptr
;

208 } 
	txrs_t
;

210 #define 
	#XRS_ID
 0x78727300

	)
227 typedef struct 
	s
{

228 
gregset_t
 
gregs
;

229 
gwindows_t
 *
gwins
;

230 
fpregset_t
 
fpregs
;

231 
xrs_t
 
xrs
;

232 long 
filler
[19];

233 } 
	tmcontext_t
;

237 #ifndef 
_KERNEL


238 #include 
	~<v7/sys/privregs.h
>

242 #ifdef 
__cplusplus


	@/usr/include/sys/resource.h

8 #ifndef 
_SYS_RESOURCE_H


9 #define 
	#_SYS_RESOURCE_H


	)
11 #pragma 
ident
 "@(#)resource.h 1.12 95/02/26 SMI"

13 #ifdef 
__cplusplus


21 #define 
	#PRIO_PROCESS
 0

	)
22 #define 
	#PRIO_PGRP
 1

	)
23 #define 
	#PRIO_USER
 2

	)
30 #define 
	#RLIMIT_CPU
 0

	)
31 #define 
	#RLIMIT_FSIZE
 1

	)
32 #define 
	#RLIMIT_DATA
 2

	)
33 #define 
	#RLIMIT_STACK
 3

	)
34 #define 
	#RLIMIT_CORE
 4

	)
35 #define 
	#RLIMIT_NOFILE
 5

	)
36 #define 
	#RLIMIT_VMEM
 6

	)
37 #define 
	#RLIMIT_AS
 
RLIMIT_VMEM


	)
39 #define 
	#RLIM_NLIMITS
 7

	)
41 #define 
	#RLIM_INFINITY
 0x7fffffff

	)
43 typedef unsigned long 
	trlim_t
;

45 struct 
	srlimit
 {

46 
rlim_t
 
rlim_cur
;

47 
rlim_t
 
rlim_max
;

50 #ifdef 
_KERNEL


52 extern struct 
rlimit
 
rlimits
[];

54 #if 
defined
(
__STDC__
)

56 extern int 
rlimit
(int, 
rlim_t
, rlim_t);

60 extern int 
rlimit
();

66 #include 
	~<sys/time.h
>

68 #define 
	#RUSAGE_SELF
 0

	)
69 #define 
	#RUSAGE_CHILDREN
 -1

	)
71 struct 
	srusage
 {

72 struct 
timeval
 
	gru_utime
;

73 struct 
timeval
 
	gru_stime
;

74 long 
	gru_maxrss
;

75 long 
	gru_ixrss
;

76 long 
	gru_idrss
;

77 long 
	gru_isrss
;

78 long 
	gru_minflt
;

79 long 
	gru_majflt
;

80 long 
	gru_nswap
;

81 long 
	gru_inblock
;

82 long 
	gru_oublock
;

83 long 
	gru_msgsnd
;

84 long 
	gru_msgrcv
;

85 long 
	gru_nsignals
;

86 long 
	gru_nvcsw
;

87 long 
	gru_nivcsw
;

90 #if 
defined
(
__STDC__
)

92 extern int 
setrlimit
(int, const struct 
rlimit
 *);

93 extern int 
getrlimit
(int, struct 
rlimit
 *);

97 extern int 
getrlimit
();

98 extern int 
setrlimit
();

104 #ifdef 
__cplusplus


	@/usr/include/sys/signal.h

13 #ifndef 
_SYS_SIGNAL_H


14 #define 
	#_SYS_SIGNAL_H


	)
16 #pragma 
ident
 "@(#)signal.h 1.44 95/03/16 SMI"

18 #include 
	~<sys/feature_tests.h
>

19 #include 
	~<sys/unistd.h
>

21 #ifdef 
__cplusplus


25 #define 
	#SIGHUP
 1

	)
26 #define 
	#SIGINT
 2

	)
27 #define 
	#SIGQUIT
 3

	)
28 #define 
	#SIGILL
 4

	)
29 #define 
	#SIGTRAP
 5

	)
30 #define 
	#SIGIOT
 6

	)
31 #define 
	#SIGABRT
 6

	)
32 #define 
	#SIGEMT
 7

	)
33 #define 
	#SIGFPE
 8

	)
34 #define 
	#SIGKILL
 9

	)
35 #define 
	#SIGBUS
 10

	)
36 #define 
	#SIGSEGV
 11

	)
37 #define 
	#SIGSYS
 12

	)
38 #define 
	#SIGPIPE
 13

	)
39 #define 
	#SIGALRM
 14

	)
40 #define 
	#SIGTERM
 15

	)
41 #define 
	#SIGUSR1
 16

	)
42 #define 
	#SIGUSR2
 17

	)
43 #define 
	#SIGCLD
 18

	)
44 #define 
	#SIGCHLD
 18

	)
45 #define 
	#SIGPWR
 19

	)
46 #define 
	#SIGWINCH
 20

	)
47 #define 
	#SIGURG
 21

	)
48 #define 
	#SIGPOLL
 22

	)
49 #define 
	#SIGIO
 
SIGPOLL


	)
50 #define 
	#SIGSTOP
 23

	)
51 #define 
	#SIGTSTP
 24

	)
52 #define 
	#SIGCONT
 25

	)
53 #define 
	#SIGTTIN
 26

	)
54 #define 
	#SIGTTOU
 27

	)
55 #define 
	#SIGVTALRM
 28

	)
56 #define 
	#SIGPROF
 29

	)
57 #define 
	#SIGXCPU
 30

	)
58 #define 
	#SIGXFSZ
 31

	)
59 #define 
	#SIGWAITING
 32

	)
60 #define 
	#SIGLWP
 33

	)
61 #define 
	#SIGFREEZE
 34

	)
62 #define 
	#SIGTHAW
 35

	)
63 #define 
	#SIGCANCEL
 36

	)
65 #define 
	#_SIGRTMIN
 37

	)
66 #define 
	#_SIGRTMAX
 44

	)
67 extern long 
_sysconf
(int);

68 #define 
	#SIGRTMIN
 
	`_sysconf
(
_SC_SIGRT_MIN
)

	)
69 #define 
	#SIGRTMAX
 
	`_sysconf
(
_SC_SIGRT_MAX
)

	)
71 #if 
defined
(
__cplusplus
)

73 typedef void 
	tSIG_FUNC_TYP
(int);

74 typedef 
SIG_FUNC_TYP
 *
	tSIG_TYP
;

75 #define 
	#SIG_PF
 
SIG_TYP


	)
77 #define 
	#SIG_DFL
 (
SIG_PF
)0

	)
78 #define 
	#SIG_ERR
 (
SIG_PF
)-1

	)
79 #define 
	#SIG_IGN
 (
SIG_PF
)1

	)
80 #define 
	#SIG_HOLD
 (
SIG_PF
)2

	)
82 #elif 
defined
(
lint
)

84 #define 
	#SIG_DFL
 (void(*)())0

	)
85 #define 
	#SIG_ERR
 (void(*)())0

	)
86 #define 
	#SIG_IGN
 (void (*)())0

	)
87 #define 
	#SIG_HOLD
 (void(*)())0

	)
91 #define 
	#SIG_DFL
 (void(*)())0

	)
92 #define 
	#SIG_ERR
 (void(*)())-1

	)
93 #define 
	#SIG_IGN
 (void (*)())1

	)
94 #define 
	#SIG_HOLD
 (void(*)())2

	)
98 #define 
	#SIG_BLOCK
 1

	)
99 #define 
	#SIG_UNBLOCK
 2

	)
100 #define 
	#SIG_SETMASK
 3

	)
102 #define 
	#SIGNO_MASK
 0xFF

	)
103 #define 
	#SIGDEFER
 0x100

	)
104 #define 
	#SIGHOLD
 0x200

	)
105 #define 
	#SIGRELSE
 0x400

	)
106 #define 
	#SIGIGNORE
 0x800

	)
107 #define 
	#SIGPAUSE
 0x1000

	)
109 #if 
defined
(
__EXTENSIONS__
) || (
__STDC__
 - 0 == 0) || \

110 
defined
(
_POSIX_C_SOURCE
) || defined(
_XOPEN_SOURCE
)

112 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

113 !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

114 (
	g_POSIX_C_SOURCE
 > 2)

118 #include 
	~<sys/siginfo.h
>

122 typedef struct 
	s
{

123 unsigned long 
	g__sigbits
[4];

124 } 
	tsigset_t
;

126 typedef struct 
	s
{

127 unsigned long 
	g__sigbits
[2];

128 } 
	tk_sigset_t
;

140 struct 
	ssigaction
 {

141 int 
	gsa_flags
;

142 union 
	u
{

143 #ifdef 
__cplusplus


144 void (*
	g_handler
)(int);

146 void (*
	g_handler
)();

148 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

149 !
defined
(
_POSIX_C_SOURCE
) && !defined(
_XOPEN_SOURCE
)) || \

150 (
	g_POSIX_C_SOURCE
 > 2)

151 void (*
	g_sigaction
)(int, 
	gsiginfo_t
 *, void *);

153 } 
	g_funcptr
;

154 
sigset_t
 
	gsa_mask
;

155 int 
	gsa_resv
[2];

157 #define 
	#sa_handler
 
_funcptr
.
_handler


	)
158 #define 
	#sa_sigaction
 
_funcptr
.
_sigaction


	)
161 #define 
	#SA_NOCLDSTOP
 0x00020000

	)
164 #if 
defined
(
__EXTENSIONS__
) || \

165 ((
	g__STDC__
 - 0 == 0) && !
defined
(
_POSIX_C_SOURCE
))

170 #define 
	#SA_ONSTACK
 0x00000001

	)
171 #define 
	#SA_RESETHAND
 0x00000002

	)
172 #define 
	#SA_RESTART
 0x00000004

	)
175 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

176 !
defined
(
_POSIX_C_SOURCE
)) || (_POSIX_C_SOURCE > 2)

177 #define 
	#SA_SIGINFO
 0x00000008

	)
180 #if 
defined
(
__EXTENSIONS__
) || ((
__STDC__
 - 0 == 0) && \

181 !
defined
(
_POSIX_C_SOURCE
))

182 #define 
	#SA_NODEFER
 0x00000010

	)
185 #define 
	#SA_NOCLDWAIT
 0x00010000

	)
188 #define 
	#SA_WAITSIG
 0x00010000

	)
194 #define 
	#NSIG
 45

	)
195 #define 
	#MAXSIG
 44

	)
200 #define 
	#S_SIGNAL
 1

	)
201 #define 
	#S_SIGSET
 2

	)
202 #define 
	#S_SIGACTION
 3

	)
203 #define 
	#S_NONE
 4

	)
205 #define 
	#MINSIGSTKSZ
 2048

	)
206 #define 
	#SIGSTKSZ
 8192

	)
208 #define 
	#SS_ONSTACK
 0x00000001

	)
209 #define 
	#SS_DISABLE
 0x00000002

	)
211 struct 
	ssigaltstack
 {

212 char *
ss_sp
;

213 int 
	gss_size
;

214 int 
	gss_flags
;

217 typedef struct 
sigaltstack
 
	tstack_t
;

221 #ifdef 
_KERNEL


222 #include 
	~<sys/t_lock.h
>

224 extern 
k_sigset_t


226 
nullsmask
,

227 
fillset
,

228 
holdvfork
,

229 
cantmask
,

230 
cantreset
,

231 
ignoredefault
,

232 
stopdefault
,

233 
coredefault
;

235 #define 
	#sigmask
(
n
) ((unsigned int)1 << (((n) - 1) & (32 - 1)))

	)
236 #define 
	#sigword
(
n
) (((unsigned int)((n) - 1))>>5)

	)
238 #define 
	#sigemptyset
(
s
) (*(s) = 
nullsmask
)

	)
239 #define 
	#sigfillset
(
s
) (*(s) = 
fillset
)

	)
240 #define 
	#sigaddset
(
s
, 
n
) ((s)->
__sigbits
[
	`sigword
(n)] |= 
	`sigmask
(n))

	)
241 #define 
	#sigdelset
(
s
, 
n
) ((s)->
__sigbits
[
	`sigword
(n)] &= ~
	`sigmask
(n))

	)
242 #define 
	#sigismember
(
s
, 
n
) (
	`sigmask
(n) & (s)->
__sigbits
[
	`sigword
(n)])

	)
243 #define 
	#sigisempty
(
s
) (!(((s)->
__sigbits
[0]) | ((s)->__sigbits[1])))

	)
244 #define 
	#sigutok
(
us
, 
ks
) ((ks)->
__sigbits
[0] = (us)->__sigbits[0], \

245 (
ks
)->
__sigbits
[1] = (
us
)->__sigbits[1])

	)
246 #define 
	#sigktou
(
ks
, 
us
) ((us)->
__sigbits
[0] = (ks)->__sigbits[0], \

247 (
us
)->
__sigbits
[1] = (
ks
)->__sigbits[1], \

248 (
us
)->
__sigbits
[2] = 0, \

249 (
us
)->
__sigbits
[3] = 0)

	)
250 typedef struct 
	s
{

251 int 
	gsig
;

252 int 
	gperm
;

253 int 
	gcheckperm
;

254 int 
	gsicode
;

255 union 
sigval
 
	gvalue
;

256 } 
	tsigsend_t
;

258 typedef struct 
	ssigqbucket
 {

259 
sigqueue_t
 
	gsqb_bucket
;

260 struct 
sigqbucket
 *
	gsqb_link
;

261 } 
	tsigqbucket_t
;

263 typedef struct 
	ssigqhdr
 {

264 struct 
sigqbucket
 *
	gsqb_link
;

265 int 
	gsqb_count
;

266 int 
	gsqb_pexited
;

267 
kmutex_t
 
	gsqb_lock
;

268 } 
	tsigqhdr_t
;

270 #define 
	#_SIGQUEUE_MAX
 32

	)
272 #if 
defined
(
__STDC__
)

273 extern void 
setsigact
(int, void (*)(), 
k_sigset_t
, int);

274 extern void 
sigorset
(
k_sigset_t
 *, k_sigset_t *);

275 extern void 
sigandset
(
k_sigset_t
 *, k_sigset_t *);

276 extern void 
sigdiffset
(
k_sigset_t
 *, k_sigset_t *);

277 extern void 
sigreplace
(
k_sigset_t
 *, k_sigset_t *);

279 extern void 
setsigact
();

280 extern void 
sigorset
();

281 extern void 
sigandset
();

282 extern void 
sigdiffset
();

283 extern void 
sigreplace
();

288 #ifdef 
__cplusplus


	@/usr/include/sys/sleepq.h

5 #ifndef 
_SYS_SLEEPQ_H


6 #define 
	#_SYS_SLEEPQ_H


	)
8 #pragma 
ident
 "@(#)sleepq.h 1.17 94/07/29 SMI"

10 #include 
	~<sys/machlock.h
>

12 #ifdef 
__cplusplus


22 typedef struct 
	ssleepq
 {

23 struct 
_kthread
 * 
sq_first
;

24 } 
	tsleepq_t
;

29 typedef struct 
	s_sleepq_head
 {

30 
sleepq_t
 
sq_queue
;

31 
disp_lock_t
 
sq_lock
;

32 } 
	tsleepq_head_t
;

34 #ifdef 
_KERNEL


36 #ifdef 
__STDC__


38 extern void 
sleepq_insert
(
sleepq_t
 *, struct 
_kthread
 *);

39 extern void 
sleepq_wakeone
(
sleepq_t
 *);

40 extern void 
sleepq_wakeall
(
sleepq_t
 *);

41 extern void 
sleepq_wakeone_chan
(
sleepq_t
 *, 
caddr_t
);

42 extern void 
sleepq_wakeall_chan
(
sleepq_t
 *, 
caddr_t
);

43 extern struct 
_kthread
 *
sleepq_unsleep
(
sleepq_t
 *, struct _kthread *);

44 extern struct 
_kthread
 *
sleepq_dequeue
(
sleepq_t
 *, struct _kthread *);

46 extern 
sleepq_head_t
 *
sqhash
(
caddr_t
 
wchan
);

50 extern void 
sleepq_insert
();

51 extern void 
sleepq_wakeone
();

52 extern void 
sleepq_wakeall
();

53 extern void 
sleepq_wakeone_chan
();

54 extern void 
sleepq_wakeall_chan
();

55 extern struct 
_kthread
 *
sleepq_unsleep
();

56 extern struct 
_kthread
 *
sleepq_dequeue
();

58 extern 
sleepq_head_t
 *
sqhash
();

82 #define 
	#NSLEEPQ
 512

	)
83 #define 
	#sqhashindex
(
X
) (((
u_int
)X >> 2) + ((u_int)(X) >> 9) & (
NSLEEPQ
 - 1))

	)
87 #ifdef 
__cplusplus


	@/usr/include/sys/t_lock.h

11 #ifndef 
_SYS_T_LOCK_H


12 #define 
	#_SYS_T_LOCK_H


	)
14 #pragma 
ident
 "@(#)t_lock.h 1.42 94/11/02 SMI"

16 #ifndef 
_ASM


17 #include 
	~<sys/machlock.h
>

18 #include 
	~<sys/dki_lkinfo.h
>

19 #include 
	~<sys/sleepq.h
>

20 #include 
	~<sys/turnstile.h
>

21 #include 
	~<sys/mutex.h
>

22 #include 
	~<sys/rwlock.h
>

23 #include 
	~<sys/semaphore.h
>

24 #include 
	~<sys/condvar.h
>

27 #ifdef 
__cplusplus


31 #ifndef 
_ASM


47 #define 
	#LOCK_NAME_LEN
 18

	)
50 #if 
defined
(
_KERNEL
)

52 extern int 
ncpus
;

54 extern 
kmutex_t
 
unsafe_driver
;

56 #define 
	#UNSAFE_DRIVER_LOCK_HELD
() (
	`mutex_owned
(&
unsafe_driver
))

	)
57 #define 
	#UNSAFE_DRIVER_LOCK_NOT_HELD
() \

58 (!
	`mutex_owned
(&
unsafe_driver
) || 
panicstr
)

	)
65 extern void 
disp_lock_enter
(
disp_lock_t
 *);

66 extern void 
disp_lock_exit
(
disp_lock_t
 *);

67 extern void 
disp_lock_exit_nopreempt
(
disp_lock_t
 *);

68 extern void 
disp_lock_enter_high
(
disp_lock_t
 *);

69 extern void 
disp_lock_exit_high
(
disp_lock_t
 *);

70 extern void 
disp_lock_init
(
disp_lock_t
 *
lp
, char *
name
);

71 extern void 
disp_lock_destroy
(
disp_lock_t
 *
lp
);

72 extern void 
disp_lock_trace
(
disp_lock_t
 *
lp
);

74 #define 
	#DISP_LOCK_HELD
(
lp
) 
	`LOCK_HELD
((
lock_t
 *)(lp))

	)
82 #ifndef 
NO_LOCKS_HELD


83 #define 
	#NO_LOCKS_HELD
 1

	)
85 #ifndef 
NO_COMPETING_THREADS


86 #define 
	#NO_COMPETING_THREADS
 1

	)
93 #ifdef 
__cplusplus


	@/usr/include/sys/turnstile.h

5 #ifndef 
_SYS_TURNSTILE_H


6 #define 
	#_SYS_TURNSTILE_H


	)
8 #pragma 
ident
 "@(#)turnstile.h 1.27 94/10/27 SMI"

10 #include 
	~<sys/types.h
>

11 #include 
	~<sys/param.h
>

12 #include 
	~<sys/pirec.h
>

13 #include 
	~<sys/sleepq.h
>

15 #ifdef 
__cplusplus


19 #define 
	#NTSTILE_SQ
 2

	)
26 typedef enum 
	e
{

27 
QOBJ_UND
 = -1,

28 
QOBJ_DEF
 = 0,

29 
QOBJ_READER
 = 0,

30 
QOBJ_WRITER
 = 1,

31 
QOBJ_CV
 = 0,

32 
QOBJ_MUTEX
 = 0,

33 
QOBJ_SEMA
 = 0

34 } 
	tqobj_t
;

37 #define 
	#TSTILE_FREE
 0

	)
38 #define 
	#TSTILE_ACTIVE
 1

	)
40 typedef struct 
turnstile
 
	tturnstile_t
;

42 typedef 
ushort_t
 
	tturnstile_id_t
;

44 struct 
	sturnstile
 {

45 union 
	utstile_un
 {

50 
turnstile_t
 *
ts_forw
;

57 
pirec_t
 
ts_prioinv
;

58 } 
tsun
;

64 
sleepq_t
 
ts_sleepq
[
NTSTILE_SQ
];

71 
turnstile_id_t
 
ts_id
;

72 
uchar_t
 
ts_flags
;

73 
disp_lock_t
 
ts_wlock
;

80 void *
ts_sobj_priv_data
;

83 #ifdef 
_KERNEL


89 #define 
	#TS_ROWSZ
 512

	)
90 #define 
	#TS_COLSZ
 128

	)
91 #define 
	#TS_ROWBITS
 9

	)
92 #define 
	#TS_COLBITS
 7

	)
93 #define 
	#TS_ROWMASK
 ((1 << 
TS_ROWBITS
) - 1)

	)
98 #define 
	#TS_ROWCOL
(
row
, 
col
) (col << 
TS_ROWBITS
 | row)

	)
103 #define 
	#TS_COL
(
ts_id
) ((ts_id) >> 
TS_ROWBITS
)

	)
108 #define 
	#TS_ROW
(
ts_id
) ((ts_id) & 
TS_ROWMASK
)

	)
113 #define 
	#TS_NEW
(
n
, 
cond
) \

114 (
turnstile_t
 *)
	`kmem_zalloc
(
n
 * sizeof (turnstile_t), 
cond
)

	)
120 #define 
	#TS_VALID
(
r
, 
c
) ((r < 
tstile_mod
.
tsm_rowcnt
) && \

121 (
c
 < 
tstile_mod
.
tsm_colsz
))

	)
124 #define 
	#TSTILE_PRIO_INVERTED
(
ts
) \

125 ((
ts
)->
tsun
.
ts_prioinv
.
pi_benef
 != 
NULL
)

	)
126 #define 
	#TSTILE_INSERT
(
ts
, 
qnum
, 
c
) \

127 
	`sleepq_insert
(&(
ts
)->
ts_sleepq
[
qnum
], 
c
)

	)
128 #define 
	#TSTILE_WAKEONE
(
ts
, 
qnum
) \

129 
	`sleepq_wakeone
(&(
ts
)->
ts_sleepq
[
qnum
])

	)
130 #define 
	#TSTILE_WAKEALL
(
ts
, 
qnum
) \

131 
	`sleepq_wakeall
(&(
ts
)->
ts_sleepq
[
qnum
])

	)
132 #define 
	#TSTILE_SLEEPQ
(
ts
, 
sobj_ops
) \

133 ((
ts
)->
ts_sleepq
[
	`SOBJ_QNUM
(
sobj_ops
)])

	)
134 #define 
	#TSTILE_DEQ
(
ts
, 
qnum
, 
t
) \

135 
	`sleepq_dequeue
(&(
ts
)->
ts_sleepq
[
qnum
], 
t
)

	)
136 #define 
	#TSTILE_UNSLEEP
(
ts
, 
qnum
, 
t
) \

137 
	`sleepq_unsleep
(&(
ts
)->
ts_sleepq
[
qnum
], 
t
)

	)
138 #define 
	#TSTILE_EMPTY
(
ts
, 
qnum
) \

139 ((
ts
)->
ts_sleepq
[
qnum
].
sq_first
 == 
NULL
)

	)
142 #ifdef 
__STDC__


144 extern void 
tstile_init
(void);

145 extern int 
tstile_more
(int, int);

146 extern 
turnstile_t
 *
tstile_pointer
(
turnstile_id_t
);

147 extern 
turnstile_t
 *
tstile_pointer_verify
(
turnstile_id_t
);

148 extern 
turnstile_t
 *
tstile_alloc
(void);

149 extern void 
tstile_free
(
turnstile_t
 *, 
turnstile_id_t
 *);

150 extern struct 
_kthread
 *
tstile_unsleep
(
turnstile_t
 *, 
qobj_t
,

151 struct 
_kthread
 *);

152 extern void 
tstile_insert
(
turnstile_t
 *, 
qobj_t
, struct 
_kthread
 *);

153 extern void 
tstile_wakeone
(
turnstile_t
 *, 
qobj_t
);

154 extern void 
tstile_wakeall
(
turnstile_t
 *, 
qobj_t
);

155 extern int 
tstile_deq
(
turnstile_t
 *, 
qobj_t
, struct 
_kthread
 *
t
);

156 extern 
pri_t
 
tstile_maxpri
(
turnstile_t
 *);

157 extern int 
tstile_prio_inverted
(
turnstile_t
 *);

158 extern int 
tstile_empty
(
turnstile_t
 *, 
qobj_t
);

159 extern struct 
_kthread
 *
tstile_inheritor
(
turnstile_t
 *);

163 extern void 
tstile_init
();

164 extern int 
tstile_more
();

165 extern 
turnstile_t
 *
tstile_pointer
();

166 extern 
turnstile_t
 *
tstile_pointer_verify
();

167 extern 
turnstile_t
 *
tstile_alloc
();

168 extern void 
tstile_free
();

169 extern struct 
_kthread
 *
tstile_unsleep
();

170 extern void 
tstile_insert
();

171 extern void 
tstile_wakeone
();

172 extern void 
tstile_wakeall
();

173 extern int 
tstile_deq
();

174 extern 
pri_t
 
tstile_maxpri
();

175 extern int 
tstile_prio_inverted
();

176 extern int 
tstile_empty
();

177 extern struct 
_kthread
 *
tstile_inheritor
();

183 #ifdef 
__cplusplus


	@/usr/include/sys/condvar.h

13 #ifndef 
_SYS_CONDVAR_H


14 #define 
	#_SYS_CONDVAR_H


	)
16 #pragma 
ident
 "@(#)condvar.h 1.6 94/07/29 SMI"

18 #ifndef 
_ASM


19 #include 
	~<sys/types.h
>

20 #ifdef 
_KERNEL


21 #include 
	~<sys/thread.h
>

25 #ifdef 
__cplusplus


29 #ifndef 
_ASM


35 typedef struct 
	s_kcondvar
 {

36 
ushort_t
 
_opaque
;

37 } 
	tkcondvar_t
;

39 typedef enum 
	e
{

40 
	mCV_DEFAULT
,

41 
	mCV_DRIVER


42 } 
	tkcv_type_t
;

45 #if 
defined
(
_KERNEL
)

51 extern void 
cv_init
(
kcondvar_t
 *, char *, 
kcv_type_t
, void *);

52 extern void 
cv_destroy
(
kcondvar_t
 *);

53 extern void 
cv_wait
(
kcondvar_t
 *, 
kmutex_t
 *);

54 extern int 
cv_timedwait
(
kcondvar_t
 *, 
kmutex_t
 *, long);

55 extern int 
cv_wait_sig
(
kcondvar_t
 *, 
kmutex_t
 *);

56 extern int 
cv_timedwait_sig
(
kcondvar_t
 *, 
kmutex_t
 *, long);

57 extern int 
cv_wait_sig_swap
(
kcondvar_t
 *, 
kmutex_t
 *);

58 extern void 
cv_signal
(
kcondvar_t
 *);

59 extern void 
cv_broadcast
(
kcondvar_t
 *);

60 extern 
kcondvar_t
 *
cv_alloc
(char *, 
kcv_type_t
, void *);

61 extern void 
cv_free
(
kcondvar_t
 *);

67 #ifdef 
__cplusplus


	@/usr/include/sys/dl.h

8 #ifndef 
_SYS_DL_H


9 #define 
	#_SYS_DL_H


	)
11 #pragma 
ident
 "@(#)dl.h 1.13 93/08/18 SMI"

13 #include 
	~<sys/isa_defs.h
>

15 #ifdef 
__cplusplus


19 typedef struct 
	sdl
 {

20 #ifdef 
_LONG_LONG_LTOH


21 
ulong_t
 
dl_lop
;

22 long 
dl_hop
;

24 long 
dl_hop
;

25 
ulong_t
 
dl_lop
;

27 } 
	tdl_t
;

29 #ifdef 
__STDC__


30 extern 
dl_t
 
ladd
(dl_t, dl_t);

31 extern 
dl_t
 
lsub
(dl_t, dl_t);

32 extern 
dl_t
 
lmul
(dl_t, dl_t);

33 extern 
dl_t
 
ldivide
(dl_t, dl_t);

34 extern 
dl_t
 
lshiftl
(dl_t, int);

35 extern 
dl_t
 
llog10
(dl_t);

36 extern 
dl_t
 
lexp10
(dl_t);

38 extern 
dl_t
 
ladd
();

39 extern 
dl_t
 
lsub
();

40 extern 
dl_t
 
lmul
();

41 extern 
dl_t
 
ldivide
();

42 extern 
dl_t
 
lshiftl
();

43 extern 
dl_t
 
llog10
();

44 extern 
dl_t
 
lexp10
();

47 extern 
dl_t
 
lzero
;

48 extern 
dl_t
 
lone
;

49 extern 
dl_t
 
lten
;

51 #ifdef 
__cplusplus


	@/usr/include/sys/lwp.h

5 #ifndef 
_SYS_LWP_H


6 #define 
	#_SYS_LWP_H


	)
8 #pragma 
ident
 "@(#)lwp.h 1.26 95/03/15 SMI"

10 #include 
	~<sys/synch.h
>

11 #include 
	~<sys/ucontext.h
>

13 #ifdef 
__cplusplus


20 #define 
	#LWP_DETACHED
 0x00000040

	)
21 #define 
	#LWP_SUSPENDED
 0x00000080

	)
27 #define 
	#__LWP_ASLWP
 0x00000100

	)
32 struct 
	slwpinfo
 {

33 
timestruc_t
 
lwp_utime
;

34 
timestruc_t
 
lwp_stime
;

35 long 
lwpinfo_pad
 [64];

38 #ifndef 
_KERNEL


40 typedef unsigned int 
	tlwpid_t
;

42 void 
_lwp_makecontext
(
ucontext_t
 *, void ((*)(void *)),

43 void *, void *, 
caddr_t
, 
size_t
);

44 int 
_lwp_create
(
ucontext_t
 *, unsigned long, 
lwpid_t
 *);

45 int 
_lwp_kill
(
lwpid_t
, int);

46 int 
_lwp_info
(struct 
lwpinfo
 *);

47 void 
_lwp_exit
(void);

48 int 
_lwp_wait
(
lwpid_t
, lwpid_t *);

49 
lwpid_t
 
_lwp_self
(void);

50 int 
_lwp_suspend
(
lwpid_t
);

51 int 
_lwp_continue
(
lwpid_t
);

52 void 
_lwp_setprivate
(void *);

53 void* 
_lwp_getprivate
(void);

57 #ifdef 
__cplusplus


	@/usr/include/sys/machlock.h

5 #ifndef 
_SYS_MACHLOCK_H


6 #define 
	#_SYS_MACHLOCK_H


	)
8 #pragma 
ident
 "@(#)machlock.h 1.14 94/10/20 SMI"

10 #ifdef 
__cplusplus


14 #ifndef 
_ASM


16 #include 
	~<sys/types.h
>

18 #ifdef 
__STDC__


19 extern void 
lock_set
(
lock_t
 *
lp
);

20 extern int 
lock_try
(
lock_t
 *
lp
);

21 extern int 
ulock_try
(
lock_t
 *
lp
);

22 extern void 
lock_clear
(
lock_t
 *
lp
);

23 extern void 
ulock_clear
(
lock_t
 *
lp
);

25 extern int 
lock_set_spl
(
lock_t
 *
lp
, int 
pl
);

26 extern void 
lock_clear_splx
(
lock_t
 *
lp
, int 
s
);

28 extern void 
lock_set
();

29 extern int 
lock_try
();

30 extern int 
ulock_try
();

31 extern void 
lock_clear
();

32 extern void 
ulock_clear
();

34 extern int 
lock_set_spl
();

35 extern void 
lock_clear_splx
();

38 #define 
	#LOCK_HELD_VALUE
 0xff

	)
39 #define 
	#LOCK_INIT_CLEAR
(
lp
) (*(lp) = 0)

	)
40 #define 
	#LOCK_INIT_HELD
(
lp
) (*(lp) = 
LOCK_HELD_VALUE
)

	)
41 #define 
	#LOCK_HELD
(
lp
) (*(lp) != 0)

	)
43 typedef 
lock_t
 
	tdisp_lock_t
;

49 #define 
	#SPIN_LOCK
(
pl
) ((pl) > 
	`ipltospl
(
LOCK_LEVEL
))

	)
57 #define 
	#LOCK_SAMPLE_INTERVAL
(
i
) (((i) & 0xff) == 0)

	)
62 extern int 
hres_lock
;

63 extern int 
clock_res
;

67 #define 
	#LOCK_LEVEL
 10

	)
68 #define 
	#CLOCK_LEVEL
 10

	)
78 #define 
	#PTR24_LSB
 5

	)
79 #define 
	#PTR24_MSB
 (
PTR24_LSB
 + 24)

	)
80 #define 
	#PTR24_ALIGN
 32

	)
81 #define 
	#PTR24_BASE
 0xe0000000

	)
83 #ifdef 
__cplusplus


	@/usr/include/sys/msacct.h

5 #ifndef 
_SYS_MSACCT_H


6 #define 
	#_SYS_MSACCT_H


	)
8 #pragma 
ident
 "@(#)msacct.h 1.7 93/07/13 SMI"

10 #ifdef 
__cplusplus


15 #define 
	#LMS_USER
 0

	)
16 #define 
	#LMS_SYSTEM
 1

	)
17 #define 
	#LMS_TRAP
 2

	)
18 #define 
	#LMS_TFAULT
 3

	)
19 #define 
	#LMS_DFAULT
 4

	)
20 #define 
	#LMS_KFAULT
 5

	)
21 #define 
	#LMS_USER_LOCK
 6

	)
22 #define 
	#LMS_SLEEP
 7

	)
23 #define 
	#LMS_WAIT_CPU
 8

	)
24 #define 
	#LMS_STOPPED
 9

	)
30 #define 
	#NMSTATES
 10

	)
32 #ifdef 
__cplusplus


	@/usr/include/sys/rwlock.h

13 #ifndef 
_SYS_RWLOCK_H


14 #define 
	#_SYS_RWLOCK_H


	)
16 #pragma 
ident
 "@(#)rwlock.h 1.3 94/07/29 SMI"

18 #ifdef 
__cplusplus


22 #ifndef 
_ASM


24 typedef enum 
	e
{

25 
RW_SLEEP
,

26 
RW_SLEEP_STAT
,

27 
RW_DRIVER_NOSTAT
 = 2,

28 
RW_DRIVER_STAT
 = 3,

29 
RW_DEFAULT


30 } 
	tkrw_type_t
;

32 typedef enum 
	e
{

33 
	mRW_WRITER
,

34 
	mRW_READER


35 } 
	tkrw_t
;

37 #if 
defined
(
_LOCKTEST
) || defined(
_MPSTATS
)

38 #define 
	#RW_DRIVER
 
RW_DRIVER_STAT


	)
40 #define 
	#RW_DRIVER
 
RW_DRIVER_NOSTAT


	)
43 typedef struct 
	s_krwlock
 {

44 void *
	m_opaque
[3];

45 } 
	tkrwlock_t
;

48 #if 
defined
(
_KERNEL
)

50 #define 
	#RW_READ_HELD
(
x
) (
	`rw_read_held
((x)))

	)
51 #define 
	#RW_WRITE_HELD
(
x
) (
	`rw_write_held
((x)))

	)
52 #define 
	#RW_LOCK_HELD
(
x
) (
	`rw_lock_held
((x)))

	)
53 #define 
	#RW_ISWRITER
(
x
) (
	`rw_iswriter
(x))

	)
55 extern void 
rw_init
(
krwlock_t
 *, char *, 
krw_type_t
, void *);

56 extern void 
rw_destroy
(
krwlock_t
 *);

57 extern void 
rw_enter
(
krwlock_t
 *, 
krw_t
);

58 extern int 
rw_tryenter
(
krwlock_t
 *, 
krw_t
);

59 extern int 
rw_read_locked
(
krwlock_t
 *);

60 extern void 
rw_exit
(
krwlock_t
 *);

61 extern void 
rw_downgrade
(
krwlock_t
 *);

62 extern int 
rw_tryupgrade
(
krwlock_t
 *);

63 extern int 
rw_read_held
(
krwlock_t
 *);

64 extern int 
rw_write_held
(
krwlock_t
 *);

65 extern int 
rw_lock_held
(
krwlock_t
 *);

66 extern int 
rw_iswriter
(
krwlock_t
 *);

67 extern void 
rw_mutex_init
(void);

68 extern struct 
_kthread
 *
rw_owner
(
krwlock_t
 *);

74 #ifdef 
__cplusplus


	@/usr/include/sys/semaphore.h

14 #ifndef 
_SYS_SEMAPHORE_H


15 #define 
	#_SYS_SEMAPHORE_H


	)
17 #pragma 
ident
 "@(#)semaphore.h 1.4 94/07/29 SMI"

19 #ifndef 
_ASM


20 #ifdef 
_KERNEL


21 #include 
	~<sys/thread.h
>

26 #ifdef 
__cplusplus


30 #ifndef 
_ASM


35 typedef enum 
	e
{

36 
SEMA_DEFAULT
,

37 
SEMA_DRIVER


38 } 
	tksema_type_t
;

40 typedef struct 
	s_ksema
 {

41 void * 
	m_opaque
[2];

42 } 
	tksema_t
;

44 #if 
defined
(
_KERNEL
)

46 #define 
	#SEMA_HELD
(
x
) (
	`sema_held
((x)))

	)
48 extern void 
sema_init
(
ksema_t
 *, unsigned int, char *,

49 
ksema_type_t
, void *);

50 extern void 
sema_destroy
(
ksema_t
 *);

51 extern void 
sema_p
(
ksema_t
 *);

52 extern int 
sema_p_sig
(
ksema_t
 *);

53 extern void 
sema_v
(
ksema_t
 *);

54 extern int 
sema_tryp
(
ksema_t
 *);

55 extern int 
sema_held
(
ksema_t
 *);

56 extern void 
sema_mutex_init
(void);

61 #ifdef 
__cplusplus


	@/usr/include/sys/ucontext.h

8 #ifndef 
_SYS_UCONTEXT_H


9 #define 
	#_SYS_UCONTEXT_H


	)
11 #pragma 
ident
 "@(#)ucontext.h 1.13 94/03/17 SMI"

13 #include 
	~<sys/types.h
>

14 #include 
	~<sys/regset.h
>

15 #include 
	~<sys/signal.h
>

17 #ifdef 
__cplusplus


21 typedef struct 
	sucontext
 {

22 
u_long
 
uc_flags
;

23 struct 
ucontext
 *
uc_link
;

24 
sigset_t
 
uc_sigmask
;

25 
stack_t
 
uc_stack
;

26 
mcontext_t
 
uc_mcontext
;

27 long 
uc_filler
[23];

28 } 
	tucontext_t
;

30 #define 
	#GETCONTEXT
 0

	)
31 #define 
	#SETCONTEXT
 1

	)
40 #define 
	#UC_SIGMASK
 001

	)
41 #define 
	#UC_STACK
 002

	)
42 #define 
	#UC_CPU
 004

	)
43 #define 
	#UC_MAU
 010

	)
44 #define 
	#UC_FPU
 
UC_MAU


	)
45 #define 
	#UC_INTR
 020

	)
47 #define 
	#UC_MCONTEXT
 (
UC_CPU
|
UC_FPU
)

	)
53 #define 
	#UC_ALL
 (
UC_SIGMASK
|
UC_STACK
|
UC_MCONTEXT
)

	)
55 #ifdef 
_KERNEL


57 void 
savecontext
(
ucontext_t
 *, 
k_sigset_t
);

61 #ifdef 
__cplusplus


	@/usr/include/sys/unistd.h

17 #ifndef 
_SYS_UNISTD_H


18 #define 
	#_SYS_UNISTD_H


	)
20 #pragma 
ident
 "@(#)unistd.h 1.24 95/08/24 SMI"

22 #include 
	~<sys/feature_tests.h
>

24 #ifdef 
__cplusplus


31 #define 
	#_SC_ARG_MAX
 1

	)
32 #define 
	#_SC_CHILD_MAX
 2

	)
33 #define 
	#_SC_CLK_TCK
 3

	)
34 #define 
	#_SC_NGROUPS_MAX
 4

	)
35 #define 
	#_SC_OPEN_MAX
 5

	)
36 #define 
	#_SC_JOB_CONTROL
 6

	)
37 #define 
	#_SC_SAVED_IDS
 7

	)
38 #define 
	#_SC_VERSION
 8

	)
40 #define 
	#_SC_PASS_MAX
 9

	)
41 #define 
	#_SC_LOGNAME_MAX
 10

	)
42 #define 
	#_SC_PAGESIZE
 11

	)
43 #define 
	#_SC_XOPEN_VERSION
 12

	)
45 #define 
	#_SC_NPROCESSORS_CONF
 14

	)
46 #define 
	#_SC_NPROCESSORS_ONLN
 15

	)
47 #define 
	#_SC_STREAM_MAX
 16

	)
48 #define 
	#_SC_TZNAME_MAX
 17

	)
50 #define 
	#_SC_AIO_LISTIO_MAX
 18

	)
51 #define 
	#_SC_AIO_MAX
 19

	)
52 #define 
	#_SC_AIO_PRIO_DELTA_MAX
 20

	)
53 #define 
	#_SC_ASYNCHRONOUS_IO
 21

	)
54 #define 
	#_SC_DELAYTIMER_MAX
 22

	)
55 #define 
	#_SC_FSYNC
 23

	)
56 #define 
	#_SC_MAPPED_FILES
 24

	)
57 #define 
	#_SC_MEMLOCK
 25

	)
58 #define 
	#_SC_MEMLOCK_RANGE
 26

	)
59 #define 
	#_SC_MEMORY_PROTECTION
 27

	)
60 #define 
	#_SC_MESSAGE_PASSING
 28

	)
61 #define 
	#_SC_MQ_OPEN_MAX
 29

	)
62 #define 
	#_SC_MQ_PRIO_MAX
 30

	)
63 #define 
	#_SC_PRIORITIZED_IO
 31

	)
64 #define 
	#_SC_PRIORITY_SCHEDULING
 32

	)
65 #define 
	#_SC_REALTIME_SIGNALS
 33

	)
66 #define 
	#_SC_RTSIG_MAX
 34

	)
67 #define 
	#_SC_SEMAPHORES
 35

	)
68 #define 
	#_SC_SEM_NSEMS_MAX
 36

	)
69 #define 
	#_SC_SEM_VALUE_MAX
 37

	)
70 #define 
	#_SC_SHARED_MEMORY_OBJECTS
 38

	)
71 #define 
	#_SC_SIGQUEUE_MAX
 39

	)
72 #define 
	#_SC_SIGRT_MIN
 40

	)
73 #define 
	#_SC_SIGRT_MAX
 41

	)
74 #define 
	#_SC_SYNCHRONIZED_IO
 42

	)
75 #define 
	#_SC_TIMERS
 43

	)
76 #define 
	#_SC_TIMER_MAX
 44

	)
78 #define 
	#_SC_2_C_BIND
 45

	)
79 #define 
	#_SC_2_C_DEV
 46

	)
80 #define 
	#_SC_2_C_VERSION
 47

	)
81 #define 
	#_SC_2_FORT_DEV
 48

	)
82 #define 
	#_SC_2_FORT_RUN
 49

	)
83 #define 
	#_SC_2_LOCALEDEF
 50

	)
84 #define 
	#_SC_2_SW_DEV
 51

	)
85 #define 
	#_SC_2_UPE
 52

	)
86 #define 
	#_SC_2_VERSION
 53

	)
87 #define 
	#_SC_BC_BASE_MAX
 54

	)
88 #define 
	#_SC_BC_DIM_MAX
 55

	)
89 #define 
	#_SC_BC_SCALE_MAX
 56

	)
90 #define 
	#_SC_BC_STRING_MAX
 57

	)
91 #define 
	#_SC_COLL_WEIGHTS_MAX
 58

	)
92 #define 
	#_SC_EXPR_NEST_MAX
 59

	)
93 #define 
	#_SC_LINE_MAX
 60

	)
94 #define 
	#_SC_RE_DUP_MAX
 61

	)
95 #define 
	#_SC_XOPEN_CRYPT
 62

	)
96 #define 
	#_SC_XOPEN_ENH_I18N
 63

	)
97 #define 
	#_SC_XOPEN_SHM
 64

	)
99 #define 
	#_CS_PATH
 65

	)
102 #define 
	#_SC_2_CHAR_TERM
 66

	)
103 #define 
	#_SC_XOPEN_XCU_VERSION
 67

	)
106 #define 
	#_SC_PHYS_PAGES
 500

	)
107 #define 
	#_SC_AVPHYS_PAGES
 501

	)
112 #define 
	#_SC_COHER_BLKSZ
 503

	)
113 #define 
	#_SC_SPLIT_CACHE
 504

	)
114 #define 
	#_SC_ICACHE_SZ
 505

	)
115 #define 
	#_SC_DCACHE_SZ
 506

	)
116 #define 
	#_SC_ICACHE_LINESZ
 507

	)
117 #define 
	#_SC_DCACHE_LINESZ
 508

	)
118 #define 
	#_SC_ICACHE_BLKSZ
 509

	)
119 #define 
	#_SC_DCACHE_BLKSZ
 510

	)
120 #define 
	#_SC_DCACHE_TBLKSZ
 511

	)
121 #define 
	#_SC_ICACHE_ASSOC
 512

	)
122 #define 
	#_SC_DCACHE_ASSOC
 513

	)
128 #define 
	#_SC_THREAD_DESTRUCTOR_ITERATIONS
 568

	)
129 #define 
	#_SC_GETGR_R_SIZE_MAX
 569

	)
130 #define 
	#_SC_GETPW_R_SIZE_MAX
 570

	)
131 #define 
	#_SC_LOGIN_NAME_MAX
 571

	)
132 #define 
	#_SC_THREAD_KEYS_MAX
 572

	)
133 #define 
	#_SC_THREAD_STACK_MIN
 573

	)
134 #define 
	#_SC_THREAD_THREADS_MAX
 574

	)
135 #define 
	#_SC_TTY_NAME_MAX
 575

	)
136 #define 
	#_SC_THREADS
 576

	)
137 #define 
	#_SC_THREAD_ATTR_STACKADDR
 577

	)
138 #define 
	#_SC_THREAD_ATTR_STACKSIZE
 578

	)
139 #define 
	#_SC_THREAD_PRIORITY_SCHEDULING
 579

	)
140 #define 
	#_SC_THREAD_PRIO_INHERIT
 580

	)
141 #define 
	#_SC_THREAD_PRIO_PROTECT
 581

	)
142 #define 
	#_SC_THREAD_PROCESS_SHARED
 582

	)
143 #define 
	#_SC_THREAD_SAFE_FUNCTIONS
 583

	)
146 #define 
	#_SC_PPC_GRANULE_SZ
 601

	)
147 #define 
	#_SC_PPC_TB_TICKSPSECH
 602

	)
148 #define 
	#_SC_PPC_TB_TICKSPSECL
 603

	)
154 #define 
	#_PC_LINK_MAX
 1

	)
155 #define 
	#_PC_MAX_CANON
 2

	)
156 #define 
	#_PC_MAX_INPUT
 3

	)
157 #define 
	#_PC_NAME_MAX
 4

	)
158 #define 
	#_PC_PATH_MAX
 5

	)
159 #define 
	#_PC_PIPE_BUF
 6

	)
160 #define 
	#_PC_NO_TRUNC
 7

	)
161 #define 
	#_PC_VDISABLE
 8

	)
162 #define 
	#_PC_CHOWN_RESTRICTED
 9

	)
164 #define 
	#_PC_ASYNC_IO
 10

	)
165 #define 
	#_PC_PRIO_IO
 11

	)
166 #define 
	#_PC_SYNC_IO
 12

	)
167 #define 
	#_PC_LAST
 12

	)
169 #ifndef 
_POSIX_VERSION


170 #define 
	#_POSIX_VERSION
 199506L

	)
173 #ifndef 
_POSIX2_VERSION


174 #define 
	#_POSIX2_VERSION
 199209L

	)
177 #ifndef 
_POSIX2_C_VERSION


178 #define 
	#_POSIX2_C_VERSION
 199209L

	)
181 #ifndef 
_XOPEN_VERSION


182 #define 
	#_XOPEN_VERSION
 3

	)
183 #define 
	#_XOPEN_XPG3


	)
186 #ifndef 
_XOPEN_XCU_VERSION


187 #define 
	#_XOPEN_XCU_VERSION
 4

	)
190 #define 
	#_POSIX2_C_BIND
 1

	)
191 #define 
	#_POSIX2_CHAR_TERM
 1

	)
192 #define 
	#_POSIX2_LOCALEDEF
 1

	)
193 #define 
	#_POSIX2_C_DEV
 1

	)
194 #define 
	#_POSIX2_SW_DEV
 1

	)
195 #define 
	#_POSIX2_UPE
 1

	)
197 #define 
	#_XOPEN_XPG4


	)
199 #ifdef 
__cplusplus


	@/usr/include/v7/sys/privregs.h

5 #ifndef 
_SYS_PRIVREGS_H


6 #define 
	#_SYS_PRIVREGS_H


	)
8 #pragma 
ident
 "@(#)privregs.h 1.3 95/02/24 SMI"

10 #ifdef 
__cplusplus


23 #include 
	~<v7/sys/psr.h
>

24 #include 
	~<sys/fsr.h
>

26 #ifndef 
_ASM


28 struct 
	sregs
 {

29 int 
r_psr
;

30 int 
r_pc
;

31 int 
r_npc
;

32 int 
r_y
;

33 int 
r_g1
;

34 int 
r_g2
;

35 int 
r_g3
;

36 int 
r_g4
;

37 int 
r_g5
;

38 int 
r_g6
;

39 int 
r_g7
;

40 int 
r_o0
;

41 int 
r_o1
;

42 int 
r_o2
;

43 int 
r_o3
;

44 int 
r_o4
;

45 int 
r_o5
;

46 int 
r_o6
;

47 int 
r_o7
;

50 #define 
	#r_ps
 
r_psr


	)
51 #define 
	#r_r0
 
r_o0


	)
52 #define 
	#r_sp
 
r_o6


	)
56 #ifdef 
_KERNEL


58 #define 
	#lwptoregs
(
lwp
) ((struct 
regs
 *)((lwp)->
lwp_regs
))

	)
59 #define 
	#lwptofpu
(
lwp
) ((struct 
fpu
 *)((lwp)->
lwp_fpu
))

	)
65 #define 
	#SAVE_GLOBALS
(
RP
) \

66 
st
 %
g1
, [
RP
 + 
G1
*4]; \

67 
std
 %
g2
, [
RP
 + 
G2
*4]; \

68 
std
 %
g4
, [
RP
 + 
G4
*4]; \

69 
std
 %
g6
, [
RP
 + 
G6
*4]; \

70 
mov
 %
y
, %
g1
; \

71 
st
 %
g1
, [
RP
 + 
Y
*4]

	)
73 #define 
	#RESTORE_GLOBALS
(
RP
) \

74 
ld
 [
RP
 + 
Y
*4], %
g1
; \

75 
mov
 %
g1
, %
y
; \

76 
ld
 [
RP
 + 
G1
*4], %
g1
; \

77 
ldd
 [
RP
 + 
G2
*4], %
g2
; \

78 
ldd
 [
RP
 + 
G4
*4], %
g4
; \

79 
ldd
 [
RP
 + 
G6
*4], %
g6
;

	)
81 #define 
	#SAVE_OUTS
(
RP
) \

82 
std
 %
i0
, [
RP
 + 
O0
*4]; \

83 
std
 %
i2
, [
RP
 + 
O2
*4]; \

84 
std
 %
i4
, [
RP
 + 
O4
*4]; \

85 
std
 %
i6
, [
RP
 + 
O6
*4];

	)
87 #define 
	#RESTORE_OUTS
(
RP
) \

88 
ldd
 [
RP
 + 
O0
*4], %
i0
; \

89 
ldd
 [
RP
 + 
O2
*4], %
i2
; \

90 
ldd
 [
RP
 + 
O4
*4], %
i4
; \

91 
ldd
 [
RP
 + 
O6
*4], %
i6
;

	)
93 #define 
	#SAVE_WINDOW
(
SBP
) \

94 
std
 %
l0
, [
SBP
 + (0*4)]; \

95 
std
 %
l2
, [
SBP
 + (2*4)]; \

96 
std
 %
l4
, [
SBP
 + (4*4)]; \

97 
std
 %
l6
, [
SBP
 + (6*4)]; \

98 
std
 %
i0
, [
SBP
 + (8*4)]; \

99 
std
 %
i2
, [
SBP
 + (10*4)]; \

100 
std
 %
i4
, [
SBP
 + (12*4)]; \

101 
std
 %
i6
, [
SBP
 + (14*4)];

	)
103 #define 
	#RESTORE_WINDOW
(
SBP
) \

104 
ldd
 [
SBP
 + (0*4)], %
l0
; \

105 
ldd
 [
SBP
 + (2*4)], %
l2
; \

106 
ldd
 [
SBP
 + (4*4)], %
l4
; \

107 
ldd
 [
SBP
 + (6*4)], %
l6
; \

108 
ldd
 [
SBP
 + (8*4)], %
i0
; \

109 
ldd
 [
SBP
 + (10*4)], %
i2
; \

110 
ldd
 [
SBP
 + (12*4)], %
i4
; \

111 
ldd
 [
SBP
 + (14*4)], %
i6
;

	)
113 #define 
	#STORE_FPREGS
(
FP
) \

114 
std
 %
f0
, [
FP
]; \

115 
std
 %
f2
, [
FP
 + 8]; \

116 
std
 %
f4
, [
FP
 + 16]; \

117 
std
 %
f6
, [
FP
 + 24]; \

118 
std
 %
f8
, [
FP
 + 32]; \

119 
std
 %
f10
, [
FP
 + 40]; \

120 
std
 %
f12
, [
FP
 + 48]; \

121 
std
 %
f14
, [
FP
 + 56]; \

122 
std
 %
f16
, [
FP
 + 64]; \

123 
std
 %
f18
, [
FP
 + 72]; \

124 
std
 %
f20
, [
FP
 + 80]; \

125 
std
 %
f22
, [
FP
 + 88]; \

126 
std
 %
f24
, [
FP
 + 96]; \

127 
std
 %
f26
, [
FP
 + 104]; \

128 
std
 %
f28
, [
FP
 + 112]; \

129 
std
 %
f30
, [
FP
 + 120];

	)
131 #define 
	#LOAD_FPREGS
(
FP
) \

132 
ldd
 [
FP
], %
f0
; \

133 
ldd
 [
FP
 + 8], %
f2
; \

134 
ldd
 [
FP
 + 16], %
f4
; \

135 
ldd
 [
FP
 + 24], %
f6
; \

136 
ldd
 [
FP
 + 32], %
f8
; \

137 
ldd
 [
FP
 + 40], %
f10
; \

138 
ldd
 [
FP
 + 48], %
f12
; \

139 
ldd
 [
FP
 + 56], %
f14
; \

140 
ldd
 [
FP
 + 64], %
f16
; \

141 
ldd
 [
FP
 + 72], %
f18
; \

142 
ldd
 [
FP
 + 80], %
f20
; \

143 
ldd
 [
FP
 + 88], %
f22
; \

144 
ldd
 [
FP
 + 96], %
f24
; \

145 
ldd
 [
FP
 + 104], %
f26
; \

146 
ldd
 [
FP
 + 112], %
f28
; \

147 
ldd
 [
FP
 + 120], %
f30
;

	)
151 #ifdef 
__cplusplus


	@/usr/include/sys/fsr.h

5 #ifndef 
_SYS_FSR_H


6 #define 
	#_SYS_FSR_H


	)
8 #pragma 
ident
 "@(#)fsr.h 1.2 94/11/18 SMI"

10 #ifdef 
__cplusplus


36 #define 
	#FSR_CEXC
 0x0000001f

	)
37 #define 
	#FSR_AEXC
 0x000003e0

	)
38 #define 
	#FSR_FCC
 0x00000c00

	)
39 #define 
	#FSR_PR
 0x00001000

	)
40 #define 
	#FSR_QNE
 0x00002000

	)
41 #define 
	#FSR_FTT
 0x0001c000

	)
42 #define 
	#FSR_VER
 0x000e0000

	)
43 #define 
	#FSR_TEM
 0x0f800000

	)
44 #define 
	#FSR_RP
 0x30000000

	)
45 #define 
	#FSR_RD
 0xc0000000

	)
46 #define 
	#FSR_VER_SHIFT
 17

	)
47 #define 
	#FSR_FCC1
 0x00000003

	)
48 #define 
	#FSR_FCC2
 0x0000000C

	)
49 #define 
	#FSR_FCC3
 0x00000030

	)
54 #define 
	#FSR_CEXC_NX
 0x00000001

	)
55 #define 
	#FSR_CEXC_DZ
 0x00000002

	)
56 #define 
	#FSR_CEXC_UF
 0x00000004

	)
57 #define 
	#FSR_CEXC_OF
 0x00000008

	)
58 #define 
	#FSR_CEXC_NV
 0x00000010

	)
63 #define 
	#FSR_AEXC_NX
 (0x1 << 5)

	)
64 #define 
	#FSR_AEXC_DZ
 (0x2 << 5)

	)
65 #define 
	#FSR_AEXC_UF
 (0x4 << 5)

	)
66 #define 
	#FSR_AEXC_OF
 (0x8 << 5)

	)
67 #define 
	#FSR_AEXC_NV
 (0x10 << 5)

	)
72 #define 
	#FTT_NONE
 0

	)
73 #define 
	#FTT_IEEE
 1

	)
74 #define 
	#FTT_UNFIN
 2

	)
75 #define 
	#FTT_UNIMP
 3

	)
76 #define 
	#FTT_SEQ
 4

	)
77 #define 
	#FTT_ALIGN
 5

	)
78 #define 
	#FTT_DFAULT
 6

	)
79 #define 
	#FSR_FTT_SHIFT
 14

	)
80 #define 
	#FSR_FTT_IEEE
 (
FTT_IEEE
 << 
FSR_FTT_SHIFT
)

	)
81 #define 
	#FSR_FTT_UNFIN
 (
FTT_UNFIN
 << 
FSR_FTT_SHIFT
)

	)
82 #define 
	#FSR_FTT_UNIMP
 (
FTT_UNIMP
 << 
FSR_FTT_SHIFT
)

	)
83 #define 
	#FSR_FTT_SEQ
 (
FTT_SEQ
 << 
FSR_FTT_SHIFT
)

	)
84 #define 
	#FSR_FTT_ALIGN
 (
FTT_ALIGN
 << 
FSR_FTT_SHIFT
)

	)
85 #define 
	#FSR_FTT_DFAULT
 (
FTT_DFAULT
 << 
FSR_FTT_SHIFT
)

	)
90 #define 
	#FSR_TEM_NX
 (0x1 << 23)

	)
91 #define 
	#FSR_TEM_DZ
 (0x2 << 23)

	)
92 #define 
	#FSR_TEM_UF
 (0x4 << 23)

	)
93 #define 
	#FSR_TEM_OF
 (0x8 << 23)

	)
94 #define 
	#FSR_TEM_NV
 (0x10 << 23)

	)
99 #define 
	#RP_DBLEXT
 0

	)
100 #define 
	#RP_SINGLE
 1

	)
101 #define 
	#RP_DOUBLE
 2

	)
102 #define 
	#RP_RESERVED
 3

	)
107 #define 
	#RD_NEAR
 0

	)
108 #define 
	#RD_ZER0
 1

	)
109 #define 
	#RD_POSINF
 2

	)
110 #define 
	#RD_NEGINF
 3

	)
122 #define 
	#FPRS_DL
 0x1

	)
123 #define 
	#FPRS_DU
 0x2

	)
124 #define 
	#FPRS_FEF
 0x4

	)
126 #ifdef 
__cplusplus


	@/usr/include/sys/synch.h

5 #ifndef 
_SYS_SYNCH_H


6 #define 
	#_SYS_SYNCH_H


	)
8 #pragma 
ident
 "@(#)synch.h 1.21 93/04/13 SMI"

10 #include 
	~<sys/types.h
>

12 #ifdef 
__cplusplus


16 #ifndef 
_UINT8_T


17 #define 
	#_UINT8_T


	)
18 typedef unsigned char 
	tuint8_t
;

20 #ifndef 
_UINT32_T


21 #define 
	#_UINT32_T


	)
22 typedef unsigned long 
	tuint32_t
;

24 #ifndef 
_UINT64_T


25 #define 
	#_UINT64_T


	)
26 typedef 
u_longlong_t
 
	tuint64_t
;

33 typedef struct 
	s_lwp_mutex
 {

34 struct 
	s_mutex_flags
 {

35 
uint8_t
 
	gflag
[4];

36 
uint32_t
 
	gtype
;

37 } 
	gflags
;

38 union 
	u_mutex_lock_un
 {

39 struct 
	s_mutex_lock
 {

40 
uint8_t
 
	gpad
[8];

41 } 
	glock64
;

42 
uint64_t
 
	gowner64
;

43 } 
	glock
;

44 
uint64_t
 
	gdata
;

45 } 
	tlwp_mutex_t
;

47 #define 
	#mutex_lockw
 
lock
.
lock64
.
pad
[7]

	)
53 typedef struct 
	s_lwp_cond
 {

54 struct 
	s_lwp_cond_flags
 {

55 
uint8_t
 
	gflag
[4];

56 
uint32_t
 
	gtype
;

57 } 
	gflags
;

58 
uint64_t
 
	gdata
;

59 } 
	tlwp_cond_t
;

66 typedef struct 
	s_lwp_sema
 {

67 
uint32_t
 
	gcount
;

68 
uint32_t
 
	gtype
;

69 
uint8_t
 
	gflags
[8];

70 
uint64_t
 
	gdata
;

71 } 
	tlwp_sema_t
;

76 #define 
	#USYNC_THREAD
 0

	)
77 #define 
	#USYNC_PROCESS
 1

	)
78 #define 
	#TRACE_TYPE
 2

	)
80 #ifdef 
__cplusplus


	@/usr/include/v7/sys/psr.h

5 #ifndef 
_SYS_PSR_H


6 #define 
	#_SYS_PSR_H


	)
8 #pragma 
ident
 "@(#)psr.h 1.2 94/10/06 SMI"

10 #ifdef 
__cplusplus


26 #define 
	#PSR_CWP
 0x0000001F

	)
27 #define 
	#PSR_ET
 0x00000020

	)
28 #define 
	#PSR_PS
 0x00000040

	)
29 #define 
	#PSR_S
 0x00000080

	)
30 #define 
	#PSR_PIL
 0x00000F00

	)
31 #define 
	#PSR_EF
 0x00001000

	)
32 #define 
	#PSR_EC
 0x00002000

	)
33 #define 
	#PSR_RSV
 0x000FC000

	)
34 #define 
	#PSR_ICC
 0x00F00000

	)
35 #define 
	#PSR_C
 0x00100000

	)
36 #define 
	#PSR_V
 0x00200000

	)
37 #define 
	#PSR_Z
 0x00400000

	)
38 #define 
	#PSR_N
 0x00800000

	)
39 #define 
	#PSR_VER
 0x0F000000

	)
40 #define 
	#PSR_IMPL
 0xF0000000

	)
42 #define 
	#PSL_ALLCC
 
PSR_ICC


	)
44 #ifndef 
_ASM


45 typedef int 
	tpsw_t
;

51 #define 
	#PSL_USER
 (
PSR_S
)

	)
52 #define 
	#PSL_USERMASK
 (
PSR_ICC
)

	)
54 #define 
	#PSL_UBITS
 (
PSR_ICC
|
PSR_EF
)

	)
57 #ifndef 
__sparcv9


61 #define 
	#USERMODE
(
ps
) (((ps) & 
PSR_PS
) == 0)

	)
64 #ifdef 
__cplusplus


	@
1
.
1
/usr/include
132
3218
include/aigraph.h
include/ainodes.h
include/aisearch.h
include/aitree.h
include/aosearch.h
include/bisearch.h
include/blist.h
include/btrack.h
include/logic.h
include/minimax.h
include/xarray.h
include/xlist.h
include/xstring.h
programs/8puzzle/8puzzle.cc
programs/8puzzle/8puzzle.h
programs/8puzzle/8puzzle2.cc
programs/8puzzle/8puzzle2.h
programs/8puzzle/8puzzle3.cc
programs/8puzzle/8puzzle3.h
programs/logic/logic.cc
programs/logic/test1.cc
programs/logic/test2.cc
programs/logic/test3.cc
programs/parser/data.cc
programs/parser/parser.cc
programs/parser/parser.h
programs/parser/run.cc
programs/planner/frule.cc
programs/planner/planner.cc
programs/planner/run.cc
programs/planner/strips.cc
programs/planner/strips.h
programs/prolog/pclause.cc
programs/prolog/pclause.h
programs/prolog/prolog.cc
programs/prolog/prolog.h
programs/prolog/ptable.cc
programs/prolog/ptable.h
programs/prolog/sample1.cc
programs/prolog/sample2.cc
programs/prover/clause.cc
programs/prover/clause.h
programs/prover/ctable.cc
programs/prover/ctable.h
programs/prover/literal.cc
programs/prover/literal.h
programs/prover/resnode.cc
programs/prover/resnode.h
programs/prover/run.cc
programs/route/route.cc
programs/route/route.h
programs/tictac/tictac.cc
programs/tictac/tictac.h
search/aosear/aosearch.cc
search/aosear/taobread.cc
search/aosear/taodepth.cc
search/bisear/bisearch.cc
search/bisear/gbibread.cc
search/bisear/gbidepth.cc
search/bisear/tbibread.cc
search/bisear/tbidepth.cc
search/btrack/btrack.cc
search/nodes/andnode.cc
search/nodes/aonode.cc
search/nodes/backnode.cc
search/nodes/bnode.cc
search/nodes/dnode.cc
search/nodes/node.cc
search/nodes/ornode.cc
search/nodes/unode.cc
search/unisear/astar.cc
search/unisear/gbreadth.cc
search/unisear/gdepth.cc
search/unisear/gucost.cc
search/unisear/search.cc
search/unisear/tbreadth.cc
search/unisear/tdepth.cc
search/unisear/tucost.cc
util/biter.cc
util/blist.cc
util/string.cc
/usr/include/ctype.h
/usr/include/stdarg.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/sys/feature_tests.h
/usr/include/sys/va_list.h
/usr/include/sys/wait.h
/usr/include/varargs.h
/usr/include/sys/procset.h
/usr/include/sys/siginfo.h
/usr/include/sys/types.h
/usr/include/sys/isa_defs.h
/usr/include/sys/machsig.h
/usr/include/sys/machtypes.h
/usr/include/sys/proc.h
/usr/include/sys/select.h
/usr/include/sys/time.h
/usr/include/sys/cred.h
/usr/include/sys/mutex.h
/usr/include/sys/thread.h
/usr/include/sys/timer.h
/usr/include/sys/user.h
/usr/include/time.h
/usr/include/sys/auxv.h
/usr/include/sys/class.h
/usr/include/sys/dki_lkinfo.h
/usr/include/sys/errno.h
/usr/include/sys/klwp.h
/usr/include/sys/param.h
/usr/include/sys/pcb.h
/usr/include/sys/pirec.h
/usr/include/sys/regset.h
/usr/include/sys/resource.h
/usr/include/sys/signal.h
/usr/include/sys/sleepq.h
/usr/include/sys/t_lock.h
/usr/include/sys/turnstile.h
/usr/include/sys/condvar.h
/usr/include/sys/dl.h
/usr/include/sys/lwp.h
/usr/include/sys/machlock.h
/usr/include/sys/msacct.h
/usr/include/sys/rwlock.h
/usr/include/sys/semaphore.h
/usr/include/sys/ucontext.h
/usr/include/sys/unistd.h
/usr/include/v7/sys/privregs.h
/usr/include/sys/fsr.h
/usr/include/sys/synch.h
/usr/include/v7/sys/psr.h
