// AO* best-first search for AND/OR graphs

// local headers
#include "search.h"

// print best-first AO* solution 
template <class NodeType>
void
PrintSolution(NodePtr<NodeType> &pnode)
{
	// print the current nodes solution
	cout << "NODE:" << pnode << endl;
	
	// loop through connectors to find the current best connector.
	ListIterator<Connector<NodePtr<NodeType> > > 
		connectorIter(*(pnode->getChildren()));
	for ( ; ! connectorIter.done(); connectorIter++)
	{
		if (connectorIter().getMarked())
		{
			// found best path connector
			break;
		}
	}
	MustBeTrue( ! connectorIter.done());

	// print the current connector solution
	cout << "CONNECTOR:" << connectorIter() << endl;

	// traverse through children and write out results
	ListIterator<NodePtr<NodeType> > childrenIter(connectorIter());
	for ( ; ! childrenIter.done(); childrenIter++)
	{
		// all nodes must be solved
		MustBeTrue(childrenIter()->getStatus() == Solved);

		// print results
		PrintSolution(childrenIter());
	}

	// all done
	return;
}

// back propagate any changes up the graph to the start node
template <class NodeType>
int
BackPropagate(NodePtr<NodeType> &pstart, NodePtr<NodeType> &backnode)
{
	// set of nodes that need updating
	List<NodePtr<NodeType> > updateset;
	updateset.insertAtFront(backnode);

	// update nodes until update set is empty
	for (NodePtr<NodeType> pnode; ! updateset.isEmpty(); )
	{
		// get first node
		if (updateset.removeAtFront(pnode) != OK)
		{
			// getting a node failed
			ERROR("remove at front failed for update set.", NOTOK);
			return(NOTOK);
		}

		// now check if any of this node's descendants
		// are also in the update set. we do not want
		// to visit a node before any of its descendants
		// since the descendant may have its hvalue updated
		// and this value then affects the parent. we need
		// to update all the children before the parent
		// is updated. that's the bottom line.
		// 
		int skipit = 0;
		ListIterator<Connector<NodePtr<NodeType> > > 
			connectorIter(*(pnode->getChildren()));
		for ( ; ! skipit && ! connectorIter.done(); connectorIter++)
		{
			ListIterator<NodePtr<NodeType> > 
				childrenIter(connectorIter());
			for ( ; ! skipit && ! childrenIter.done(); 
				childrenIter++)
			{
				if (updateset.isInList(childrenIter()))
				{
					// node has a child in the 
					// update set. put this node
					// at the end of the update
					// list and go on to the next
					// node in the update list.
					//
					updateset.insertAtEnd(pnode);
					skipit = 1;
				}
			}
		}

		// do we go to next node or continue with this one
		if (skipit) continue;

		// now we update the costs for this node
		int solved = 0;
		int minhvalue = INT_MAX;
		Connector<NodePtr<NodeType> > *pmincon = NULL;
		for (connectorIter.reset(); ! connectorIter.done(); 
			connectorIter++)
		{
			// clear marked bit
			connectorIter().setMarked(0);

			// add up costs of nodes. also add one
			// for each node in the connector.
			int notsolved = 0;
			int sumhvalue = 0;
			ListIterator<NodePtr<NodeType> > 
				childrenIter(connectorIter());
			for ( ; ! childrenIter.done(); childrenIter++)
			{
				sumhvalue += childrenIter()->getHvalue() + 1;
				if (childrenIter()->getStatus() != Solved)
					notsolved++;
			}
			connectorIter().setHvalue(sumhvalue);

			// is this the best yet?
			if (sumhvalue < minhvalue)
			{
				minhvalue = sumhvalue;
				pmincon = &(connectorIter());
			}

			// are all children solved?
			if (notsolved == 0)
			{
				connectorIter().setStatus(Solved);
			}

			// are any connectors solved?
			if (connectorIter().getStatus() == Solved)
				solved++;
		}

		// mark the new best connector
		MustBeTrue(pmincon != NULL);
		pmincon->setMarked(1);

		// update the hvalue for this node
		int updateparents = 0;
		if (pnode->getHvalue() != minhvalue)
		{
			pnode->setHvalue(minhvalue);
			updateparents = 1;
		}

		// now set the flag to indicate if node is solved
		if (solved > 0)
		{
			pnode->setStatus(Solved);
			updateparents = 1;
		}

		// place parents in update set
		if (updateparents)
		{
			List<NodePtr<NodeType> > 
				*pparents = pnode->getParents();
			MustBeTrue(pparents != NULL);
			if ( ! pparents->isEmpty())
			{
				ListIterator<NodePtr<NodeType> > 
					parentsIter(*pparents);
				for ( ; !parentsIter.done(); parentsIter++)
				{
					updateset.insertAtEnd(parentsIter());
				}
			}
		}
	}

	// all done
	return(OK);
}

// remove duplicate nodes that might have generated by node expansion
template <class NodeType>
int
RemoveDuplicates(NodePtr<NodeType> &pnode, List<NodePtr<NodeType> > &nodeset)
{
	// loop through connectors
	ListIterator<Connector<NodePtr<NodeType> > > 
		connectorIter(*(pnode->getChildren()));
	for ( ; ! connectorIter.done(); connectorIter++)
	{
		// children to delete. required since iterators do not
		// allow the underlying list to be modified while
		// they exist.
		//
		List<NodePtr<NodeType> > nodesToRemove;
		nodesToRemove.clear();

		// loop through children
		ListIterator<NodePtr<NodeType> > childrenIter(connectorIter());
		for ( ; ! childrenIter.done(); childrenIter++)
		{
			// check if node already exists. if not,
			// call heuristic function.
			//
			if (nodeset.isInList(childrenIter()))
			{
				// node already exists, remove it.
				nodesToRemove.insertAtFront(childrenIter());
			}
			else
			{
				// calculate heuristic merit for node
				childrenIter()->heuristic();
			}
		}

		// update connector if duplicates were found
		ListIterator<NodePtr<NodeType> > 
			nodesToRemoveIter(nodesToRemove);
		for ( ; ! nodesToRemoveIter.done(); nodesToRemoveIter++)
		{
			connectorIter().removeByValue(nodesToRemoveIter());
		}

		// check if connector is empty now
		if (connectorIter().isEmpty())
		{
			// update status to unsolvable.
			connectorIter().setStatus(NoSolution);
			connectorIter().setHvalue(INT_MAX);
		}
	}

	// all done
	return(OK);
}

// trace current best-path through the AND/OR graph.
template <class NodeType>
int
TraceCurrentBestPath(NodePtr<NodeType> &pnode, NodePtr<NodeType> &backnode, 
	List<NodePtr<NodeType> > &nodeset)
{
	// check status of incoming node. must have been expanded.
	if (pnode->getStatus() != NotSolved)
	{
		// status can only be not solved. a node
		// that is solved, does not need to be traced.
		// a node that has no solution should not
		// be in the current best path.
		//
		ERROR("node status is not equal to NotSolved.", NOTOK);
		return(NOTOK);
	}

	// loop through connectors to find the current best connector.
	ListIterator<Connector<NodePtr<NodeType> > > 
		connectorIter(*(pnode->getChildren()));
	for ( ; ! connectorIter.done(); connectorIter++)
	{
		if (connectorIter().getMarked())
		{
			// found best path connector
			break;
		}
	}

	// check if we found a connector. if not, it is a error.
	if (connectorIter.done())
	{
		// failed to find a best connector
		ERROR("best current connector was not found.", NOTOK);
		return(NOTOK);
	}

	// scan nodes in connector for a node that is not
	// solved. if any of the nodes is marked as "no
	// solution," then the connector has no solution and
	// we have an error. also, if all the nodes are
	// marked as "solved," then we also have a problem.
	//
	ListIterator<NodePtr<NodeType> > 
		childrenIter(connectorIter());
	for ( ; ! childrenIter.done(); childrenIter++)
	{
		switch (childrenIter()->getStatus())
		{
		case Solved:
			// skip any nodes that are solved
			continue;

		case NotSolved:
			// we found a node to follow.
			return(TraceCurrentBestPath(childrenIter(), 
					backnode, nodeset));

		case NotExpanded:
			// we found a node to expand.
			if (childrenIter()->expand(backnode) != OK)
			{
				// expansion failed
				ERROR("failed to expand a node.", NOTOK);
				return(NOTOK);
			}
			if (RemoveDuplicates(childrenIter(), nodeset) != OK)
			{
				// unable to remove duplicate nodes
				ERROR("failed to remove duplicate nodes.", NOTOK);
				return(NOTOK);
			}
			else
				return(OK);

		default:
			// anything else is an error.
			ERROR("children status is invalid.", NOTOK);
			return(NOTOK);
		}
	}

	// all nodes are solved. this is an error.
	ERROR("all nodes are solved.", NOTOK);
	return(NOTOK);
}

// AO* search procedure for AND/OR graphs. This procedure is used
// for problem-reduction cases.
//
template <class NodeType>
int
BestFirst_AOstar(const NodeType &start)
{
	// copy start state, start of solution graph.
	NodePtr<NodeType> pstart(start);

	// calculate the heuristic value for this node
	pstart->heuristic();

	// node that needs back-propagating
	NodePtr<NodeType> backnode;

	// set of all nodes. used to prevent duplicates
	List<NodePtr<NodeType> > nodeset;
	nodeset.insertAtEnd(pstart);

	// expand start state
	if (pstart->expand(backnode) != OK)
	{
		// expansion failed
		ERROR("failed to expand a node.", NOTOK);
		return(NOTOK);
	}

	// remove any duplicate nodes
	if (RemoveDuplicates(pstart, nodeset) != OK)
	{
		// unable to remove duplicate nodes from graph
		ERROR("failed to remove duplicate nodes from graph.", NOTOK);
		return(NOTOK);
	}

	// back propagate the states of the new nodes
	if (BackPropagate(pstart, backnode) != OK)
	{
		// back-propagation failed
		ERROR("failed to back propagate changes.", NOTOK);
		return(NOTOK);
	}

	// repeat the process of expanding nodes and back propagating
	// costs until the start node is solved or it is marked 
	// as having no solution.
	// 
	while (pstart->getStatus() == NotSolved)
	{
		// trace through current best path
		if (TraceCurrentBestPath(pstart, backnode, nodeset) != OK)
		{
			// trace failed
			ERROR("trace of current best path failed.", NOTOK);
			return(NOTOK);
		}

		// back propagate the states of the new nodes
		if (BackPropagate(pstart, backnode) != OK)
		{
			// back-propagation failed
			ERROR("failed to back propagate changes.", NOTOK);
			return(NOTOK);
		}
	}

	// finished. check if search succeeded.
	if (pstart->getStatus() == Solved)
	{
		// a solution was found
		PrintSolution(pstart);
		return(OK);
	}
	else
	{
		// no solution was found
		ERROR("problem has no solution.", NOTOK);
		return(NOTOK);
	}
}

