1) to create a vector of numbers:

> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)

other ways to assign data  ...

> assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))

or

c(10.4, 5.6, 3.1, 6.4, 21.7) -> x

2) using vectors to do arithmetic:

> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
> x
[1] 10.4  5.6  3.1  6.4 21.7
> exp(x)
[1] 3.285963e+04 2.704264e+02 2.219795e+01 6.018450e+02 2.655769e+09
> 1/x
[1] 0.09615385 0.17857143 0.32258065 0.15625000 0.04608295
> log(x)
[1] 2.341806 1.722767 1.131402 1.856298 3.077312
>
> y <- c(1/x, 0, x)
> y
 [1]  0.09615385  0.17857143  0.32258065  0.15625000  0.04608295  0.00000000
 [7] 10.40000000  5.60000000  3.10000000  6.40000000 21.70000000
>

3) other vector functions ...

> sum(x)
[1] 47.2
> var(x)
[1] 53.853
> mean(x)
[1] 9.44
> x
[1] 10.4  5.6  3.1  6.4 21.7
> sort(x)
[1]  3.1  5.6  6.4 10.4 21.7
> max(x)
[1] 21.7
> min(x)
[1] 3.1
>
> rm(y)
>
> y <- c(mean(x), var(x), min(x), max(x))
> y
[1]  9.440 53.853  3.100 21.700
> x
[1] 10.4  5.6  3.1  6.4 21.7

4) generating sequences. 

notice that the ":" operator has a very high priority (higher than 
arithmetic operations):


> n <- 10
> n
[1] 10

> 1:n-1
 [1] 0 1 2 3 4 5 6 7 8 9

> 1:(n-1)
[1] 1 2 3 4 5 6 7 8 9

> 10:1
 [1] 10  9  8  7  6  5  4  3  2  1

5) function seq(...) is a generalization of ":" operator:

seq() has five parameters, from, to, by, length, and "along".
> seq(1,10)
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(from=1,to=10)
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(from=1,to=10,by=0.7)
 [1] 1.0 1.7 2.4 3.1 3.8 4.5 5.2 5.9 6.6 7.3 8.0 8.7 9.4
> seq(from=1,by=0.333,length=12)
 [1] 1.000 1.333 1.666 1.999 2.332 2.665 2.998 3.331 3.664 3.997 4.330 4.663

examples of along= ...

> x <- 1:10
> y <- x*x
> x
 [1]  1  2  3  4  5  6  7  8  9 10
> y
 [1]   1   4   9  16  25  36  49  64  81 100
> seq(along=y)
 [1]  1  2  3  4  5  6  7  8  9 10
>
> seq(from=20, along=y)
 [1] 20 21 22 23 24 25 26 27 28 29

7) logical vectors are generated by comparing vectors with 
logical operators: <, <=, ==, >=, >

>  x <- runif(10, min=0, max=2)
> x
 [1] 0.1007665 1.6784742 0.2624294 1.3488048 1.8019269 1.4337432 1.8027584
 [8] 0.7994354 0.6759900 0.8933024

> x > 1
 [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE

> 1 < x && x < 1.5
[1] FALSE

> x < 1.5
 [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE

> 1 < x
 [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE

> x
 [1] 0.1007665 1.6784742 0.2624294 1.3488048 1.8019269 1.4337432 1.8027584
 [8] 0.7994354 0.6759900 0.8933024

8) missing values

In some cases the components of a vector may not be completely known. When 
an element or value is “not available” or a “missing value” in the 
statistical sense, a place within a vector may be reserved for it by 
assigning it the special value NA. In general any operation on an NA
becomes an NA. The motivation for this rule is simply that if the 
specification of an operation is incomplete, the result cannot be known 
and hence is not available.

The function is.na(x) gives a logical vector of the same size as x with 
\value TRUE if and only if the corresponding element in x is NA.

> z <- c(1:3,NA); ind <- is.na(z)

Notice that the logical expression x == NA is quite different from 
is.na(x) since NA is not really a value but a marker for a quantity 
that is not available. Thus x == NA is a vector of the
same length as x all of whose values are NA as the 
logical expression itself is incomplete and hence undecidable.

Note that there is a second kind of “missing” values which are produced 
by numerical computation, the so-called Not a Number, NaN, values. 

Examples are
> 0/0
or
> Inf - Inf

In summary, is.na(xx) is TRUE both for NA and NaN values. 
To differentiate these, is.nan(xx) is only TRUE for NaNs

9)  character vectors - can be constructed using paste(...);

> x <- paste('a', 'b', 'c', 'd')
> x
[1] "a b c d"

> x <- paste('a', 'b', 'c', 'd', sep="+-+")
> x
[1] "a+-+b+-+c+-+d"

>
> labs <- paste(c("X", "Y"), 1:10, sep="")
> labs
 [1] "X1"  "Y2"  "X3"  "Y4"  "X5"  "Y6"  "X7"  "Y8"  "X9"  "Y10"

note: shorter sequences are repeated to match the longer sequence.

10) logical vectors used to select values in vectors:

> x <- c(1,-2,3,0/0,NA,4,5,1/0,NA,-5)
> x
 [1]   1  -2   3 NaN  NA   4   5 Inf  NA  -5

> is.na(x)
 [1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE

> is.nan(x)
 [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE

> z <- x[!is.na(x)]
> z
[1]   1  -2   3   4   5 Inf  -5

> z <- (x+1)[(!is.na(x)) & x>0]
> z
[1]   2   4   5   6 Inf

11) use an index vector to select values in another vector:

> x <- (1:20)^2
> x
 [1]   1   4   9  16  25  36  49  64  81 100 121 144 169 196 225 256 289 324 361
[20] 400

> y <- c(3,5,7,8,9,12,15)
> y
[1]  3  5  7  8  9 12 15

> z <- x[y]
> z
[1]   9  25  49  64  81 144 225

if the vector if indexes is negative, then the values are *NOT* included.

> x <- (1:10)^2
> x
 [1]   1   4   9  16  25  36  49  64  81 100

> y <- c(2,5,8)
> x[y]
[1]  4 25 64

> -y
[1] -2 -5 -8

> x[-y]
[1]   1   9  16  36  49  81 100


12) use a vector of character strings as labels for entries in another
vector:

> fruit <- c(5,10,1,20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
> lunch
 apple orange
     1      5

13) other type of objects:

Vectors are the most important type of object in R, but there are several 
others which we will meet more formally in later sections.

matrices or more generally arrays are multi-dimensional generalizations of 
vectors. In fact, they are vectors that can be indexed by two or more 
indices and will be printed in special ways. See Chapter 5 [Arrays and 
matrices], page 18.

factors provide compact ways to handle categorical data. See Chapter 4 
[Factors], page 16.

lists are a general form of vector in which the various elements need 
not be of the same type, and are often themselves vectors or lists. 
Lists provide a convenient way to return the results of a statistical 
computation. See Section 6.1 [Lists], page 26.

data frames are matrix-like structures, in which the columns can be 
of different types. Think of data frames as ‘data matrices’ with one 
row per observational unit but with (possibly) both numerical and 
categorical variables. Many experiments are best described by data
frames: the treatments are categorical but the response is numeric. 
See Section 6.3 [Data frames], page 27.

functions are themselves objects in R which can be stored in the 
project’s workspace. This provides a simple and convenient way to 
extend R. See Chapter 10 [Writing your own functions], page 42.

